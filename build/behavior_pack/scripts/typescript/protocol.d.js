export const protocol_d_ts='/**\n * Declaration module describing the TypeScript Server protocol\n */\ndeclare namespace ts.server.protocol {\n    const enum CommandTypes {\n        JsxClosingTag = "jsxClosingTag",\n        Brace = "brace",\n        BraceCompletion = "braceCompletion",\n        GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",\n        Change = "change",\n        Close = "close",\n        /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */\n        Completions = "completions",\n        CompletionInfo = "completionInfo",\n        CompletionDetails = "completionEntryDetails",\n        CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",\n        CompileOnSaveEmitFile = "compileOnSaveEmitFile",\n        Configure = "configure",\n        Definition = "definition",\n        DefinitionAndBoundSpan = "definitionAndBoundSpan",\n        Implementation = "implementation",\n        Exit = "exit",\n        FileReferences = "fileReferences",\n        Format = "format",\n        Formatonkey = "formatonkey",\n        Geterr = "geterr",\n        GeterrForProject = "geterrForProject",\n        SemanticDiagnosticsSync = "semanticDiagnosticsSync",\n        SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",\n        SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",\n        NavBar = "navbar",\n        Navto = "navto",\n        NavTree = "navtree",\n        NavTreeFull = "navtree-full",\n        /** @deprecated */\n        Occurrences = "occurrences",\n        DocumentHighlights = "documentHighlights",\n        Open = "open",\n        Quickinfo = "quickinfo",\n        References = "references",\n        Reload = "reload",\n        Rename = "rename",\n        Saveto = "saveto",\n        SignatureHelp = "signatureHelp",\n        Status = "status",\n        TypeDefinition = "typeDefinition",\n        ProjectInfo = "projectInfo",\n        ReloadProjects = "reloadProjects",\n        Unknown = "unknown",\n        OpenExternalProject = "openExternalProject",\n        OpenExternalProjects = "openExternalProjects",\n        CloseExternalProject = "closeExternalProject",\n        UpdateOpen = "updateOpen",\n        GetOutliningSpans = "getOutliningSpans",\n        TodoComments = "todoComments",\n        Indentation = "indentation",\n        DocCommentTemplate = "docCommentTemplate",\n        CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",\n        GetCodeFixes = "getCodeFixes",\n        GetCombinedCodeFix = "getCombinedCodeFix",\n        ApplyCodeActionCommand = "applyCodeActionCommand",\n        GetSupportedCodeFixes = "getSupportedCodeFixes",\n        GetApplicableRefactors = "getApplicableRefactors",\n        GetEditsForRefactor = "getEditsForRefactor",\n        OrganizeImports = "organizeImports",\n        GetEditsForFileRename = "getEditsForFileRename",\n        ConfigurePlugin = "configurePlugin",\n        SelectionRange = "selectionRange",\n        ToggleLineComment = "toggleLineComment",\n        ToggleMultilineComment = "toggleMultilineComment",\n        CommentSelection = "commentSelection",\n        UncommentSelection = "uncommentSelection",\n        PrepareCallHierarchy = "prepareCallHierarchy",\n        ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",\n        ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls",\n        ProvideInlayHints = "provideInlayHints"\n    }\n    /**\n     * A TypeScript Server message\n     */\n    interface Message {\n        /**\n         * Sequence number of the message\n         */\n        seq: number;\n        /**\n         * One of "request", "response", or "event"\n         */\n        type: "request" | "response" | "event";\n    }\n    /**\n     * Client-initiated request message\n     */\n    interface Request extends Message {\n        type: "request";\n        /**\n         * The command to execute\n         */\n        command: string;\n        /**\n         * Object containing arguments for the command\n         */\n        arguments?: any;\n    }\n    /**\n     * Request to reload the project structure for all the opened files\n     */\n    interface ReloadProjectsRequest extends Message {\n        command: CommandTypes.ReloadProjects;\n    }\n    /**\n     * Server-initiated event message\n     */\n    interface Event extends Message {\n        type: "event";\n        /**\n         * Name of event\n         */\n        event: string;\n        /**\n         * Event-specific information\n         */\n        body?: any;\n    }\n    /**\n     * Response by server to client request message.\n     */\n    interface Response extends Message {\n        type: "response";\n        /**\n         * Sequence number of the request message.\n         */\n        request_seq: number;\n        /**\n         * Outcome of the request.\n         */\n        success: boolean;\n        /**\n         * The command requested.\n         */\n        command: string;\n        /**\n         * If success === false, this should always be provided.\n         * Otherwise, may (or may not) contain a success message.\n         */\n        message?: string;\n        /**\n         * Contains message body if success === true.\n         */\n        body?: any;\n        /**\n         * Contains extra information that plugin can include to be passed on\n         */\n        metadata?: unknown;\n        /**\n         * Exposes information about the performance of this request-response pair.\n         */\n        performanceData?: PerformanceData;\n    }\n    interface PerformanceData {\n        /**\n         * Time spent updating the program graph, in milliseconds.\n         */\n        updateGraphDurationMs?: number;\n        /**\n         * The time spent creating or updating the auto-import program, in milliseconds.\n         */\n        createAutoImportProviderProgramDurationMs?: number;\n    }\n    /**\n     * Arguments for FileRequest messages.\n     */\n    interface FileRequestArgs {\n        /**\n         * The file for the request (absolute pathname required).\n         */\n        file: string;\n        projectFileName?: string;\n    }\n    interface StatusRequest extends Request {\n        command: CommandTypes.Status;\n    }\n    interface StatusResponseBody {\n        /**\n         * The TypeScript version (`ts.version`).\n         */\n        version: string;\n    }\n    /**\n     * Response to StatusRequest\n     */\n    interface StatusResponse extends Response {\n        body: StatusResponseBody;\n    }\n    /**\n     * Requests a JS Doc comment template for a given position\n     */\n    interface DocCommentTemplateRequest extends FileLocationRequest {\n        command: CommandTypes.DocCommentTemplate;\n    }\n    /**\n     * Response to DocCommentTemplateRequest\n     */\n    interface DocCommandTemplateResponse extends Response {\n        body?: TextInsertion;\n    }\n    /**\n     * A request to get TODO comments from the file\n     */\n    interface TodoCommentRequest extends FileRequest {\n        command: CommandTypes.TodoComments;\n        arguments: TodoCommentRequestArgs;\n    }\n    /**\n     * Arguments for TodoCommentRequest request.\n     */\n    interface TodoCommentRequestArgs extends FileRequestArgs {\n        /**\n         * Array of target TodoCommentDescriptors that describes TODO comments to be found\n         */\n        descriptors: TodoCommentDescriptor[];\n    }\n    /**\n     * Response for TodoCommentRequest request.\n     */\n    interface TodoCommentsResponse extends Response {\n        body?: TodoComment[];\n    }\n    /**\n     * A request to determine if the caret is inside a comment.\n     */\n    interface SpanOfEnclosingCommentRequest extends FileLocationRequest {\n        command: CommandTypes.GetSpanOfEnclosingComment;\n        arguments: SpanOfEnclosingCommentRequestArgs;\n    }\n    interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.\n         */\n        onlyMultiLine: boolean;\n    }\n    /**\n     * Request to obtain outlining spans in file.\n     */\n    interface OutliningSpansRequest extends FileRequest {\n        command: CommandTypes.GetOutliningSpans;\n    }\n    interface OutliningSpan {\n        /** The span of the document to actually collapse. */\n        textSpan: TextSpan;\n        /** The span of the document to display when the user hovers over the collapsed span. */\n        hintSpan: TextSpan;\n        /** The text to display in the editor for the collapsed region. */\n        bannerText: string;\n        /**\n         * Whether or not this region should be automatically collapsed when\n         * the \'Collapse to Definitions\' command is invoked.\n         */\n        autoCollapse: boolean;\n        /**\n         * Classification of the contents of the span\n         */\n        kind: OutliningSpanKind;\n    }\n    /**\n     * Response to OutliningSpansRequest request.\n     */\n    interface OutliningSpansResponse extends Response {\n        body?: OutliningSpan[];\n    }\n    /**\n     * A request to get indentation for a location in file\n     */\n    interface IndentationRequest extends FileLocationRequest {\n        command: CommandTypes.Indentation;\n        arguments: IndentationRequestArgs;\n    }\n    /**\n     * Response for IndentationRequest request.\n     */\n    interface IndentationResponse extends Response {\n        body?: IndentationResult;\n    }\n    /**\n     * Indentation result representing where indentation should be placed\n     */\n    interface IndentationResult {\n        /**\n         * The base position in the document that the indent should be relative to\n         */\n        position: number;\n        /**\n         * The number of columns the indent should be at relative to the position\'s column.\n         */\n        indentation: number;\n    }\n    /**\n     * Arguments for IndentationRequest request.\n     */\n    interface IndentationRequestArgs extends FileLocationRequestArgs {\n        /**\n         * An optional set of settings to be used when computing indentation.\n         * If argument is omitted - then it will use settings for file that were previously set via \'configure\' request or global settings.\n         */\n        options?: EditorSettings;\n    }\n    /**\n     * Arguments for ProjectInfoRequest request.\n     */\n    interface ProjectInfoRequestArgs extends FileRequestArgs {\n        /**\n         * Indicate if the file name list of the project is needed\n         */\n        needFileNameList: boolean;\n    }\n    /**\n     * A request to get the project information of the current file.\n     */\n    interface ProjectInfoRequest extends Request {\n        command: CommandTypes.ProjectInfo;\n        arguments: ProjectInfoRequestArgs;\n    }\n    /**\n     * A request to retrieve compiler options diagnostics for a project\n     */\n    interface CompilerOptionsDiagnosticsRequest extends Request {\n        arguments: CompilerOptionsDiagnosticsRequestArgs;\n    }\n    /**\n     * Arguments for CompilerOptionsDiagnosticsRequest request.\n     */\n    interface CompilerOptionsDiagnosticsRequestArgs {\n        /**\n         * Name of the project to retrieve compiler options diagnostics.\n         */\n        projectFileName: string;\n    }\n    /**\n     * Response message body for "projectInfo" request\n     */\n    interface ProjectInfo {\n        /**\n         * For configured project, this is the normalized path of the \'tsconfig.json\' file\n         * For inferred project, this is undefined\n         */\n        configFileName: string;\n        /**\n         * The list of normalized file name in the project, including \'lib.d.ts\'\n         */\n        fileNames?: string[];\n        /**\n         * Indicates if the project has a active language service instance\n         */\n        languageServiceDisabled?: boolean;\n    }\n    /**\n     * Represents diagnostic info that includes location of diagnostic in two forms\n     * - start position and length of the error span\n     * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.\n     */\n    interface DiagnosticWithLinePosition {\n        message: string;\n        start: number;\n        length: number;\n        startLocation: Location;\n        endLocation: Location;\n        category: string;\n        code: number;\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n        relatedInformation?: DiagnosticRelatedInformation[];\n    }\n    /**\n     * Response message for "projectInfo" request\n     */\n    interface ProjectInfoResponse extends Response {\n        body?: ProjectInfo;\n    }\n    /**\n     * Request whose sole parameter is a file name.\n     */\n    interface FileRequest extends Request {\n        arguments: FileRequestArgs;\n    }\n    /**\n     * Instances of this interface specify a location in a source file:\n     * (file, line, character offset), where line and character offset are 1-based.\n     */\n    interface FileLocationRequestArgs extends FileRequestArgs {\n        /**\n         * The line number for the request (1-based).\n         */\n        line: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        offset: number;\n    }\n    type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;\n    /**\n     * Request refactorings at a given position or selection area.\n     */\n    interface GetApplicableRefactorsRequest extends Request {\n        command: CommandTypes.GetApplicableRefactors;\n        arguments: GetApplicableRefactorsRequestArgs;\n    }\n    type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {\n        triggerReason?: RefactorTriggerReason;\n        kind?: string;\n    };\n    type RefactorTriggerReason = "implicit" | "invoked";\n    /**\n     * Response is a list of available refactorings.\n     * Each refactoring exposes one or more "Actions"; a user selects one action to invoke a refactoring\n     */\n    interface GetApplicableRefactorsResponse extends Response {\n        body?: ApplicableRefactorInfo[];\n    }\n    /**\n     * A set of one or more available refactoring actions, grouped under a parent refactoring.\n     */\n    interface ApplicableRefactorInfo {\n        /**\n         * The programmatic name of the refactoring\n         */\n        name: string;\n        /**\n         * A description of this refactoring category to show to the user.\n         * If the refactoring gets inlined (see below), this text will not be visible.\n         */\n        description: string;\n        /**\n         * Inlineable refactorings can have their actions hoisted out to the top level\n         * of a context menu. Non-inlineanable refactorings should always be shown inside\n         * their parent grouping.\n         *\n         * If not specified, this value is assumed to be \'true\'\n         */\n        inlineable?: boolean;\n        actions: RefactorActionInfo[];\n    }\n    /**\n     * Represents a single refactoring action - for example, the "Extract Method..." refactor might\n     * offer several actions, each corresponding to a surround class or closure to extract into.\n     */\n    interface RefactorActionInfo {\n        /**\n         * The programmatic name of the refactoring action\n         */\n        name: string;\n        /**\n         * A description of this refactoring action to show to the user.\n         * If the parent refactoring is inlined away, this will be the only text shown,\n         * so this description should make sense by itself if the parent is inlineable=true\n         */\n        description: string;\n        /**\n         * A message to show to the user if the refactoring cannot be applied in\n         * the current context.\n         */\n        notApplicableReason?: string;\n        /**\n         * The hierarchical dotted name of the refactor action.\n         */\n        kind?: string;\n    }\n    interface GetEditsForRefactorRequest extends Request {\n        command: CommandTypes.GetEditsForRefactor;\n        arguments: GetEditsForRefactorRequestArgs;\n    }\n    /**\n     * Request the edits that a particular refactoring action produces.\n     * Callers must specify the name of the refactor and the name of the action.\n     */\n    type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {\n        refactor: string;\n        action: string;\n    };\n    interface GetEditsForRefactorResponse extends Response {\n        body?: RefactorEditInfo;\n    }\n    interface RefactorEditInfo {\n        edits: FileCodeEdits[];\n        /**\n         * An optional location where the editor should start a rename operation once\n         * the refactoring edits have been applied\n         */\n        renameLocation?: Location;\n        renameFilename?: string;\n    }\n    /**\n     * Organize imports by:\n     *   1) Removing unused imports\n     *   2) Coalescing imports from the same module\n     *   3) Sorting imports\n     */\n    interface OrganizeImportsRequest extends Request {\n        command: CommandTypes.OrganizeImports;\n        arguments: OrganizeImportsRequestArgs;\n    }\n    type OrganizeImportsScope = GetCombinedCodeFixScope;\n    interface OrganizeImportsRequestArgs {\n        scope: OrganizeImportsScope;\n        skipDestructiveCodeActions?: boolean;\n    }\n    interface OrganizeImportsResponse extends Response {\n        body: readonly FileCodeEdits[];\n    }\n    interface GetEditsForFileRenameRequest extends Request {\n        command: CommandTypes.GetEditsForFileRename;\n        arguments: GetEditsForFileRenameRequestArgs;\n    }\n    /** Note: Paths may also be directories. */\n    interface GetEditsForFileRenameRequestArgs {\n        readonly oldFilePath: string;\n        readonly newFilePath: string;\n    }\n    interface GetEditsForFileRenameResponse extends Response {\n        body: readonly FileCodeEdits[];\n    }\n    /**\n     * Request for the available codefixes at a specific position.\n     */\n    interface CodeFixRequest extends Request {\n        command: CommandTypes.GetCodeFixes;\n        arguments: CodeFixRequestArgs;\n    }\n    interface GetCombinedCodeFixRequest extends Request {\n        command: CommandTypes.GetCombinedCodeFix;\n        arguments: GetCombinedCodeFixRequestArgs;\n    }\n    interface GetCombinedCodeFixResponse extends Response {\n        body: CombinedCodeActions;\n    }\n    interface ApplyCodeActionCommandRequest extends Request {\n        command: CommandTypes.ApplyCodeActionCommand;\n        arguments: ApplyCodeActionCommandRequestArgs;\n    }\n    interface ApplyCodeActionCommandResponse extends Response {\n    }\n    interface FileRangeRequestArgs extends FileRequestArgs {\n        /**\n         * The line number for the request (1-based).\n         */\n        startLine: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        startOffset: number;\n        /**\n         * The line number for the request (1-based).\n         */\n        endLine: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        endOffset: number;\n    }\n    /**\n     * Instances of this interface specify errorcodes on a specific location in a sourcefile.\n     */\n    interface CodeFixRequestArgs extends FileRangeRequestArgs {\n        /**\n         * Errorcodes we want to get the fixes for.\n         */\n        errorCodes: readonly number[];\n    }\n    interface GetCombinedCodeFixRequestArgs {\n        scope: GetCombinedCodeFixScope;\n        fixId: {};\n    }\n    interface GetCombinedCodeFixScope {\n        type: "file";\n        args: FileRequestArgs;\n    }\n    interface ApplyCodeActionCommandRequestArgs {\n        /** May also be an array of commands. */\n        command: {};\n    }\n    /**\n     * Response for GetCodeFixes request.\n     */\n    interface GetCodeFixesResponse extends Response {\n        body?: CodeAction[];\n    }\n    /**\n     * A request whose arguments specify a file location (file, line, col).\n     */\n    interface FileLocationRequest extends FileRequest {\n        arguments: FileLocationRequestArgs;\n    }\n    /**\n     * A request to get codes of supported code fixes.\n     */\n    interface GetSupportedCodeFixesRequest extends Request {\n        command: CommandTypes.GetSupportedCodeFixes;\n    }\n    /**\n     * A response for GetSupportedCodeFixesRequest request.\n     */\n    interface GetSupportedCodeFixesResponse extends Response {\n        /**\n         * List of error codes supported by the server.\n         */\n        body?: string[];\n    }\n    /**\n     * A request to get encoded semantic classifications for a span in the file\n     */\n    interface EncodedSemanticClassificationsRequest extends FileRequest {\n        arguments: EncodedSemanticClassificationsRequestArgs;\n    }\n    /**\n     * Arguments for EncodedSemanticClassificationsRequest request.\n     */\n    interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {\n        /**\n         * Start position of the span.\n         */\n        start: number;\n        /**\n         * Length of the span.\n         */\n        length: number;\n        /**\n         * Optional parameter for the semantic highlighting response, if absent it\n         * defaults to "original".\n         */\n        format?: "original" | "2020";\n    }\n    /** The response for a EncodedSemanticClassificationsRequest */\n    interface EncodedSemanticClassificationsResponse extends Response {\n        body?: EncodedSemanticClassificationsResponseBody;\n    }\n    /**\n     * Implementation response message. Gives series of text spans depending on the format ar.\n     */\n    interface EncodedSemanticClassificationsResponseBody {\n        endOfLineState: EndOfLineState;\n        spans: number[];\n    }\n    /**\n     * Arguments in document highlight request; include: filesToSearch, file,\n     * line, offset.\n     */\n    interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * List of files to search for document highlights.\n         */\n        filesToSearch: string[];\n    }\n    /**\n     * Go to definition request; value of command field is\n     * "definition". Return response giving the file locations that\n     * define the symbol found in file at location line, col.\n     */\n    interface DefinitionRequest extends FileLocationRequest {\n        command: CommandTypes.Definition;\n    }\n    interface DefinitionAndBoundSpanRequest extends FileLocationRequest {\n        readonly command: CommandTypes.DefinitionAndBoundSpan;\n    }\n    interface DefinitionAndBoundSpanResponse extends Response {\n        readonly body: DefinitionInfoAndBoundSpan;\n    }\n    /**\n     * Go to type request; value of command field is\n     * "typeDefinition". Return response giving the file locations that\n     * define the type for the symbol found in file at location line, col.\n     */\n    interface TypeDefinitionRequest extends FileLocationRequest {\n        command: CommandTypes.TypeDefinition;\n    }\n    /**\n     * Go to implementation request; value of command field is\n     * "implementation". Return response giving the file locations that\n     * implement the symbol found in file at location line, col.\n     */\n    interface ImplementationRequest extends FileLocationRequest {\n        command: CommandTypes.Implementation;\n    }\n    /**\n     * Location in source code expressed as (one-based) line and (one-based) column offset.\n     */\n    interface Location {\n        line: number;\n        offset: number;\n    }\n    /**\n     * Object found in response messages defining a span of text in source code.\n     */\n    interface TextSpan {\n        /**\n         * First character of the definition.\n         */\n        start: Location;\n        /**\n         * One character past last character of the definition.\n         */\n        end: Location;\n    }\n    /**\n     * Object found in response messages defining a span of text in a specific source file.\n     */\n    interface FileSpan extends TextSpan {\n        /**\n         * File containing text span.\n         */\n        file: string;\n    }\n    interface JSDocTagInfo {\n        /** Name of the JSDoc tag */\n        name: string;\n        /**\n         * Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment\n         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.\n         */\n        text?: string | SymbolDisplayPart[];\n    }\n    interface TextSpanWithContext extends TextSpan {\n        contextStart?: Location;\n        contextEnd?: Location;\n    }\n    interface FileSpanWithContext extends FileSpan, TextSpanWithContext {\n    }\n    interface DefinitionInfo extends FileSpanWithContext {\n        /**\n         * When true, the file may or may not exist.\n         */\n        unverified?: boolean;\n    }\n    interface DefinitionInfoAndBoundSpan {\n        definitions: readonly DefinitionInfo[];\n        textSpan: TextSpan;\n    }\n    /**\n     * Definition response message.  Gives text range for definition.\n     */\n    interface DefinitionResponse extends Response {\n        body?: DefinitionInfo[];\n    }\n    interface DefinitionInfoAndBoundSpanResponse extends Response {\n        body?: DefinitionInfoAndBoundSpan;\n    }\n    /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */\n    type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;\n    /**\n     * Definition response message.  Gives text range for definition.\n     */\n    interface TypeDefinitionResponse extends Response {\n        body?: FileSpanWithContext[];\n    }\n    /**\n     * Implementation response message.  Gives text range for implementations.\n     */\n    interface ImplementationResponse extends Response {\n        body?: FileSpanWithContext[];\n    }\n    /**\n     * Request to get brace completion for a location in the file.\n     */\n    interface BraceCompletionRequest extends FileLocationRequest {\n        command: CommandTypes.BraceCompletion;\n        arguments: BraceCompletionRequestArgs;\n    }\n    /**\n     * Argument for BraceCompletionRequest request.\n     */\n    interface BraceCompletionRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Kind of opening brace\n         */\n        openingBrace: string;\n    }\n    interface JsxClosingTagRequest extends FileLocationRequest {\n        readonly command: CommandTypes.JsxClosingTag;\n        readonly arguments: JsxClosingTagRequestArgs;\n    }\n    interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {\n    }\n    interface JsxClosingTagResponse extends Response {\n        readonly body: TextInsertion;\n    }\n    /**\n     * @deprecated\n     * Get occurrences request; value of command field is\n     * "occurrences". Return response giving spans that are relevant\n     * in the file at a given line and column.\n     */\n    interface OccurrencesRequest extends FileLocationRequest {\n        command: CommandTypes.Occurrences;\n    }\n    /** @deprecated */\n    interface OccurrencesResponseItem extends FileSpanWithContext {\n        /**\n         * True if the occurrence is a write location, false otherwise.\n         */\n        isWriteAccess: boolean;\n        /**\n         * True if the occurrence is in a string, undefined otherwise;\n         */\n        isInString?: true;\n    }\n    /** @deprecated */\n    interface OccurrencesResponse extends Response {\n        body?: OccurrencesResponseItem[];\n    }\n    /**\n     * Get document highlights request; value of command field is\n     * "documentHighlights". Return response giving spans that are relevant\n     * in the file at a given line and column.\n     */\n    interface DocumentHighlightsRequest extends FileLocationRequest {\n        command: CommandTypes.DocumentHighlights;\n        arguments: DocumentHighlightsRequestArgs;\n    }\n    /**\n     * Span augmented with extra information that denotes the kind of the highlighting to be used for span.\n     */\n    interface HighlightSpan extends TextSpanWithContext {\n        kind: HighlightSpanKind;\n    }\n    /**\n     * Represents a set of highligh spans for a give name\n     */\n    interface DocumentHighlightsItem {\n        /**\n         * File containing highlight spans.\n         */\n        file: string;\n        /**\n         * Spans to highlight in file.\n         */\n        highlightSpans: HighlightSpan[];\n    }\n    /**\n     * Response for a DocumentHighlightsRequest request.\n     */\n    interface DocumentHighlightsResponse extends Response {\n        body?: DocumentHighlightsItem[];\n    }\n    /**\n     * Find references request; value of command field is\n     * "references". Return response giving the file locations that\n     * reference the symbol found in file at location line, col.\n     */\n    interface ReferencesRequest extends FileLocationRequest {\n        command: CommandTypes.References;\n    }\n    interface ReferencesResponseItem extends FileSpanWithContext {\n        /** Text of line containing the reference.  Including this\n         *  with the response avoids latency of editor loading files\n         * to show text of reference line (the server already has\n         * loaded the referencing files).\n         */\n        lineText: string;\n        /**\n         * True if reference is a write location, false otherwise.\n         */\n        isWriteAccess: boolean;\n        /**\n         * True if reference is a definition, false otherwise.\n         */\n        isDefinition: boolean;\n    }\n    /**\n     * The body of a "references" response message.\n     */\n    interface ReferencesResponseBody {\n        /**\n         * The file locations referencing the symbol.\n         */\n        refs: readonly ReferencesResponseItem[];\n        /**\n         * The name of the symbol.\n         */\n        symbolName: string;\n        /**\n         * The start character offset of the symbol (on the line provided by the references request).\n         */\n        symbolStartOffset: number;\n        /**\n         * The full display name of the symbol.\n         */\n        symbolDisplayString: string;\n    }\n    /**\n     * Response to "references" request.\n     */\n    interface ReferencesResponse extends Response {\n        body?: ReferencesResponseBody;\n    }\n    interface FileReferencesRequest extends FileRequest {\n        command: CommandTypes.FileReferences;\n    }\n    interface FileReferencesResponseBody {\n        /**\n         * The file locations referencing the symbol.\n         */\n        refs: readonly ReferencesResponseItem[];\n        /**\n         * The name of the symbol.\n         */\n        symbolName: string;\n    }\n    interface FileReferencesResponse extends Response {\n        body?: FileReferencesResponseBody;\n    }\n    /**\n     * Argument for RenameRequest request.\n     */\n    interface RenameRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Should text at specified location be found/changed in comments?\n         */\n        findInComments?: boolean;\n        /**\n         * Should text at specified location be found/changed in strings?\n         */\n        findInStrings?: boolean;\n    }\n    /**\n     * Rename request; value of command field is "rename". Return\n     * response giving the file locations that reference the symbol\n     * found in file at location line, col. Also return full display\n     * name of the symbol so that client can print it unambiguously.\n     */\n    interface RenameRequest extends FileLocationRequest {\n        command: CommandTypes.Rename;\n        arguments: RenameRequestArgs;\n    }\n    /**\n     * Information about the item to be renamed.\n     */\n    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n    interface RenameInfoSuccess {\n        /**\n         * True if item can be renamed.\n         */\n        canRename: true;\n        /**\n         * File or directory to rename.\n         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.\n         */\n        fileToRename?: string;\n        /**\n         * Display name of the item to be renamed.\n         */\n        displayName: string;\n        /**\n         * Full display name of item to be renamed.\n         */\n        fullDisplayName: string;\n        /**\n         * The items\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /** Span of text to rename. */\n        triggerSpan: TextSpan;\n    }\n    interface RenameInfoFailure {\n        canRename: false;\n        /**\n         * Error message if item can not be renamed.\n         */\n        localizedErrorMessage: string;\n    }\n    /**\n     *  A group of text spans, all in \'file\'.\n     */\n    interface SpanGroup {\n        /** The file to which the spans apply */\n        file: string;\n        /** The text spans in this group */\n        locs: RenameTextSpan[];\n    }\n    interface RenameTextSpan extends TextSpanWithContext {\n        readonly prefixText?: string;\n        readonly suffixText?: string;\n    }\n    interface RenameResponseBody {\n        /**\n         * Information about the item to be renamed.\n         */\n        info: RenameInfo;\n        /**\n         * An array of span groups (one per file) that refer to the item to be renamed.\n         */\n        locs: readonly SpanGroup[];\n    }\n    /**\n     * Rename response message.\n     */\n    interface RenameResponse extends Response {\n        body?: RenameResponseBody;\n    }\n    /**\n     * Represents a file in external project.\n     * External project is project whose set of files, compilation options and openclose state\n     * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).\n     * External project will exist even if all files in it are closed and should be closed explicitly.\n     * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will\n     * create configured project for every config file but will maintain a link that these projects were created\n     * as a result of opening external project so they should be removed once external project is closed.\n     */\n    interface ExternalFile {\n        /**\n         * Name of file file\n         */\n        fileName: string;\n        /**\n         * Script kind of the file\n         */\n        scriptKind?: ScriptKindName | ts.ScriptKind;\n        /**\n         * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)\n         */\n        hasMixedContent?: boolean;\n        /**\n         * Content of the file\n         */\n        content?: string;\n    }\n    /**\n     * Represent an external project\n     */\n    interface ExternalProject {\n        /**\n         * Project name\n         */\n        projectFileName: string;\n        /**\n         * List of root files in project\n         */\n        rootFiles: ExternalFile[];\n        /**\n         * Compiler options for the project\n         */\n        options: ExternalProjectCompilerOptions;\n        /**\n         * @deprecated typingOptions. Use typeAcquisition instead\n         */\n        typingOptions?: TypeAcquisition;\n        /**\n         * Explicitly specified type acquisition for the project\n         */\n        typeAcquisition?: TypeAcquisition;\n    }\n    interface CompileOnSaveMixin {\n        /**\n         * If compile on save is enabled for the project\n         */\n        compileOnSave?: boolean;\n    }\n    /**\n     * For external projects, some of the project settings are sent together with\n     * compiler settings.\n     */\n    type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;\n    interface FileWithProjectReferenceRedirectInfo {\n        /**\n         * Name of file\n         */\n        fileName: string;\n        /**\n         * True if the file is primarily included in a referenced project\n         */\n        isSourceOfProjectReferenceRedirect: boolean;\n    }\n    /**\n     * Represents a set of changes that happen in project\n     */\n    interface ProjectChanges {\n        /**\n         * List of added files\n         */\n        added: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of removed files\n         */\n        removed: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of updated files\n         */\n        updated: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of files that have had their project reference redirect status updated\n         * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true\n         */\n        updatedRedirects?: FileWithProjectReferenceRedirectInfo[];\n    }\n    /**\n     * Information found in a configure request.\n     */\n    interface ConfigureRequestArguments {\n        /**\n         * Information about the host, for example \'Emacs 24.4\' or\n         * \'Sublime Text version 3075\'\n         */\n        hostInfo?: string;\n        /**\n         * If present, tab settings apply only to this file.\n         */\n        file?: string;\n        /**\n         * The format options to use during formatting and other code editing features.\n         */\n        formatOptions?: FormatCodeSettings;\n        preferences?: UserPreferences;\n        /**\n         * The host\'s additional supported .js file extensions\n         */\n        extraFileExtensions?: FileExtensionInfo[];\n        watchOptions?: WatchOptions;\n    }\n    const enum WatchFileKind {\n        FixedPollingInterval = "FixedPollingInterval",\n        PriorityPollingInterval = "PriorityPollingInterval",\n        DynamicPriorityPolling = "DynamicPriorityPolling",\n        FixedChunkSizePolling = "FixedChunkSizePolling",\n        UseFsEvents = "UseFsEvents",\n        UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"\n    }\n    const enum WatchDirectoryKind {\n        UseFsEvents = "UseFsEvents",\n        FixedPollingInterval = "FixedPollingInterval",\n        DynamicPriorityPolling = "DynamicPriorityPolling",\n        FixedChunkSizePolling = "FixedChunkSizePolling"\n    }\n    const enum PollingWatchKind {\n        FixedInterval = "FixedInterval",\n        PriorityInterval = "PriorityInterval",\n        DynamicPriority = "DynamicPriority",\n        FixedChunkSize = "FixedChunkSize"\n    }\n    interface WatchOptions {\n        watchFile?: WatchFileKind | ts.WatchFileKind;\n        watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;\n        fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;\n        synchronousWatchDirectory?: boolean;\n        excludeDirectories?: string[];\n        excludeFiles?: string[];\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    /**\n     *  Configure request; value of command field is "configure".  Specifies\n     *  host information, such as host type, tab size, and indent size.\n     */\n    interface ConfigureRequest extends Request {\n        command: CommandTypes.Configure;\n        arguments: ConfigureRequestArguments;\n    }\n    /**\n     * Response to "configure" request.  This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface ConfigureResponse extends Response {\n    }\n    interface ConfigurePluginRequestArguments {\n        pluginName: string;\n        configuration: any;\n    }\n    interface ConfigurePluginRequest extends Request {\n        command: CommandTypes.ConfigurePlugin;\n        arguments: ConfigurePluginRequestArguments;\n    }\n    interface ConfigurePluginResponse extends Response {\n    }\n    interface SelectionRangeRequest extends FileRequest {\n        command: CommandTypes.SelectionRange;\n        arguments: SelectionRangeRequestArgs;\n    }\n    interface SelectionRangeRequestArgs extends FileRequestArgs {\n        locations: Location[];\n    }\n    interface SelectionRangeResponse extends Response {\n        body?: SelectionRange[];\n    }\n    interface SelectionRange {\n        textSpan: TextSpan;\n        parent?: SelectionRange;\n    }\n    interface ToggleLineCommentRequest extends FileRequest {\n        command: CommandTypes.ToggleLineComment;\n        arguments: FileRangeRequestArgs;\n    }\n    interface ToggleMultilineCommentRequest extends FileRequest {\n        command: CommandTypes.ToggleMultilineComment;\n        arguments: FileRangeRequestArgs;\n    }\n    interface CommentSelectionRequest extends FileRequest {\n        command: CommandTypes.CommentSelection;\n        arguments: FileRangeRequestArgs;\n    }\n    interface UncommentSelectionRequest extends FileRequest {\n        command: CommandTypes.UncommentSelection;\n        arguments: FileRangeRequestArgs;\n    }\n    /**\n     *  Information found in an "open" request.\n     */\n    interface OpenRequestArgs extends FileRequestArgs {\n        /**\n         * Used when a version of the file content is known to be more up to date than the one on disk.\n         * Then the known content will be used upon opening instead of the disk copy\n         */\n        fileContent?: string;\n        /**\n         * Used to specify the script kind of the file explicitly. It could be one of the following:\n         *      "TS", "JS", "TSX", "JSX"\n         */\n        scriptKindName?: ScriptKindName;\n        /**\n         * Used to limit the searching for project config file. If given the searching will stop at this\n         * root path; otherwise it will go all the way up to the dist root path.\n         */\n        projectRootPath?: string;\n    }\n    type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";\n    /**\n     * Open request; value of command field is "open". Notify the\n     * server that the client has file open.  The server will not\n     * monitor the filesystem for changes in this file and will assume\n     * that the client is updating the server (using the change and/or\n     * reload messages) when the file changes. Server does not currently\n     * send a response to an open request.\n     */\n    interface OpenRequest extends Request {\n        command: CommandTypes.Open;\n        arguments: OpenRequestArgs;\n    }\n    /**\n     * Request to open or update external project\n     */\n    interface OpenExternalProjectRequest extends Request {\n        command: CommandTypes.OpenExternalProject;\n        arguments: OpenExternalProjectArgs;\n    }\n    /**\n     * Arguments to OpenExternalProjectRequest request\n     */\n    type OpenExternalProjectArgs = ExternalProject;\n    /**\n     * Request to open multiple external projects\n     */\n    interface OpenExternalProjectsRequest extends Request {\n        command: CommandTypes.OpenExternalProjects;\n        arguments: OpenExternalProjectsArgs;\n    }\n    /**\n     * Arguments to OpenExternalProjectsRequest\n     */\n    interface OpenExternalProjectsArgs {\n        /**\n         * List of external projects to open or update\n         */\n        projects: ExternalProject[];\n    }\n    /**\n     * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface OpenExternalProjectResponse extends Response {\n    }\n    /**\n     * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface OpenExternalProjectsResponse extends Response {\n    }\n    /**\n     * Request to close external project.\n     */\n    interface CloseExternalProjectRequest extends Request {\n        command: CommandTypes.CloseExternalProject;\n        arguments: CloseExternalProjectRequestArgs;\n    }\n    /**\n     * Arguments to CloseExternalProjectRequest request\n     */\n    interface CloseExternalProjectRequestArgs {\n        /**\n         * Name of the project to close\n         */\n        projectFileName: string;\n    }\n    /**\n     * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface CloseExternalProjectResponse extends Response {\n    }\n    /**\n     * Request to synchronize list of open files with the client\n     */\n    interface UpdateOpenRequest extends Request {\n        command: CommandTypes.UpdateOpen;\n        arguments: UpdateOpenRequestArgs;\n    }\n    /**\n     * Arguments to UpdateOpenRequest\n     */\n    interface UpdateOpenRequestArgs {\n        /**\n         * List of newly open files\n         */\n        openFiles?: OpenRequestArgs[];\n        /**\n         * List of open files files that were changes\n         */\n        changedFiles?: FileCodeEdits[];\n        /**\n         * List of files that were closed\n         */\n        closedFiles?: string[];\n    }\n    /**\n     * External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.\n     */\n    type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;\n    /**\n     * Request to set compiler options for inferred projects.\n     * External projects are opened / closed explicitly.\n     * Configured projects are opened when user opens loose file that has \'tsconfig.json\' or \'jsconfig.json\' anywhere in one of containing folders.\n     * This configuration file will be used to obtain a list of files and configuration settings for the project.\n     * Inferred projects are created when user opens a loose file that is not the part of external project\n     * or configured project and will contain only open file and transitive closure of referenced files if \'useOneInferredProject\' is false,\n     * or all open loose files and its transitive closure of referenced files if \'useOneInferredProject\' is true.\n     */\n    interface SetCompilerOptionsForInferredProjectsRequest extends Request {\n        command: CommandTypes.CompilerOptionsForInferredProjects;\n        arguments: SetCompilerOptionsForInferredProjectsArgs;\n    }\n    /**\n     * Argument for SetCompilerOptionsForInferredProjectsRequest request.\n     */\n    interface SetCompilerOptionsForInferredProjectsArgs {\n        /**\n         * Compiler options to be used with inferred projects.\n         */\n        options: InferredProjectCompilerOptions;\n        /**\n         * Specifies the project root path used to scope compiler options.\n         * It is an error to provide this property if the server has not been started with\n         * `useInferredProjectPerProjectRoot` enabled.\n         */\n        projectRootPath?: string;\n    }\n    /**\n     * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface SetCompilerOptionsForInferredProjectsResponse extends Response {\n    }\n    /**\n     *  Exit request; value of command field is "exit".  Ask the server process\n     *  to exit.\n     */\n    interface ExitRequest extends Request {\n        command: CommandTypes.Exit;\n    }\n    /**\n     * Close request; value of command field is "close". Notify the\n     * server that the client has closed a previously open file.  If\n     * file is still referenced by open files, the server will resume\n     * monitoring the filesystem for changes to file.  Server does not\n     * currently send a response to a close request.\n     */\n    interface CloseRequest extends FileRequest {\n        command: CommandTypes.Close;\n    }\n    /**\n     * Request to obtain the list of files that should be regenerated if target file is recompiled.\n     * NOTE: this us query-only operation and does not generate any output on disk.\n     */\n    interface CompileOnSaveAffectedFileListRequest extends FileRequest {\n        command: CommandTypes.CompileOnSaveAffectedFileList;\n    }\n    /**\n     * Contains a list of files that should be regenerated in a project\n     */\n    interface CompileOnSaveAffectedFileListSingleProject {\n        /**\n         * Project name\n         */\n        projectFileName: string;\n        /**\n         * List of files names that should be recompiled\n         */\n        fileNames: string[];\n        /**\n         * true if project uses outFile or out compiler option\n         */\n        projectUsesOutFile: boolean;\n    }\n    /**\n     * Response for CompileOnSaveAffectedFileListRequest request;\n     */\n    interface CompileOnSaveAffectedFileListResponse extends Response {\n        body: CompileOnSaveAffectedFileListSingleProject[];\n    }\n    /**\n     * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.\n     */\n    interface CompileOnSaveEmitFileRequest extends FileRequest {\n        command: CommandTypes.CompileOnSaveEmitFile;\n        arguments: CompileOnSaveEmitFileRequestArgs;\n    }\n    /**\n     * Arguments for CompileOnSaveEmitFileRequest\n     */\n    interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {\n        /**\n         * if true - then file should be recompiled even if it does not have any changes.\n         */\n        forced?: boolean;\n        includeLinePosition?: boolean;\n        /** if true - return response as object with emitSkipped and diagnostics */\n        richResponse?: boolean;\n    }\n    interface CompileOnSaveEmitFileResponse extends Response {\n        body: boolean | EmitResult;\n    }\n    interface EmitResult {\n        emitSkipped: boolean;\n        diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    /**\n     * Quickinfo request; value of command field is\n     * "quickinfo". Return response giving a quick type and\n     * documentation string for the symbol found in file at location\n     * line, col.\n     */\n    interface QuickInfoRequest extends FileLocationRequest {\n        command: CommandTypes.Quickinfo;\n        arguments: FileLocationRequestArgs;\n    }\n    /**\n     * Body of QuickInfoResponse.\n     */\n    interface QuickInfoResponseBody {\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /**\n         * Starting file location of symbol.\n         */\n        start: Location;\n        /**\n         * One past last character of symbol.\n         */\n        end: Location;\n        /**\n         * Type and kind of symbol.\n         */\n        displayString: string;\n        /**\n         * Documentation associated with symbol.\n         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.\n         */\n        documentation: string | SymbolDisplayPart[];\n        /**\n         * JSDoc tags associated with symbol.\n         */\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Quickinfo response message.\n     */\n    interface QuickInfoResponse extends Response {\n        body?: QuickInfoResponseBody;\n    }\n    /**\n     * Arguments for format messages.\n     */\n    interface FormatRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Last line of range for which to format text in file.\n         */\n        endLine: number;\n        /**\n         * Character offset on last line of range for which to format text in file.\n         */\n        endOffset: number;\n        /**\n         * Format options to be used.\n         */\n        options?: FormatCodeSettings;\n    }\n    /**\n     * Format request; value of command field is "format".  Return\n     * response giving zero or more edit instructions.  The edit\n     * instructions will be sorted in file order.  Applying the edit\n     * instructions in reverse to file will result in correctly\n     * reformatted text.\n     */\n    interface FormatRequest extends FileLocationRequest {\n        command: CommandTypes.Format;\n        arguments: FormatRequestArgs;\n    }\n    /**\n     * Object found in response messages defining an editing\n     * instruction for a span of text in source code.  The effect of\n     * this instruction is to replace the text starting at start and\n     * ending one character before end with newText. For an insertion,\n     * the text span is empty.  For a deletion, newText is empty.\n     */\n    interface CodeEdit {\n        /**\n         * First character of the text span to edit.\n         */\n        start: Location;\n        /**\n         * One character past last character of the text span to edit.\n         */\n        end: Location;\n        /**\n         * Replace the span defined above with this string (may be\n         * the empty string).\n         */\n        newText: string;\n    }\n    interface FileCodeEdits {\n        fileName: string;\n        textChanges: CodeEdit[];\n    }\n    interface CodeFixResponse extends Response {\n        /** The code actions that are available */\n        body?: CodeFixAction[];\n    }\n    interface CodeAction {\n        /** Description of the code action to display in the UI of the editor */\n        description: string;\n        /** Text changes to apply to each file as part of the code action */\n        changes: FileCodeEdits[];\n        /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */\n        commands?: {}[];\n    }\n    interface CombinedCodeActions {\n        changes: readonly FileCodeEdits[];\n        commands?: readonly {}[];\n    }\n    interface CodeFixAction extends CodeAction {\n        /** Short name to identify the fix, for use by telemetry. */\n        fixName: string;\n        /**\n         * If present, one may call \'getCombinedCodeFix\' with this fixId.\n         * This may be omitted to indicate that the code fix can\'t be applied in a group.\n         */\n        fixId?: {};\n        /** Should be present if and only if \'fixId\' is. */\n        fixAllDescription?: string;\n    }\n    /**\n     * Format and format on key response message.\n     */\n    interface FormatResponse extends Response {\n        body?: CodeEdit[];\n    }\n    /**\n     * Arguments for format on key messages.\n     */\n    interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Key pressed (\';\', \'\n\', or \'}\').\n         */\n        key: string;\n        options?: FormatCodeSettings;\n    }\n    /**\n     * Format on key request; value of command field is\n     * "formatonkey". Given file location and key typed (as string),\n     * return response giving zero or more edit instructions.  The\n     * edit instructions will be sorted in file order.  Applying the\n     * edit instructions in reverse to file will result in correctly\n     * reformatted text.\n     */\n    interface FormatOnKeyRequest extends FileLocationRequest {\n        command: CommandTypes.Formatonkey;\n        arguments: FormatOnKeyRequestArgs;\n    }\n    type CompletionsTriggerCharacter = "." | \'"\' | "\'" | "`" | "/" | "@" | "<" | "#" | " ";\n    const enum CompletionTriggerKind {\n        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */\n        Invoked = 1,\n        /** Completion was triggered by a trigger character. */\n        TriggerCharacter = 2,\n        /** Completion was re-triggered as the current completion list is incomplete. */\n        TriggerForIncompleteCompletions = 3\n    }\n    /**\n     * Arguments for completions messages.\n     */\n    interface CompletionsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Optional prefix to apply to possible completions.\n         */\n        prefix?: string;\n        /**\n         * Character that was responsible for triggering completion.\n         * Should be `undefined` if a user manually requested completion.\n         */\n        triggerCharacter?: CompletionsTriggerCharacter;\n        triggerKind?: CompletionTriggerKind;\n        /**\n         * @deprecated Use UserPreferences.includeCompletionsForModuleExports\n         */\n        includeExternalModuleExports?: boolean;\n        /**\n         * @deprecated Use UserPreferences.includeCompletionsWithInsertText\n         */\n        includeInsertTextCompletions?: boolean;\n    }\n    /**\n     * Completions request; value of command field is "completions".\n     * Given a file location (file, line, col) and a prefix (which may\n     * be the empty string), return the possible completions that\n     * begin with prefix.\n     */\n    interface CompletionsRequest extends FileLocationRequest {\n        command: CommandTypes.Completions | CommandTypes.CompletionInfo;\n        arguments: CompletionsRequestArgs;\n    }\n    /**\n     * Arguments for completion details request.\n     */\n    interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Names of one or more entries for which to obtain details.\n         */\n        entryNames: (string | CompletionEntryIdentifier)[];\n    }\n    interface CompletionEntryIdentifier {\n        name: string;\n        source?: string;\n        data?: unknown;\n    }\n    /**\n     * Completion entry details request; value of command field is\n     * "completionEntryDetails".  Given a file location (file, line,\n     * col) and an array of completion entry names return more\n     * detailed information for each completion entry.\n     */\n    interface CompletionDetailsRequest extends FileLocationRequest {\n        command: CommandTypes.CompletionDetails;\n        arguments: CompletionDetailsRequestArgs;\n    }\n    /**\n     * Part of a symbol description.\n     */\n    interface SymbolDisplayPart {\n        /**\n         * Text of an item describing the symbol.\n         */\n        text: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: string;\n    }\n    /** A part of a symbol description that links from a jsdoc @link tag to a declaration */\n    interface JSDocLinkDisplayPart extends SymbolDisplayPart {\n        /** The location of the declaration that the @link tag links to. */\n        target: FileSpan;\n    }\n    /**\n     * An item found in a completion response.\n     */\n    interface CompletionEntry {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * A string that is used for comparing completion items so that they can be ordered.  This\n         * is often the same as the name but may be different in certain circumstances.\n         */\n        sortText: string;\n        /**\n         * Text to insert instead of `name`.\n         * This is used to support bracketed completions; If `name` might be "a-b" but `insertText` would be `["a-b"]`,\n         * coupled with `replacementSpan` to replace a dotted access with a bracket access.\n         */\n        insertText?: string;\n        /**\n         * `insertText` should be interpreted as a snippet if true.\n         */\n        isSnippet?: true;\n        /**\n         * An optional span that indicates the text to be replaced by this completion item.\n         * If present, this span should be used instead of the default one.\n         * It will be set if the required span differs from the one generated by the default replacement behavior.\n         */\n        replacementSpan?: TextSpan;\n        /**\n         * Indicates whether commiting this completion entry will require additional code actions to be\n         * made to avoid errors. The CompletionEntryDetails will have these actions.\n         */\n        hasAction?: true;\n        /**\n         * Identifier (not necessarily human-readable) identifying where this completion came from.\n         */\n        source?: string;\n        /**\n         * Human-readable description of the `source`.\n         */\n        sourceDisplay?: SymbolDisplayPart[];\n        /**\n         * If true, this completion should be highlighted as recommended. There will only be one of these.\n         * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.\n         * Then either that enum/class or a namespace containing it will be the recommended symbol.\n         */\n        isRecommended?: true;\n        /**\n         * If true, this completion was generated from traversing the name table of an unchecked JS file,\n         * and therefore may not be accurate.\n         */\n        isFromUncheckedFile?: true;\n        /**\n         * If true, this completion was for an auto-import of a module not yet in the program, but listed\n         * in the project package.json. Used for telemetry reporting.\n         */\n        isPackageJsonImport?: true;\n        /**\n         * If true, this completion was an auto-import-style completion of an import statement (i.e., the\n         * module specifier was inserted along with the imported identifier). Used for telemetry reporting.\n         */\n        isImportStatementCompletion?: true;\n        /**\n         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,\n         * that allows TS Server to look up the symbol represented by the completion item, disambiguating\n         * items with the same name.\n         */\n        data?: unknown;\n    }\n    /**\n     * Additional completion entry details, available on demand\n     */\n    interface CompletionEntryDetails {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /**\n         * Display parts of the symbol (similar to quick info).\n         */\n        displayParts: SymbolDisplayPart[];\n        /**\n         * Documentation strings for the symbol.\n         */\n        documentation?: SymbolDisplayPart[];\n        /**\n         * JSDoc tags for the symbol.\n         */\n        tags?: JSDocTagInfo[];\n        /**\n         * The associated code actions for this entry\n         */\n        codeActions?: CodeAction[];\n        /**\n         * @deprecated Use `sourceDisplay` instead.\n         */\n        source?: SymbolDisplayPart[];\n        /**\n         * Human-readable description of the `source` from the CompletionEntry.\n         */\n        sourceDisplay?: SymbolDisplayPart[];\n    }\n    /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */\n    interface CompletionsResponse extends Response {\n        body?: CompletionEntry[];\n    }\n    interface CompletionInfoResponse extends Response {\n        body?: CompletionInfo;\n    }\n    interface CompletionInfo {\n        readonly isGlobalCompletion: boolean;\n        readonly isMemberCompletion: boolean;\n        readonly isNewIdentifierLocation: boolean;\n        /**\n         * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use\n         * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span\n         * must be used to commit that completion entry.\n         */\n        readonly optionalReplacementSpan?: TextSpan;\n        readonly isIncomplete?: boolean;\n        readonly entries: readonly CompletionEntry[];\n    }\n    interface CompletionDetailsResponse extends Response {\n        body?: CompletionEntryDetails[];\n    }\n    /**\n     * Signature help information for a single parameter\n     */\n    interface SignatureHelpParameter {\n        /**\n         * The parameter\'s name\n         */\n        name: string;\n        /**\n         * Documentation of the parameter.\n         */\n        documentation: SymbolDisplayPart[];\n        /**\n         * Display parts of the parameter.\n         */\n        displayParts: SymbolDisplayPart[];\n        /**\n         * Whether the parameter is optional or not.\n         */\n        isOptional: boolean;\n    }\n    /**\n     * Represents a single signature to show in signature help.\n     */\n    interface SignatureHelpItem {\n        /**\n         * Whether the signature accepts a variable number of arguments.\n         */\n        isVariadic: boolean;\n        /**\n         * The prefix display parts.\n         */\n        prefixDisplayParts: SymbolDisplayPart[];\n        /**\n         * The suffix display parts.\n         */\n        suffixDisplayParts: SymbolDisplayPart[];\n        /**\n         * The separator display parts.\n         */\n        separatorDisplayParts: SymbolDisplayPart[];\n        /**\n         * The signature helps items for the parameters.\n         */\n        parameters: SignatureHelpParameter[];\n        /**\n         * The signature\'s documentation\n         */\n        documentation: SymbolDisplayPart[];\n        /**\n         * The signature\'s JSDoc tags\n         */\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Signature help items found in the response of a signature help request.\n     */\n    interface SignatureHelpItems {\n        /**\n         * The signature help items.\n         */\n        items: SignatureHelpItem[];\n        /**\n         * The span for which signature help should appear on a signature\n         */\n        applicableSpan: TextSpan;\n        /**\n         * The item selected in the set of available help items.\n         */\n        selectedItemIndex: number;\n        /**\n         * The argument selected in the set of parameters.\n         */\n        argumentIndex: number;\n        /**\n         * The argument count\n         */\n        argumentCount: number;\n    }\n    type SignatureHelpTriggerCharacter = "," | "(" | "<";\n    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";\n    /**\n     * Arguments of a signature help request.\n     */\n    interface SignatureHelpRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Reason why signature help was invoked.\n         * See each individual possible\n         */\n        triggerReason?: SignatureHelpTriggerReason;\n    }\n    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;\n    /**\n     * Signals that the user manually requested signature help.\n     * The language service will unconditionally attempt to provide a result.\n     */\n    interface SignatureHelpInvokedReason {\n        kind: "invoked";\n        triggerCharacter?: undefined;\n    }\n    /**\n     * Signals that the signature help request came from a user typing a character.\n     * Depending on the character and the syntactic context, the request may or may not be served a result.\n     */\n    interface SignatureHelpCharacterTypedReason {\n        kind: "characterTyped";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter: SignatureHelpTriggerCharacter;\n    }\n    /**\n     * Signals that this signature help request came from typing a character or moving the cursor.\n     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.\n     * The language service will unconditionally attempt to provide a result.\n     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.\n     */\n    interface SignatureHelpRetriggeredReason {\n        kind: "retrigger";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter?: SignatureHelpRetriggerCharacter;\n    }\n    /**\n     * Signature help request; value of command field is "signatureHelp".\n     * Given a file location (file, line, col), return the signature\n     * help.\n     */\n    interface SignatureHelpRequest extends FileLocationRequest {\n        command: CommandTypes.SignatureHelp;\n        arguments: SignatureHelpRequestArgs;\n    }\n    /**\n     * Response object for a SignatureHelpRequest.\n     */\n    interface SignatureHelpResponse extends Response {\n        body?: SignatureHelpItems;\n    }\n    type InlayHintKind = "Type" | "Parameter" | "Enum";\n    interface InlayHintsRequestArgs extends FileRequestArgs {\n        /**\n         * Start position of the span.\n         */\n        start: number;\n        /**\n         * Length of the span.\n         */\n        length: number;\n    }\n    interface InlayHintsRequest extends Request {\n        command: CommandTypes.ProvideInlayHints;\n        arguments: InlayHintsRequestArgs;\n    }\n    interface InlayHintItem {\n        text: string;\n        position: Location;\n        kind: InlayHintKind;\n        whitespaceBefore?: boolean;\n        whitespaceAfter?: boolean;\n    }\n    interface InlayHintsResponse extends Response {\n        body?: InlayHintItem[];\n    }\n    /**\n     * Synchronous request for semantic diagnostics of one file.\n     */\n    interface SemanticDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SemanticDiagnosticsSync;\n        arguments: SemanticDiagnosticsSyncRequestArgs;\n    }\n    interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n        includeLinePosition?: boolean;\n    }\n    /**\n     * Response object for synchronous sematic diagnostics request.\n     */\n    interface SemanticDiagnosticsSyncResponse extends Response {\n        body?: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    interface SuggestionDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SuggestionDiagnosticsSync;\n        arguments: SuggestionDiagnosticsSyncRequestArgs;\n    }\n    type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;\n    type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;\n    /**\n     * Synchronous request for syntactic diagnostics of one file.\n     */\n    interface SyntacticDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SyntacticDiagnosticsSync;\n        arguments: SyntacticDiagnosticsSyncRequestArgs;\n    }\n    interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n        includeLinePosition?: boolean;\n    }\n    /**\n     * Response object for synchronous syntactic diagnostics request.\n     */\n    interface SyntacticDiagnosticsSyncResponse extends Response {\n        body?: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    /**\n     * Arguments for GeterrForProject request.\n     */\n    interface GeterrForProjectRequestArgs {\n        /**\n         * the file requesting project error list\n         */\n        file: string;\n        /**\n         * Delay in milliseconds to wait before starting to compute\n         * errors for the files in the file list\n         */\n        delay: number;\n    }\n    /**\n     * GeterrForProjectRequest request; value of command field is\n     * "geterrForProject". It works similarly with \'Geterr\', only\n     * it request for every file in this project.\n     */\n    interface GeterrForProjectRequest extends Request {\n        command: CommandTypes.GeterrForProject;\n        arguments: GeterrForProjectRequestArgs;\n    }\n    /**\n     * Arguments for geterr messages.\n     */\n    interface GeterrRequestArgs {\n        /**\n         * List of file names for which to compute compiler errors.\n         * The files will be checked in list order.\n         */\n        files: string[];\n        /**\n         * Delay in milliseconds to wait before starting to compute\n         * errors for the files in the file list\n         */\n        delay: number;\n    }\n    /**\n     * Geterr request; value of command field is "geterr". Wait for\n     * delay milliseconds and then, if during the wait no change or\n     * reload messages have arrived for the first file in the files\n     * list, get the syntactic errors for the file, field requests,\n     * and then get the semantic errors for the file.  Repeat with a\n     * smaller delay for each subsequent file on the files list.  Best\n     * practice for an editor is to send a file list containing each\n     * file that is currently visible, in most-recently-used order.\n     */\n    interface GeterrRequest extends Request {\n        command: CommandTypes.Geterr;\n        arguments: GeterrRequestArgs;\n    }\n    type RequestCompletedEventName = "requestCompleted";\n    /**\n     * Event that is sent when server have finished processing request with specified id.\n     */\n    interface RequestCompletedEvent extends Event {\n        event: RequestCompletedEventName;\n        body: RequestCompletedEventBody;\n    }\n    interface RequestCompletedEventBody {\n        request_seq: number;\n    }\n    /**\n     * Item of diagnostic information found in a DiagnosticEvent message.\n     */\n    interface Diagnostic {\n        /**\n         * Starting file location at which text applies.\n         */\n        start: Location;\n        /**\n         * The last file location at which the text applies.\n         */\n        end: Location;\n        /**\n         * Text of diagnostic message.\n         */\n        text: string;\n        /**\n         * The category of the diagnostic message, e.g. "error", "warning", or "suggestion".\n         */\n        category: string;\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n        /**\n         * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites\n         */\n        relatedInformation?: DiagnosticRelatedInformation[];\n        /**\n         * The error code of the diagnostic message.\n         */\n        code?: number;\n        /**\n         * The name of the plugin reporting the message.\n         */\n        source?: string;\n    }\n    interface DiagnosticWithFileName extends Diagnostic {\n        /**\n         * Name of the file the diagnostic is in\n         */\n        fileName: string;\n    }\n    /**\n     * Represents additional spans returned with a diagnostic which are relevant to it\n     */\n    interface DiagnosticRelatedInformation {\n        /**\n         * The category of the related information message, e.g. "error", "warning", or "suggestion".\n         */\n        category: string;\n        /**\n         * The code used ot identify the related information\n         */\n        code: number;\n        /**\n         * Text of related or additional information.\n         */\n        message: string;\n        /**\n         * Associated location\n         */\n        span?: FileSpan;\n    }\n    interface DiagnosticEventBody {\n        /**\n         * The file for which diagnostic information is reported.\n         */\n        file: string;\n        /**\n         * An array of diagnostic information items.\n         */\n        diagnostics: Diagnostic[];\n    }\n    type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag";\n    /**\n     * Event message for DiagnosticEventKind event types.\n     * These events provide syntactic and semantic errors for a file.\n     */\n    interface DiagnosticEvent extends Event {\n        body?: DiagnosticEventBody;\n        event: DiagnosticEventKind;\n    }\n    interface ConfigFileDiagnosticEventBody {\n        /**\n         * The file which trigged the searching and error-checking of the config file\n         */\n        triggerFile: string;\n        /**\n         * The name of the found config file.\n         */\n        configFile: string;\n        /**\n         * An arry of diagnostic information items for the found config file.\n         */\n        diagnostics: DiagnosticWithFileName[];\n    }\n    /**\n     * Event message for "configFileDiag" event type.\n     * This event provides errors for a found config file.\n     */\n    interface ConfigFileDiagnosticEvent extends Event {\n        body?: ConfigFileDiagnosticEventBody;\n        event: "configFileDiag";\n    }\n    type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";\n    interface ProjectLanguageServiceStateEvent extends Event {\n        event: ProjectLanguageServiceStateEventName;\n        body?: ProjectLanguageServiceStateEventBody;\n    }\n    interface ProjectLanguageServiceStateEventBody {\n        /**\n         * Project name that has changes in the state of language service.\n         * For configured projects this will be the config file path.\n         * For external projects this will be the name of the projects specified when project was open.\n         * For inferred projects this event is not raised.\n         */\n        projectName: string;\n        /**\n         * True if language service state switched from disabled to enabled\n         * and false otherwise.\n         */\n        languageServiceEnabled: boolean;\n    }\n    type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";\n    interface ProjectsUpdatedInBackgroundEvent extends Event {\n        event: ProjectsUpdatedInBackgroundEventName;\n        body: ProjectsUpdatedInBackgroundEventBody;\n    }\n    interface ProjectsUpdatedInBackgroundEventBody {\n        /**\n         * Current set of open files\n         */\n        openFiles: string[];\n    }\n    type ProjectLoadingStartEventName = "projectLoadingStart";\n    interface ProjectLoadingStartEvent extends Event {\n        event: ProjectLoadingStartEventName;\n        body: ProjectLoadingStartEventBody;\n    }\n    interface ProjectLoadingStartEventBody {\n        /** name of the project */\n        projectName: string;\n        /** reason for loading */\n        reason: string;\n    }\n    type ProjectLoadingFinishEventName = "projectLoadingFinish";\n    interface ProjectLoadingFinishEvent extends Event {\n        event: ProjectLoadingFinishEventName;\n        body: ProjectLoadingFinishEventBody;\n    }\n    interface ProjectLoadingFinishEventBody {\n        /** name of the project */\n        projectName: string;\n    }\n    type SurveyReadyEventName = "surveyReady";\n    interface SurveyReadyEvent extends Event {\n        event: SurveyReadyEventName;\n        body: SurveyReadyEventBody;\n    }\n    interface SurveyReadyEventBody {\n        /** Name of the survey. This is an internal machine- and programmer-friendly name */\n        surveyId: string;\n    }\n    type LargeFileReferencedEventName = "largeFileReferenced";\n    interface LargeFileReferencedEvent extends Event {\n        event: LargeFileReferencedEventName;\n        body: LargeFileReferencedEventBody;\n    }\n    interface LargeFileReferencedEventBody {\n        /**\n         * name of the large file being loaded\n         */\n        file: string;\n        /**\n         * size of the file\n         */\n        fileSize: number;\n        /**\n         * max file size allowed on the server\n         */\n        maxFileSize: number;\n    }\n    /**\n     * Arguments for reload request.\n     */\n    interface ReloadRequestArgs extends FileRequestArgs {\n        /**\n         * Name of temporary file from which to reload file\n         * contents. May be same as file.\n         */\n        tmpfile: string;\n    }\n    /**\n     * Reload request message; value of command field is "reload".\n     * Reload contents of file with name given by the \'file\' argument\n     * from temporary file with name given by the \'tmpfile\' argument.\n     * The two names can be identical.\n     */\n    interface ReloadRequest extends FileRequest {\n        command: CommandTypes.Reload;\n        arguments: ReloadRequestArgs;\n    }\n    /**\n     * Response to "reload" request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface ReloadResponse extends Response {\n    }\n    /**\n     * Arguments for saveto request.\n     */\n    interface SavetoRequestArgs extends FileRequestArgs {\n        /**\n         * Name of temporary file into which to save server\'s view of\n         * file contents.\n         */\n        tmpfile: string;\n    }\n    /**\n     * Saveto request message; value of command field is "saveto".\n     * For debugging purposes, save to a temporaryfile (named by\n     * argument \'tmpfile\') the contents of file named by argument\n     * \'file\'.  The server does not currently send a response to a\n     * "saveto" request.\n     */\n    interface SavetoRequest extends FileRequest {\n        command: CommandTypes.Saveto;\n        arguments: SavetoRequestArgs;\n    }\n    /**\n     * Arguments for navto request message.\n     */\n    interface NavtoRequestArgs {\n        /**\n         * Search term to navigate to from current location; term can\n         * be \'.*\' or an identifier prefix.\n         */\n        searchValue: string;\n        /**\n         *  Optional limit on the number of items to return.\n         */\n        maxResultCount?: number;\n        /**\n         * The file for the request (absolute pathname required).\n         */\n        file?: string;\n        /**\n         * Optional flag to indicate we want results for just the current file\n         * or the entire project.\n         */\n        currentFileOnly?: boolean;\n        projectFileName?: string;\n    }\n    /**\n     * Navto request message; value of command field is "navto".\n     * Return list of objects giving file locations and symbols that\n     * match the search term given in argument \'searchTerm\'.  The\n     * context for the search is given by the named file.\n     */\n    interface NavtoRequest extends Request {\n        command: CommandTypes.Navto;\n        arguments: NavtoRequestArgs;\n    }\n    /**\n     * An item found in a navto response.\n     */\n    interface NavtoItem extends FileSpan {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * exact, substring, or prefix.\n         */\n        matchKind: string;\n        /**\n         * If this was a case sensitive or insensitive match.\n         */\n        isCaseSensitive: boolean;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * Name of symbol\'s container symbol (if any); for example,\n         * the class name if symbol is a class member.\n         */\n        containerName?: string;\n        /**\n         * Kind of symbol\'s container symbol (if any).\n         */\n        containerKind?: ScriptElementKind;\n    }\n    /**\n     * Navto response message. Body is an array of navto items.  Each\n     * item gives a symbol that matched the search term.\n     */\n    interface NavtoResponse extends Response {\n        body?: NavtoItem[];\n    }\n    /**\n     * Arguments for change request message.\n     */\n    interface ChangeRequestArgs extends FormatRequestArgs {\n        /**\n         * Optional string to insert at location (file, line, offset).\n         */\n        insertString?: string;\n    }\n    /**\n     * Change request message; value of command field is "change".\n     * Update the server\'s view of the file named by argument \'file\'.\n     * Server does not currently send a response to a change request.\n     */\n    interface ChangeRequest extends FileLocationRequest {\n        command: CommandTypes.Change;\n        arguments: ChangeRequestArgs;\n    }\n    /**\n     * Response to "brace" request.\n     */\n    interface BraceResponse extends Response {\n        body?: TextSpan[];\n    }\n    /**\n     * Brace matching request; value of command field is "brace".\n     * Return response giving the file locations of matching braces\n     * found in file at location line, offset.\n     */\n    interface BraceRequest extends FileLocationRequest {\n        command: CommandTypes.Brace;\n    }\n    /**\n     * NavBar items request; value of command field is "navbar".\n     * Return response giving the list of navigation bar entries\n     * extracted from the requested file.\n     */\n    interface NavBarRequest extends FileRequest {\n        command: CommandTypes.NavBar;\n    }\n    /**\n     * NavTree request; value of command field is "navtree".\n     * Return response giving the navigation tree of the requested file.\n     */\n    interface NavTreeRequest extends FileRequest {\n        command: CommandTypes.NavTree;\n    }\n    interface NavigationBarItem {\n        /**\n         * The item\'s display text.\n         */\n        text: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * The definition locations of the item.\n         */\n        spans: TextSpan[];\n        /**\n         * Optional children.\n         */\n        childItems?: NavigationBarItem[];\n        /**\n         * Number of levels deep this item should appear.\n         */\n        indent: number;\n    }\n    /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */\n    interface NavigationTree {\n        text: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        spans: TextSpan[];\n        nameSpan: TextSpan | undefined;\n        childItems?: NavigationTree[];\n    }\n    type TelemetryEventName = "telemetry";\n    interface TelemetryEvent extends Event {\n        event: TelemetryEventName;\n        body: TelemetryEventBody;\n    }\n    interface TelemetryEventBody {\n        telemetryEventName: string;\n        payload: any;\n    }\n    type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";\n    interface TypesInstallerInitializationFailedEvent extends Event {\n        event: TypesInstallerInitializationFailedEventName;\n        body: TypesInstallerInitializationFailedEventBody;\n    }\n    interface TypesInstallerInitializationFailedEventBody {\n        message: string;\n    }\n    type TypingsInstalledTelemetryEventName = "typingsInstalled";\n    interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {\n        telemetryEventName: TypingsInstalledTelemetryEventName;\n        payload: TypingsInstalledTelemetryEventPayload;\n    }\n    interface TypingsInstalledTelemetryEventPayload {\n        /**\n         * Comma separated list of installed typing packages\n         */\n        installedPackages: string;\n        /**\n         * true if install request succeeded, otherwise - false\n         */\n        installSuccess: boolean;\n        /**\n         * version of typings installer\n         */\n        typingsInstallerVersion: string;\n    }\n    type BeginInstallTypesEventName = "beginInstallTypes";\n    type EndInstallTypesEventName = "endInstallTypes";\n    interface BeginInstallTypesEvent extends Event {\n        event: BeginInstallTypesEventName;\n        body: BeginInstallTypesEventBody;\n    }\n    interface EndInstallTypesEvent extends Event {\n        event: EndInstallTypesEventName;\n        body: EndInstallTypesEventBody;\n    }\n    interface InstallTypesEventBody {\n        /**\n         * correlation id to match begin and end events\n         */\n        eventId: number;\n        /**\n         * list of packages to install\n         */\n        packages: readonly string[];\n    }\n    interface BeginInstallTypesEventBody extends InstallTypesEventBody {\n    }\n    interface EndInstallTypesEventBody extends InstallTypesEventBody {\n        /**\n         * true if installation succeeded, otherwise false\n         */\n        success: boolean;\n    }\n    interface NavBarResponse extends Response {\n        body?: NavigationBarItem[];\n    }\n    interface NavTreeResponse extends Response {\n        body?: NavigationTree;\n    }\n    interface CallHierarchyItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        file: string;\n        span: TextSpan;\n        selectionSpan: TextSpan;\n        containerName?: string;\n    }\n    interface CallHierarchyIncomingCall {\n        from: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface CallHierarchyOutgoingCall {\n        to: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface PrepareCallHierarchyRequest extends FileLocationRequest {\n        command: CommandTypes.PrepareCallHierarchy;\n    }\n    interface PrepareCallHierarchyResponse extends Response {\n        readonly body: CallHierarchyItem | CallHierarchyItem[];\n    }\n    interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {\n        command: CommandTypes.ProvideCallHierarchyIncomingCalls;\n    }\n    interface ProvideCallHierarchyIncomingCallsResponse extends Response {\n        readonly body: CallHierarchyIncomingCall[];\n    }\n    interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {\n        command: CommandTypes.ProvideCallHierarchyOutgoingCalls;\n    }\n    interface ProvideCallHierarchyOutgoingCallsResponse extends Response {\n        readonly body: CallHierarchyOutgoingCall[];\n    }\n    const enum IndentStyle {\n        None = "None",\n        Block = "Block",\n        Smart = "Smart"\n    }\n    enum SemicolonPreference {\n        Ignore = "ignore",\n        Insert = "insert",\n        Remove = "remove"\n    }\n    interface EditorSettings {\n        baseIndentSize?: number;\n        indentSize?: number;\n        tabSize?: number;\n        newLineCharacter?: string;\n        convertTabsToSpaces?: boolean;\n        indentStyle?: IndentStyle | ts.IndentStyle;\n        trimTrailingWhitespace?: boolean;\n    }\n    interface FormatCodeSettings extends EditorSettings {\n        insertSpaceAfterCommaDelimiter?: boolean;\n        insertSpaceAfterSemicolonInForStatements?: boolean;\n        insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n        insertSpaceAfterConstructor?: boolean;\n        insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n        insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        insertSpaceAfterTypeAssertion?: boolean;\n        insertSpaceBeforeFunctionParenthesis?: boolean;\n        placeOpenBraceOnNewLineForFunctions?: boolean;\n        placeOpenBraceOnNewLineForControlBlocks?: boolean;\n        insertSpaceBeforeTypeAnnotation?: boolean;\n        semicolons?: SemicolonPreference;\n    }\n    interface UserPreferences {\n        readonly disableSuggestions?: boolean;\n        readonly quotePreference?: "auto" | "double" | "single";\n        /**\n         * If enabled, TypeScript will search through all external modules\' exports and add them to the completions list.\n         * This affects lone identifier completions but not completions on the right hand side of `obj.`.\n         */\n        readonly includeCompletionsForModuleExports?: boolean;\n        /**\n         * Enables auto-import-style completions on partially-typed import statements. E.g., allows\n         * `import write|` to be completed to `import { writeFile } from "fs"`.\n         */\n        readonly includeCompletionsForImportStatements?: boolean;\n        /**\n         * Allows completions to be formatted with snippet text, indicated by `CompletionItem["isSnippet"]`.\n         */\n        readonly includeCompletionsWithSnippetText?: boolean;\n        /**\n         * If enabled, the completion list will include completions with invalid identifier names.\n         * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `["x"]`.\n         */\n        readonly includeCompletionsWithInsertText?: boolean;\n        /**\n         * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,\n         * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined\n         * values, with insertion text to replace preceding `.` tokens with `?.`.\n         */\n        readonly includeAutomaticOptionalChainCompletions?: boolean;\n        /**\n         * If enabled, completions for class members (e.g. methods and properties) will include\n         * a whole declaration for the member.\n         * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of\n         * `class A { foo }`.\n         */\n        readonly includeCompletionsWithClassMemberSnippets?: boolean;\n        readonly allowIncompleteCompletions?: boolean;\n        readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";\n        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */\n        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";\n        readonly allowTextChangesInNewFiles?: boolean;\n        readonly lazyConfiguredProjectsFromExternalProject?: boolean;\n        readonly providePrefixAndSuffixTextForRename?: boolean;\n        readonly provideRefactorNotApplicableReason?: boolean;\n        readonly allowRenameOfImportPath?: boolean;\n        readonly includePackageJsonAutoImports?: "auto" | "on" | "off";\n        readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";\n        readonly displayPartsForJSDoc?: boolean;\n        readonly generateReturnInDocTemplate?: boolean;\n    }\n    interface CompilerOptions {\n        allowJs?: boolean;\n        allowSyntheticDefaultImports?: boolean;\n        allowUnreachableCode?: boolean;\n        allowUnusedLabels?: boolean;\n        alwaysStrict?: boolean;\n        baseUrl?: string;\n        charset?: string;\n        checkJs?: boolean;\n        declaration?: boolean;\n        declarationDir?: string;\n        disableSizeLimit?: boolean;\n        downlevelIteration?: boolean;\n        emitBOM?: boolean;\n        emitDecoratorMetadata?: boolean;\n        experimentalDecorators?: boolean;\n        forceConsistentCasingInFileNames?: boolean;\n        importHelpers?: boolean;\n        inlineSourceMap?: boolean;\n        inlineSources?: boolean;\n        isolatedModules?: boolean;\n        jsx?: JsxEmit | ts.JsxEmit;\n        lib?: string[];\n        locale?: string;\n        mapRoot?: string;\n        maxNodeModuleJsDepth?: number;\n        module?: ModuleKind | ts.ModuleKind;\n        moduleResolution?: ModuleResolutionKind | ts.ModuleResolutionKind;\n        newLine?: NewLineKind | ts.NewLineKind;\n        noEmit?: boolean;\n        noEmitHelpers?: boolean;\n        noEmitOnError?: boolean;\n        noErrorTruncation?: boolean;\n        noFallthroughCasesInSwitch?: boolean;\n        noImplicitAny?: boolean;\n        noImplicitReturns?: boolean;\n        noImplicitThis?: boolean;\n        noUnusedLocals?: boolean;\n        noUnusedParameters?: boolean;\n        noImplicitUseStrict?: boolean;\n        noLib?: boolean;\n        noResolve?: boolean;\n        out?: string;\n        outDir?: string;\n        outFile?: string;\n        paths?: MapLike<string[]>;\n        plugins?: PluginImport[];\n        preserveConstEnums?: boolean;\n        preserveSymlinks?: boolean;\n        project?: string;\n        reactNamespace?: string;\n        removeComments?: boolean;\n        references?: ProjectReference[];\n        rootDir?: string;\n        rootDirs?: string[];\n        skipLibCheck?: boolean;\n        skipDefaultLibCheck?: boolean;\n        sourceMap?: boolean;\n        sourceRoot?: string;\n        strict?: boolean;\n        strictNullChecks?: boolean;\n        suppressExcessPropertyErrors?: boolean;\n        suppressImplicitAnyIndexErrors?: boolean;\n        useDefineForClassFields?: boolean;\n        target?: ScriptTarget | ts.ScriptTarget;\n        traceResolution?: boolean;\n        resolveJsonModule?: boolean;\n        types?: string[];\n        /** Paths used to used to compute primary types search locations */\n        typeRoots?: string[];\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    const enum JsxEmit {\n        None = "None",\n        Preserve = "Preserve",\n        ReactNative = "ReactNative",\n        React = "React"\n    }\n    const enum ModuleKind {\n        None = "None",\n        CommonJS = "CommonJS",\n        AMD = "AMD",\n        UMD = "UMD",\n        System = "System",\n        ES6 = "ES6",\n        ES2015 = "ES2015",\n        ESNext = "ESNext"\n    }\n    const enum ModuleResolutionKind {\n        Classic = "Classic",\n        Node = "Node"\n    }\n    const enum NewLineKind {\n        Crlf = "Crlf",\n        Lf = "Lf"\n    }\n    const enum ScriptTarget {\n        ES3 = "ES3",\n        ES5 = "ES5",\n        ES6 = "ES6",\n        ES2015 = "ES2015",\n        ES2016 = "ES2016",\n        ES2017 = "ES2017",\n        ES2018 = "ES2018",\n        ES2019 = "ES2019",\n        ES2020 = "ES2020",\n        ES2021 = "ES2021",\n        ES2022 = "ES2022",\n        ESNext = "ESNext"\n    }\n    const enum ClassificationType {\n        comment = 1,\n        identifier = 2,\n        keyword = 3,\n        numericLiteral = 4,\n        operator = 5,\n        stringLiteral = 6,\n        regularExpressionLiteral = 7,\n        whiteSpace = 8,\n        text = 9,\n        punctuation = 10,\n        className = 11,\n        enumName = 12,\n        interfaceName = 13,\n        moduleName = 14,\n        typeParameterName = 15,\n        typeAliasName = 16,\n        parameterName = 17,\n        docCommentTagName = 18,\n        jsxOpenTagName = 19,\n        jsxCloseTagName = 20,\n        jsxSelfClosingTagName = 21,\n        jsxAttribute = 22,\n        jsxText = 23,\n        jsxAttributeStringLiteralValue = 24,\n        bigintLiteral = 25\n    }\n}\ndeclare namespace ts.server.protocol {\n\n    interface TextInsertion {\n        newText: string;\n        /** The position in newText the caret should point to after the insertion. */\n        caretOffset: number;\n    }\n\n    interface TodoCommentDescriptor {\n        text: string;\n        priority: number;\n    }\n\n    interface TodoComment {\n        descriptor: TodoCommentDescriptor;\n        message: string;\n        position: number;\n    }\n\n    enum OutliningSpanKind {\n        /** Single or multi-line comments */\n        Comment = "comment",\n        /** Sections marked by \'// #region\' and \'// #endregion\' comments */\n        Region = "region",\n        /** Declarations and expressions */\n        Code = "code",\n        /** Contiguous blocks of import declarations */\n        Imports = "imports"\n    }\n\n    enum HighlightSpanKind {\n        none = "none",\n        definition = "definition",\n        reference = "reference",\n        writtenReference = "writtenReference"\n    }\n\n    enum ScriptElementKind {\n        unknown = "",\n        warning = "warning",\n        /** predefined type (void) or keyword (class) */\n        keyword = "keyword",\n        /** top level script node */\n        scriptElement = "script",\n        /** module foo {} */\n        moduleElement = "module",\n        /** class X {} */\n        classElement = "class",\n        /** var x = class X {} */\n        localClassElement = "local class",\n        /** interface Y {} */\n        interfaceElement = "interface",\n        /** type T = ... */\n        typeElement = "type",\n        /** enum E */\n        enumElement = "enum",\n        enumMemberElement = "enum member",\n        /**\n         * Inside module and script only\n         * const v = ..\n         */\n        variableElement = "var",\n        /** Inside function */\n        localVariableElement = "local var",\n        /**\n         * Inside module and script only\n         * function f() { }\n         */\n        functionElement = "function",\n        /** Inside function */\n        localFunctionElement = "local function",\n        /** class X { [public|private]* foo() {} } */\n        memberFunctionElement = "method",\n        /** class X { [public|private]* [get|set] foo:number; } */\n        memberGetAccessorElement = "getter",\n        memberSetAccessorElement = "setter",\n        /**\n         * class X { [public|private]* foo:number; }\n         * interface Y { foo:number; }\n         */\n        memberVariableElement = "property",\n        /**\n         * class X { constructor() { } }\n         * class X { static { } }\n         */\n        constructorImplementationElement = "constructor",\n        /** interface Y { ():number; } */\n        callSignatureElement = "call",\n        /** interface Y { []:number; } */\n        indexSignatureElement = "index",\n        /** interface Y { new():Y; } */\n        constructSignatureElement = "construct",\n        /** function foo(*Y*: string) */\n        parameterElement = "parameter",\n        typeParameterElement = "type parameter",\n        primitiveType = "primitive type",\n        label = "label",\n        alias = "alias",\n        constElement = "const",\n        letElement = "let",\n        directory = "directory",\n        externalModuleName = "external module name",\n        /**\n         * <JsxTagName attribute1 attribute2={0} />\n         * @deprecated\n         */\n        jsxAttribute = "JSX attribute",\n        /** String literal */\n        string = "string",\n        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */\n        link = "link",\n        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */\n        linkName = "link name",\n        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */\n        linkText = "link text"\n    }\n\n    export interface TypeAcquisition {\n        /**\n         * @deprecated typingOptions.enableAutoDiscovery\n         * Use typeAcquisition.enable instead.\n         */\n        enableAutoDiscovery?: boolean;\n        enable?: boolean;\n        include?: string[];\n        exclude?: string[];\n        disableFilenameBasedTypeAcquisition?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n\n    export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;\n\n    export interface FileExtensionInfo {\n        extension: string;\n        isMixedContent: boolean;\n        scriptKind?: ScriptKind;\n    }\n\n    /**\n     * Type of objects whose values are all of the same type.\n     * The `in` and `for-in` operators can *not* be safely used,\n     * since `Object.prototype` may be modified by outside code.\n     */\n    interface MapLike<T> {\n        [index: string]: T;\n    }\n\n    export interface PluginImport {\n        name: string;\n    }\n\n    export interface ProjectReference {\n        /** A normalized path on disk */\n        path: string;\n        /** The path as the user originally wrote it */\n        originalPath?: string;\n        /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */\n        prepend?: boolean;\n        /** True if it is intended that this reference form a circularity */\n        circular?: boolean;\n    }\n}\ndeclare namespace ts {\n    // these types are empty stubs for types from services and should not be used directly\n    export type EndOfLineState = never;\n    export type ScriptKind = never;\n    export type WatchFileKind = never;\n    export type WatchDirectoryKind = never;\n    export type PollingWatchKind = never;\n    export type IndentStyle = never;\n    export type JsxEmit = never;\n    export type ModuleKind = never;\n    export type ModuleResolutionKind = never;\n    export type NewLineKind = never;\n    export type ScriptTarget = never;\n}\nimport protocol = ts.server.protocol;\nexport = protocol;\nexport as namespace protocol;';