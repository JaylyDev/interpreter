export const typescriptServices_d_ts='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\ndeclare namespace ts {\n    const versionMajorMinor = "4.6";\n    /** The version of the TypeScript compiler release */\n    const version: string;\n    /**\n     * Type of objects whose values are all of the same type.\n     * The `in` and `for-in` operators can *not* be safely used,\n     * since `Object.prototype` may be modified by outside code.\n     */\n    interface MapLike<T> {\n        [index: string]: T;\n    }\n    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {\n        " __sortedArrayBrand": any;\n    }\n    interface SortedArray<T> extends Array<T> {\n        " __sortedArrayBrand": any;\n    }\n    /** Common read methods for ES6 Map/Set. */\n    interface ReadonlyCollection<K> {\n        readonly size: number;\n        has(key: K): boolean;\n        keys(): Iterator<K>;\n    }\n    /** Common write methods for ES6 Map/Set. */\n    interface Collection<K> extends ReadonlyCollection<K> {\n        delete(key: K): boolean;\n        clear(): void;\n    }\n    /** ES6 Map interface, only read methods included. */\n    interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {\n        get(key: K): V | undefined;\n        values(): Iterator<V>;\n        entries(): Iterator<[K, V]>;\n        forEach(action: (value: V, key: K) => void): void;\n    }\n    /**\n     * ES6 Map interface, only read methods included.\n     */\n    interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {\n    }\n    /** ES6 Map interface. */\n    interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {\n        set(key: K, value: V): this;\n    }\n    /**\n     * ES6 Map interface.\n     */\n    interface Map<T> extends ESMap<string, T> {\n    }\n    /** ES6 Set interface, only read methods included. */\n    interface ReadonlySet<T> extends ReadonlyCollection<T> {\n        has(value: T): boolean;\n        values(): Iterator<T>;\n        entries(): Iterator<[T, T]>;\n        forEach(action: (value: T, key: T) => void): void;\n    }\n    /** ES6 Set interface. */\n    interface Set<T> extends ReadonlySet<T>, Collection<T> {\n        add(value: T): this;\n        delete(value: T): boolean;\n    }\n    /** ES6 Iterator type. */\n    interface Iterator<T> {\n        next(): {\n            value: T;\n            done?: false;\n        } | {\n            value: void;\n            done: true;\n        };\n    }\n    /** Array that is only intended to be pushed to, never read. */\n    interface Push<T> {\n        push(...values: T[]): void;\n    }\n}\ndeclare namespace ts {\n    export type Path = string & {\n        __pathBrand: any;\n    };\n    export interface TextRange {\n        pos: number;\n        end: number;\n    }\n    export interface ReadonlyTextRange {\n        readonly pos: number;\n        readonly end: number;\n    }\n    export enum SyntaxKind {\n        Unknown = 0,\n        EndOfFileToken = 1,\n        SingleLineCommentTrivia = 2,\n        MultiLineCommentTrivia = 3,\n        NewLineTrivia = 4,\n        WhitespaceTrivia = 5,\n        ShebangTrivia = 6,\n        ConflictMarkerTrivia = 7,\n        NumericLiteral = 8,\n        BigIntLiteral = 9,\n        StringLiteral = 10,\n        JsxText = 11,\n        JsxTextAllWhiteSpaces = 12,\n        RegularExpressionLiteral = 13,\n        NoSubstitutionTemplateLiteral = 14,\n        TemplateHead = 15,\n        TemplateMiddle = 16,\n        TemplateTail = 17,\n        OpenBraceToken = 18,\n        CloseBraceToken = 19,\n        OpenParenToken = 20,\n        CloseParenToken = 21,\n        OpenBracketToken = 22,\n        CloseBracketToken = 23,\n        DotToken = 24,\n        DotDotDotToken = 25,\n        SemicolonToken = 26,\n        CommaToken = 27,\n        QuestionDotToken = 28,\n        LessThanToken = 29,\n        LessThanSlashToken = 30,\n        GreaterThanToken = 31,\n        LessThanEqualsToken = 32,\n        GreaterThanEqualsToken = 33,\n        EqualsEqualsToken = 34,\n        ExclamationEqualsToken = 35,\n        EqualsEqualsEqualsToken = 36,\n        ExclamationEqualsEqualsToken = 37,\n        EqualsGreaterThanToken = 38,\n        PlusToken = 39,\n        MinusToken = 40,\n        AsteriskToken = 41,\n        AsteriskAsteriskToken = 42,\n        SlashToken = 43,\n        PercentToken = 44,\n        PlusPlusToken = 45,\n        MinusMinusToken = 46,\n        LessThanLessThanToken = 47,\n        GreaterThanGreaterThanToken = 48,\n        GreaterThanGreaterThanGreaterThanToken = 49,\n        AmpersandToken = 50,\n        BarToken = 51,\n        CaretToken = 52,\n        ExclamationToken = 53,\n        TildeToken = 54,\n        AmpersandAmpersandToken = 55,\n        BarBarToken = 56,\n        QuestionToken = 57,\n        ColonToken = 58,\n        AtToken = 59,\n        QuestionQuestionToken = 60,\n        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */\n        BacktickToken = 61,\n        /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */\n        HashToken = 62,\n        EqualsToken = 63,\n        PlusEqualsToken = 64,\n        MinusEqualsToken = 65,\n        AsteriskEqualsToken = 66,\n        AsteriskAsteriskEqualsToken = 67,\n        SlashEqualsToken = 68,\n        PercentEqualsToken = 69,\n        LessThanLessThanEqualsToken = 70,\n        GreaterThanGreaterThanEqualsToken = 71,\n        GreaterThanGreaterThanGreaterThanEqualsToken = 72,\n        AmpersandEqualsToken = 73,\n        BarEqualsToken = 74,\n        BarBarEqualsToken = 75,\n        AmpersandAmpersandEqualsToken = 76,\n        QuestionQuestionEqualsToken = 77,\n        CaretEqualsToken = 78,\n        Identifier = 79,\n        PrivateIdentifier = 80,\n        BreakKeyword = 81,\n        CaseKeyword = 82,\n        CatchKeyword = 83,\n        ClassKeyword = 84,\n        ConstKeyword = 85,\n        ContinueKeyword = 86,\n        DebuggerKeyword = 87,\n        DefaultKeyword = 88,\n        DeleteKeyword = 89,\n        DoKeyword = 90,\n        ElseKeyword = 91,\n        EnumKeyword = 92,\n        ExportKeyword = 93,\n        ExtendsKeyword = 94,\n        FalseKeyword = 95,\n        FinallyKeyword = 96,\n        ForKeyword = 97,\n        FunctionKeyword = 98,\n        IfKeyword = 99,\n        ImportKeyword = 100,\n        InKeyword = 101,\n        InstanceOfKeyword = 102,\n        NewKeyword = 103,\n        NullKeyword = 104,\n        ReturnKeyword = 105,\n        SuperKeyword = 106,\n        SwitchKeyword = 107,\n        ThisKeyword = 108,\n        ThrowKeyword = 109,\n        TrueKeyword = 110,\n        TryKeyword = 111,\n        TypeOfKeyword = 112,\n        VarKeyword = 113,\n        VoidKeyword = 114,\n        WhileKeyword = 115,\n        WithKeyword = 116,\n        ImplementsKeyword = 117,\n        InterfaceKeyword = 118,\n        LetKeyword = 119,\n        PackageKeyword = 120,\n        PrivateKeyword = 121,\n        ProtectedKeyword = 122,\n        PublicKeyword = 123,\n        StaticKeyword = 124,\n        YieldKeyword = 125,\n        AbstractKeyword = 126,\n        AsKeyword = 127,\n        AssertsKeyword = 128,\n        AssertKeyword = 129,\n        AnyKeyword = 130,\n        AsyncKeyword = 131,\n        AwaitKeyword = 132,\n        BooleanKeyword = 133,\n        ConstructorKeyword = 134,\n        DeclareKeyword = 135,\n        GetKeyword = 136,\n        InferKeyword = 137,\n        IntrinsicKeyword = 138,\n        IsKeyword = 139,\n        KeyOfKeyword = 140,\n        ModuleKeyword = 141,\n        NamespaceKeyword = 142,\n        NeverKeyword = 143,\n        ReadonlyKeyword = 144,\n        RequireKeyword = 145,\n        NumberKeyword = 146,\n        ObjectKeyword = 147,\n        SetKeyword = 148,\n        StringKeyword = 149,\n        SymbolKeyword = 150,\n        TypeKeyword = 151,\n        UndefinedKeyword = 152,\n        UniqueKeyword = 153,\n        UnknownKeyword = 154,\n        FromKeyword = 155,\n        GlobalKeyword = 156,\n        BigIntKeyword = 157,\n        OverrideKeyword = 158,\n        OfKeyword = 159,\n        QualifiedName = 160,\n        ComputedPropertyName = 161,\n        TypeParameter = 162,\n        Parameter = 163,\n        Decorator = 164,\n        PropertySignature = 165,\n        PropertyDeclaration = 166,\n        MethodSignature = 167,\n        MethodDeclaration = 168,\n        ClassStaticBlockDeclaration = 169,\n        Constructor = 170,\n        GetAccessor = 171,\n        SetAccessor = 172,\n        CallSignature = 173,\n        ConstructSignature = 174,\n        IndexSignature = 175,\n        TypePredicate = 176,\n        TypeReference = 177,\n        FunctionType = 178,\n        ConstructorType = 179,\n        TypeQuery = 180,\n        TypeLiteral = 181,\n        ArrayType = 182,\n        TupleType = 183,\n        OptionalType = 184,\n        RestType = 185,\n        UnionType = 186,\n        IntersectionType = 187,\n        ConditionalType = 188,\n        InferType = 189,\n        ParenthesizedType = 190,\n        ThisType = 191,\n        TypeOperator = 192,\n        IndexedAccessType = 193,\n        MappedType = 194,\n        LiteralType = 195,\n        NamedTupleMember = 196,\n        TemplateLiteralType = 197,\n        TemplateLiteralTypeSpan = 198,\n        ImportType = 199,\n        ObjectBindingPattern = 200,\n        ArrayBindingPattern = 201,\n        BindingElement = 202,\n        ArrayLiteralExpression = 203,\n        ObjectLiteralExpression = 204,\n        PropertyAccessExpression = 205,\n        ElementAccessExpression = 206,\n        CallExpression = 207,\n        NewExpression = 208,\n        TaggedTemplateExpression = 209,\n        TypeAssertionExpression = 210,\n        ParenthesizedExpression = 211,\n        FunctionExpression = 212,\n        ArrowFunction = 213,\n        DeleteExpression = 214,\n        TypeOfExpression = 215,\n        VoidExpression = 216,\n        AwaitExpression = 217,\n        PrefixUnaryExpression = 218,\n        PostfixUnaryExpression = 219,\n        BinaryExpression = 220,\n        ConditionalExpression = 221,\n        TemplateExpression = 222,\n        YieldExpression = 223,\n        SpreadElement = 224,\n        ClassExpression = 225,\n        OmittedExpression = 226,\n        ExpressionWithTypeArguments = 227,\n        AsExpression = 228,\n        NonNullExpression = 229,\n        MetaProperty = 230,\n        SyntheticExpression = 231,\n        TemplateSpan = 232,\n        SemicolonClassElement = 233,\n        Block = 234,\n        EmptyStatement = 235,\n        VariableStatement = 236,\n        ExpressionStatement = 237,\n        IfStatement = 238,\n        DoStatement = 239,\n        WhileStatement = 240,\n        ForStatement = 241,\n        ForInStatement = 242,\n        ForOfStatement = 243,\n        ContinueStatement = 244,\n        BreakStatement = 245,\n        ReturnStatement = 246,\n        WithStatement = 247,\n        SwitchStatement = 248,\n        LabeledStatement = 249,\n        ThrowStatement = 250,\n        TryStatement = 251,\n        DebuggerStatement = 252,\n        VariableDeclaration = 253,\n        VariableDeclarationList = 254,\n        FunctionDeclaration = 255,\n        ClassDeclaration = 256,\n        InterfaceDeclaration = 257,\n        TypeAliasDeclaration = 258,\n        EnumDeclaration = 259,\n        ModuleDeclaration = 260,\n        ModuleBlock = 261,\n        CaseBlock = 262,\n        NamespaceExportDeclaration = 263,\n        ImportEqualsDeclaration = 264,\n        ImportDeclaration = 265,\n        ImportClause = 266,\n        NamespaceImport = 267,\n        NamedImports = 268,\n        ImportSpecifier = 269,\n        ExportAssignment = 270,\n        ExportDeclaration = 271,\n        NamedExports = 272,\n        NamespaceExport = 273,\n        ExportSpecifier = 274,\n        MissingDeclaration = 275,\n        ExternalModuleReference = 276,\n        JsxElement = 277,\n        JsxSelfClosingElement = 278,\n        JsxOpeningElement = 279,\n        JsxClosingElement = 280,\n        JsxFragment = 281,\n        JsxOpeningFragment = 282,\n        JsxClosingFragment = 283,\n        JsxAttribute = 284,\n        JsxAttributes = 285,\n        JsxSpreadAttribute = 286,\n        JsxExpression = 287,\n        CaseClause = 288,\n        DefaultClause = 289,\n        HeritageClause = 290,\n        CatchClause = 291,\n        AssertClause = 292,\n        AssertEntry = 293,\n        PropertyAssignment = 294,\n        ShorthandPropertyAssignment = 295,\n        SpreadAssignment = 296,\n        EnumMember = 297,\n        UnparsedPrologue = 298,\n        UnparsedPrepend = 299,\n        UnparsedText = 300,\n        UnparsedInternalText = 301,\n        UnparsedSyntheticReference = 302,\n        SourceFile = 303,\n        Bundle = 304,\n        UnparsedSource = 305,\n        InputFiles = 306,\n        JSDocTypeExpression = 307,\n        JSDocNameReference = 308,\n        JSDocMemberName = 309,\n        JSDocAllType = 310,\n        JSDocUnknownType = 311,\n        JSDocNullableType = 312,\n        JSDocNonNullableType = 313,\n        JSDocOptionalType = 314,\n        JSDocFunctionType = 315,\n        JSDocVariadicType = 316,\n        JSDocNamepathType = 317,\n        JSDocComment = 318,\n        JSDocText = 319,\n        JSDocTypeLiteral = 320,\n        JSDocSignature = 321,\n        JSDocLink = 322,\n        JSDocLinkCode = 323,\n        JSDocLinkPlain = 324,\n        JSDocTag = 325,\n        JSDocAugmentsTag = 326,\n        JSDocImplementsTag = 327,\n        JSDocAuthorTag = 328,\n        JSDocDeprecatedTag = 329,\n        JSDocClassTag = 330,\n        JSDocPublicTag = 331,\n        JSDocPrivateTag = 332,\n        JSDocProtectedTag = 333,\n        JSDocReadonlyTag = 334,\n        JSDocOverrideTag = 335,\n        JSDocCallbackTag = 336,\n        JSDocEnumTag = 337,\n        JSDocParameterTag = 338,\n        JSDocReturnTag = 339,\n        JSDocThisTag = 340,\n        JSDocTypeTag = 341,\n        JSDocTemplateTag = 342,\n        JSDocTypedefTag = 343,\n        JSDocSeeTag = 344,\n        JSDocPropertyTag = 345,\n        SyntaxList = 346,\n        NotEmittedStatement = 347,\n        PartiallyEmittedExpression = 348,\n        CommaListExpression = 349,\n        MergeDeclarationMarker = 350,\n        EndOfDeclarationMarker = 351,\n        SyntheticReferenceExpression = 352,\n        Count = 353,\n        FirstAssignment = 63,\n        LastAssignment = 78,\n        FirstCompoundAssignment = 64,\n        LastCompoundAssignment = 78,\n        FirstReservedWord = 81,\n        LastReservedWord = 116,\n        FirstKeyword = 81,\n        LastKeyword = 159,\n        FirstFutureReservedWord = 117,\n        LastFutureReservedWord = 125,\n        FirstTypeNode = 176,\n        LastTypeNode = 199,\n        FirstPunctuation = 18,\n        LastPunctuation = 78,\n        FirstToken = 0,\n        LastToken = 159,\n        FirstTriviaToken = 2,\n        LastTriviaToken = 7,\n        FirstLiteralToken = 8,\n        LastLiteralToken = 14,\n        FirstTemplateToken = 14,\n        LastTemplateToken = 17,\n        FirstBinaryOperator = 29,\n        LastBinaryOperator = 78,\n        FirstStatement = 236,\n        LastStatement = 252,\n        FirstNode = 160,\n        FirstJSDocNode = 307,\n        LastJSDocNode = 345,\n        FirstJSDocTagNode = 325,\n        LastJSDocTagNode = 345,\n    }\n    export type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;\n    export type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;\n    export type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;\n    export type PunctuationSyntaxKind = SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.DotToken | SyntaxKind.DotDotDotToken | SyntaxKind.SemicolonToken | SyntaxKind.CommaToken | SyntaxKind.QuestionDotToken | SyntaxKind.LessThanToken | SyntaxKind.LessThanSlashToken | SyntaxKind.GreaterThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.EqualsGreaterThanToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.AsteriskToken | SyntaxKind.AsteriskAsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken | SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken | SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken | SyntaxKind.ExclamationToken | SyntaxKind.TildeToken | SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken | SyntaxKind.QuestionQuestionToken | SyntaxKind.QuestionToken | SyntaxKind.ColonToken | SyntaxKind.AtToken | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.EqualsToken | SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken;\n    export type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.AssertKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InferKeyword | SyntaxKind.InKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.OfKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.RequireKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword;\n    export type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;\n    export type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;\n    export type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;\n    export type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;\n    export type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;\n    export enum NodeFlags {\n        None = 0,\n        Let = 1,\n        Const = 2,\n        NestedNamespace = 4,\n        Synthesized = 8,\n        Namespace = 16,\n        OptionalChain = 32,\n        ExportContext = 64,\n        ContainsThis = 128,\n        HasImplicitReturn = 256,\n        HasExplicitReturn = 512,\n        GlobalAugmentation = 1024,\n        HasAsyncFunctions = 2048,\n        DisallowInContext = 4096,\n        YieldContext = 8192,\n        DecoratorContext = 16384,\n        AwaitContext = 32768,\n        ThisNodeHasError = 65536,\n        JavaScriptFile = 131072,\n        ThisNodeOrAnySubNodesHasError = 262144,\n        HasAggregatedChildData = 524288,\n        JSDoc = 4194304,\n        JsonFile = 33554432,\n        BlockScoped = 3,\n        ReachabilityCheckFlags = 768,\n        ReachabilityAndEmitFlags = 2816,\n        ContextFlags = 25358336,\n        TypeExcludesFlags = 40960,\n    }\n    export enum ModifierFlags {\n        None = 0,\n        Export = 1,\n        Ambient = 2,\n        Public = 4,\n        Private = 8,\n        Protected = 16,\n        Static = 32,\n        Readonly = 64,\n        Abstract = 128,\n        Async = 256,\n        Default = 512,\n        Const = 2048,\n        HasComputedJSDocModifiers = 4096,\n        Deprecated = 8192,\n        Override = 16384,\n        HasComputedFlags = 536870912,\n        AccessibilityModifier = 28,\n        ParameterPropertyModifier = 16476,\n        NonPublicAccessibilityModifier = 24,\n        TypeScriptModifier = 18654,\n        ExportDefault = 513,\n        All = 27647\n    }\n    export enum JsxFlags {\n        None = 0,\n        /** An element from a named property of the JSX.IntrinsicElements interface */\n        IntrinsicNamedElement = 1,\n        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */\n        IntrinsicIndexedElement = 2,\n        IntrinsicElement = 3\n    }\n    export interface Node extends ReadonlyTextRange {\n        readonly kind: SyntaxKind;\n        readonly flags: NodeFlags;\n        readonly decorators?: NodeArray<Decorator>;\n        readonly modifiers?: ModifiersArray;\n        readonly parent: Node;\n    }\n    export interface JSDocContainer {\n    }\n    export type HasJSDoc = ParameterDeclaration | CallSignatureDeclaration | ClassStaticBlockDeclaration | ConstructSignatureDeclaration | MethodSignature | PropertySignature | ArrowFunction | ParenthesizedExpression | SpreadAssignment | ShorthandPropertyAssignment | PropertyAssignment | FunctionExpression | EmptyStatement | DebuggerStatement | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | BreakStatement | ContinueStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | FunctionDeclaration | ConstructorDeclaration | MethodDeclaration | VariableDeclaration | PropertyDeclaration | AccessorDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumMember | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportAssignment | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | ExportDeclaration | NamedTupleMember | ExportSpecifier | EndOfFileToken;\n    export type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;\n    export type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;\n    export type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;\n    export type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertySignature | PropertyDeclaration | PropertyAssignment | EnumMember;\n    export interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {\n        readonly hasTrailingComma: boolean;\n    }\n    export interface Token<TKind extends SyntaxKind> extends Node {\n        readonly kind: TKind;\n    }\n    export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;\n    export interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {\n    }\n    export type DotToken = PunctuationToken<SyntaxKind.DotToken>;\n    export type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;\n    export type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;\n    export type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;\n    export type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;\n    export type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;\n    export type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;\n    export type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;\n    export type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;\n    export type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;\n    export type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;\n    export interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {\n    }\n    export type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;\n    export type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;\n    export type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;\n    /** @deprecated Use `AwaitKeyword` instead. */\n    export type AwaitKeywordToken = AwaitKeyword;\n    /** @deprecated Use `AssertsKeyword` instead. */\n    export type AssertsToken = AssertsKeyword;\n    export interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {\n    }\n    export type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;\n    export type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;\n    export type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;\n    export type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;\n    export type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;\n    export type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;\n    export type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;\n    export type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;\n    export type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;\n    export type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;\n    export type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;\n    export type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;\n    /** @deprecated Use `ReadonlyKeyword` instead. */\n    export type ReadonlyToken = ReadonlyKeyword;\n    export type Modifier = AbstractKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;\n    export type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;\n    export type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;\n    export type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword;\n    export type ModifiersArray = NodeArray<Modifier>;\n    export enum GeneratedIdentifierFlags {\n        None = 0,\n        ReservedInNestedScopes = 8,\n        Optimistic = 16,\n        FileLevel = 32,\n        AllowNameSubstitution = 64\n    }\n    export interface Identifier extends PrimaryExpression, Declaration {\n        readonly kind: SyntaxKind.Identifier;\n        /**\n         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)\n         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.\n         */\n        readonly escapedText: __String;\n        readonly originalKeywordKind?: SyntaxKind;\n        isInJSDocNamespace?: boolean;\n    }\n    export interface TransientIdentifier extends Identifier {\n        resolvedSymbol: Symbol;\n    }\n    export interface QualifiedName extends Node {\n        readonly kind: SyntaxKind.QualifiedName;\n        readonly left: EntityName;\n        readonly right: Identifier;\n    }\n    export type EntityName = Identifier | QualifiedName;\n    export type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier;\n    export type MemberName = Identifier | PrivateIdentifier;\n    export type DeclarationName = Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ComputedPropertyName | ElementAccessExpression | BindingPattern | EntityNameExpression;\n    export interface Declaration extends Node {\n        _declarationBrand: any;\n    }\n    export interface NamedDeclaration extends Declaration {\n        readonly name?: DeclarationName;\n    }\n    export interface DeclarationStatement extends NamedDeclaration, Statement {\n        readonly name?: Identifier | StringLiteral | NumericLiteral;\n    }\n    export interface ComputedPropertyName extends Node {\n        readonly kind: SyntaxKind.ComputedPropertyName;\n        readonly parent: Declaration;\n        readonly expression: Expression;\n    }\n    export interface PrivateIdentifier extends PrimaryExpression {\n        readonly kind: SyntaxKind.PrivateIdentifier;\n        readonly escapedText: __String;\n    }\n    export interface Decorator extends Node {\n        readonly kind: SyntaxKind.Decorator;\n        readonly parent: NamedDeclaration;\n        readonly expression: LeftHandSideExpression;\n    }\n    export interface TypeParameterDeclaration extends NamedDeclaration {\n        readonly kind: SyntaxKind.TypeParameter;\n        readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;\n        readonly name: Identifier;\n        /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */\n        readonly constraint?: TypeNode;\n        readonly default?: TypeNode;\n        expression?: Expression;\n    }\n    export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {\n        readonly kind: SignatureDeclaration["kind"];\n        readonly name?: PropertyName;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly parameters: NodeArray<ParameterDeclaration>;\n        readonly type?: TypeNode;\n    }\n    export type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;\n    export interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\n        readonly kind: SyntaxKind.CallSignature;\n    }\n    export interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\n        readonly kind: SyntaxKind.ConstructSignature;\n    }\n    export type BindingName = Identifier | BindingPattern;\n    export interface VariableDeclaration extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.VariableDeclaration;\n        readonly parent: VariableDeclarationList | CatchClause;\n        readonly name: BindingName;\n        readonly exclamationToken?: ExclamationToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    export interface VariableDeclarationList extends Node {\n        readonly kind: SyntaxKind.VariableDeclarationList;\n        readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;\n        readonly declarations: NodeArray<VariableDeclaration>;\n    }\n    export interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.Parameter;\n        readonly parent: SignatureDeclaration;\n        readonly dotDotDotToken?: DotDotDotToken;\n        readonly name: BindingName;\n        readonly questionToken?: QuestionToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    export interface BindingElement extends NamedDeclaration {\n        readonly kind: SyntaxKind.BindingElement;\n        readonly parent: BindingPattern;\n        readonly propertyName?: PropertyName;\n        readonly dotDotDotToken?: DotDotDotToken;\n        readonly name: BindingName;\n        readonly initializer?: Expression;\n    }\n    export interface PropertySignature extends TypeElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertySignature;\n        readonly name: PropertyName;\n        readonly questionToken?: QuestionToken;\n        readonly type?: TypeNode;\n        initializer?: Expression;\n    }\n    export interface PropertyDeclaration extends ClassElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertyDeclaration;\n        readonly parent: ClassLikeDeclaration;\n        readonly name: PropertyName;\n        readonly questionToken?: QuestionToken;\n        readonly exclamationToken?: ExclamationToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    export interface ObjectLiteralElement extends NamedDeclaration {\n        _objectLiteralBrand: any;\n        readonly name?: PropertyName;\n    }\n    /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */\n    export type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;\n    export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertyAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly name: PropertyName;\n        readonly questionToken?: QuestionToken;\n        readonly exclamationToken?: ExclamationToken;\n        readonly initializer: Expression;\n    }\n    export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.ShorthandPropertyAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly name: Identifier;\n        readonly questionToken?: QuestionToken;\n        readonly exclamationToken?: ExclamationToken;\n        readonly equalsToken?: EqualsToken;\n        readonly objectAssignmentInitializer?: Expression;\n    }\n    export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.SpreadAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly expression: Expression;\n    }\n    export type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;\n    export interface PropertyLikeDeclaration extends NamedDeclaration {\n        readonly name: PropertyName;\n    }\n    export interface ObjectBindingPattern extends Node {\n        readonly kind: SyntaxKind.ObjectBindingPattern;\n        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        readonly elements: NodeArray<BindingElement>;\n    }\n    export interface ArrayBindingPattern extends Node {\n        readonly kind: SyntaxKind.ArrayBindingPattern;\n        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        readonly elements: NodeArray<ArrayBindingElement>;\n    }\n    export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\n    export type ArrayBindingElement = BindingElement | OmittedExpression;\n    /**\n     * Several node kinds share function-like features such as a signature,\n     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.\n     * Examples:\n     * - FunctionDeclaration\n     * - MethodDeclaration\n     * - AccessorDeclaration\n     */\n    export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {\n        _functionLikeDeclarationBrand: any;\n        readonly asteriskToken?: AsteriskToken;\n        readonly questionToken?: QuestionToken;\n        readonly exclamationToken?: ExclamationToken;\n        readonly body?: Block | Expression;\n    }\n    export type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;\n    /** @deprecated Use SignatureDeclaration */\n    export type FunctionLike = SignatureDeclaration;\n    export interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement {\n        readonly kind: SyntaxKind.FunctionDeclaration;\n        readonly name?: Identifier;\n        readonly body?: FunctionBody;\n    }\n    export interface MethodSignature extends SignatureDeclarationBase, TypeElement {\n        readonly kind: SyntaxKind.MethodSignature;\n        readonly parent: ObjectTypeDeclaration;\n        readonly name: PropertyName;\n    }\n    export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.MethodDeclaration;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody;\n    }\n    export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {\n        readonly kind: SyntaxKind.Constructor;\n        readonly parent: ClassLikeDeclaration;\n        readonly body?: FunctionBody;\n    }\n    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */\n    export interface SemicolonClassElement extends ClassElement {\n        readonly kind: SyntaxKind.SemicolonClassElement;\n        readonly parent: ClassLikeDeclaration;\n    }\n    export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.GetAccessor;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody;\n    }\n    export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.SetAccessor;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody;\n    }\n    export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\n    export interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement {\n        readonly kind: SyntaxKind.IndexSignature;\n        readonly parent: ObjectTypeDeclaration;\n        readonly type: TypeNode;\n    }\n    export interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer {\n        readonly kind: SyntaxKind.ClassStaticBlockDeclaration;\n        readonly parent: ClassDeclaration | ClassExpression;\n        readonly body: Block;\n    }\n    export interface TypeNode extends Node {\n        _typeNodeBrand: any;\n    }\n    export interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {\n        readonly kind: TKind;\n    }\n    export interface ImportTypeNode extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.ImportType;\n        readonly isTypeOf: boolean;\n        readonly argument: TypeNode;\n        readonly qualifier?: EntityName;\n    }\n    export interface ThisTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ThisType;\n    }\n    export type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;\n    export interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {\n        readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;\n        readonly type: TypeNode;\n    }\n    export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {\n        readonly kind: SyntaxKind.FunctionType;\n    }\n    export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {\n        readonly kind: SyntaxKind.ConstructorType;\n    }\n    export interface NodeWithTypeArguments extends TypeNode {\n        readonly typeArguments?: NodeArray<TypeNode>;\n    }\n    export type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;\n    export interface TypeReferenceNode extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.TypeReference;\n        readonly typeName: EntityName;\n    }\n    export interface TypePredicateNode extends TypeNode {\n        readonly kind: SyntaxKind.TypePredicate;\n        readonly parent: SignatureDeclaration | JSDocTypeExpression;\n        readonly assertsModifier?: AssertsKeyword;\n        readonly parameterName: Identifier | ThisTypeNode;\n        readonly type?: TypeNode;\n    }\n    export interface TypeQueryNode extends TypeNode {\n        readonly kind: SyntaxKind.TypeQuery;\n        readonly exprName: EntityName;\n    }\n    export interface TypeLiteralNode extends TypeNode, Declaration {\n        readonly kind: SyntaxKind.TypeLiteral;\n        readonly members: NodeArray<TypeElement>;\n    }\n    export interface ArrayTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ArrayType;\n        readonly elementType: TypeNode;\n    }\n    export interface TupleTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.TupleType;\n        readonly elements: NodeArray<TypeNode | NamedTupleMember>;\n    }\n    export interface NamedTupleMember extends TypeNode, JSDocContainer, Declaration {\n        readonly kind: SyntaxKind.NamedTupleMember;\n        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\n        readonly name: Identifier;\n        readonly questionToken?: Token<SyntaxKind.QuestionToken>;\n        readonly type: TypeNode;\n    }\n    export interface OptionalTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.OptionalType;\n        readonly type: TypeNode;\n    }\n    export interface RestTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.RestType;\n        readonly type: TypeNode;\n    }\n    export type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;\n    export interface UnionTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.UnionType;\n        readonly types: NodeArray<TypeNode>;\n    }\n    export interface IntersectionTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.IntersectionType;\n        readonly types: NodeArray<TypeNode>;\n    }\n    export interface ConditionalTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ConditionalType;\n        readonly checkType: TypeNode;\n        readonly extendsType: TypeNode;\n        readonly trueType: TypeNode;\n        readonly falseType: TypeNode;\n    }\n    export interface InferTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.InferType;\n        readonly typeParameter: TypeParameterDeclaration;\n    }\n    export interface ParenthesizedTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ParenthesizedType;\n        readonly type: TypeNode;\n    }\n    export interface TypeOperatorNode extends TypeNode {\n        readonly kind: SyntaxKind.TypeOperator;\n        readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;\n        readonly type: TypeNode;\n    }\n    export interface IndexedAccessTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.IndexedAccessType;\n        readonly objectType: TypeNode;\n        readonly indexType: TypeNode;\n    }\n    export interface MappedTypeNode extends TypeNode, Declaration {\n        readonly kind: SyntaxKind.MappedType;\n        readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;\n        readonly typeParameter: TypeParameterDeclaration;\n        readonly nameType?: TypeNode;\n        readonly questionToken?: QuestionToken | PlusToken | MinusToken;\n        readonly type?: TypeNode;\n        /** Used only to produce grammar errors */\n        readonly members?: NodeArray<TypeElement>;\n    }\n    export interface LiteralTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.LiteralType;\n        readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\n    }\n    export interface StringLiteral extends LiteralExpression, Declaration {\n        readonly kind: SyntaxKind.StringLiteral;\n    }\n    export type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;\n    export type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral;\n    export interface TemplateLiteralTypeNode extends TypeNode {\n        kind: SyntaxKind.TemplateLiteralType;\n        readonly head: TemplateHead;\n        readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;\n    }\n    export interface TemplateLiteralTypeSpan extends TypeNode {\n        readonly kind: SyntaxKind.TemplateLiteralTypeSpan;\n        readonly parent: TemplateLiteralTypeNode;\n        readonly type: TypeNode;\n        readonly literal: TemplateMiddle | TemplateTail;\n    }\n    export interface Expression extends Node {\n        _expressionBrand: any;\n    }\n    export interface OmittedExpression extends Expression {\n        readonly kind: SyntaxKind.OmittedExpression;\n    }\n    export interface PartiallyEmittedExpression extends LeftHandSideExpression {\n        readonly kind: SyntaxKind.PartiallyEmittedExpression;\n        readonly expression: Expression;\n    }\n    export interface UnaryExpression extends Expression {\n        _unaryExpressionBrand: any;\n    }\n    /** Deprecated, please use UpdateExpression */\n    export type IncrementExpression = UpdateExpression;\n    export interface UpdateExpression extends UnaryExpression {\n        _updateExpressionBrand: any;\n    }\n    export type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;\n    export interface PrefixUnaryExpression extends UpdateExpression {\n        readonly kind: SyntaxKind.PrefixUnaryExpression;\n        readonly operator: PrefixUnaryOperator;\n        readonly operand: UnaryExpression;\n    }\n    export type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;\n    export interface PostfixUnaryExpression extends UpdateExpression {\n        readonly kind: SyntaxKind.PostfixUnaryExpression;\n        readonly operand: LeftHandSideExpression;\n        readonly operator: PostfixUnaryOperator;\n    }\n    export interface LeftHandSideExpression extends UpdateExpression {\n        _leftHandSideExpressionBrand: any;\n    }\n    export interface MemberExpression extends LeftHandSideExpression {\n        _memberExpressionBrand: any;\n    }\n    export interface PrimaryExpression extends MemberExpression {\n        _primaryExpressionBrand: any;\n    }\n    export interface NullLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.NullKeyword;\n    }\n    export interface TrueLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.TrueKeyword;\n    }\n    export interface FalseLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.FalseKeyword;\n    }\n    export type BooleanLiteral = TrueLiteral | FalseLiteral;\n    export interface ThisExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.ThisKeyword;\n    }\n    export interface SuperExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.SuperKeyword;\n    }\n    export interface ImportExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.ImportKeyword;\n    }\n    export interface DeleteExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.DeleteExpression;\n        readonly expression: UnaryExpression;\n    }\n    export interface TypeOfExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.TypeOfExpression;\n        readonly expression: UnaryExpression;\n    }\n    export interface VoidExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.VoidExpression;\n        readonly expression: UnaryExpression;\n    }\n    export interface AwaitExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.AwaitExpression;\n        readonly expression: UnaryExpression;\n    }\n    export interface YieldExpression extends Expression {\n        readonly kind: SyntaxKind.YieldExpression;\n        readonly asteriskToken?: AsteriskToken;\n        readonly expression?: Expression;\n    }\n    export interface SyntheticExpression extends Expression {\n        readonly kind: SyntaxKind.SyntheticExpression;\n        readonly isSpread: boolean;\n        readonly type: Type;\n        readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;\n    }\n    export type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;\n    export type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;\n    export type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;\n    export type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;\n    export type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;\n    export type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\n    export type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;\n    export type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;\n    export type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;\n    export type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;\n    export type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;\n    export type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;\n    export type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;\n    export type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;\n    export type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;\n    export type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;\n    export type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;\n    export type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;\n    export type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;\n    export type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;\n    export type BinaryOperatorToken = Token<BinaryOperator>;\n    export interface BinaryExpression extends Expression, Declaration {\n        readonly kind: SyntaxKind.BinaryExpression;\n        readonly left: Expression;\n        readonly operatorToken: BinaryOperatorToken;\n        readonly right: Expression;\n    }\n    export type AssignmentOperatorToken = Token<AssignmentOperator>;\n    export interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {\n        readonly left: LeftHandSideExpression;\n        readonly operatorToken: TOperator;\n    }\n    export interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        readonly left: ObjectLiteralExpression;\n    }\n    export interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        readonly left: ArrayLiteralExpression;\n    }\n    export type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;\n    export type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;\n    export type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;\n    export type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;\n    export type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;\n    export type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;\n    export type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;\n    export type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;\n    export type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;\n    export type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;\n    export interface ConditionalExpression extends Expression {\n        readonly kind: SyntaxKind.ConditionalExpression;\n        readonly condition: Expression;\n        readonly questionToken: QuestionToken;\n        readonly whenTrue: Expression;\n        readonly colonToken: ColonToken;\n        readonly whenFalse: Expression;\n    }\n    export type FunctionBody = Block;\n    export type ConciseBody = FunctionBody | Expression;\n    export interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer {\n        readonly kind: SyntaxKind.FunctionExpression;\n        readonly name?: Identifier;\n        readonly body: FunctionBody;\n    }\n    export interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer {\n        readonly kind: SyntaxKind.ArrowFunction;\n        readonly equalsGreaterThanToken: EqualsGreaterThanToken;\n        readonly body: ConciseBody;\n        readonly name: never;\n    }\n    export interface LiteralLikeNode extends Node {\n        text: string;\n        isUnterminated?: boolean;\n        hasExtendedUnicodeEscape?: boolean;\n    }\n    export interface TemplateLiteralLikeNode extends LiteralLikeNode {\n        rawText?: string;\n    }\n    export interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {\n        _literalExpressionBrand: any;\n    }\n    export interface RegularExpressionLiteral extends LiteralExpression {\n        readonly kind: SyntaxKind.RegularExpressionLiteral;\n    }\n    export interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {\n        readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;\n    }\n    export enum TokenFlags {\n        None = 0,\n        Scientific = 16,\n        Octal = 32,\n        HexSpecifier = 64,\n        BinarySpecifier = 128,\n        OctalSpecifier = 256,\n    }\n    export interface NumericLiteral extends LiteralExpression, Declaration {\n        readonly kind: SyntaxKind.NumericLiteral;\n    }\n    export interface BigIntLiteral extends LiteralExpression {\n        readonly kind: SyntaxKind.BigIntLiteral;\n    }\n    export type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;\n    export interface TemplateHead extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateHead;\n        readonly parent: TemplateExpression | TemplateLiteralTypeNode;\n    }\n    export interface TemplateMiddle extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateMiddle;\n        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;\n    }\n    export interface TemplateTail extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateTail;\n        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;\n    }\n    export type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;\n    export type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;\n    export interface TemplateExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.TemplateExpression;\n        readonly head: TemplateHead;\n        readonly templateSpans: NodeArray<TemplateSpan>;\n    }\n    export type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\n    export interface TemplateSpan extends Node {\n        readonly kind: SyntaxKind.TemplateSpan;\n        readonly parent: TemplateExpression;\n        readonly expression: Expression;\n        readonly literal: TemplateMiddle | TemplateTail;\n    }\n    export interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {\n        readonly kind: SyntaxKind.ParenthesizedExpression;\n        readonly expression: Expression;\n    }\n    export interface ArrayLiteralExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.ArrayLiteralExpression;\n        readonly elements: NodeArray<Expression>;\n    }\n    export interface SpreadElement extends Expression {\n        readonly kind: SyntaxKind.SpreadElement;\n        readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;\n        readonly expression: Expression;\n    }\n    /**\n     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to\n     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes\' properties can only be\n     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type\n     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)\n     */\n    export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {\n        readonly properties: NodeArray<T>;\n    }\n    export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {\n        readonly kind: SyntaxKind.ObjectLiteralExpression;\n    }\n    export type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;\n    export type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;\n    export type AccessExpression = PropertyAccessExpression | ElementAccessExpression;\n    export interface PropertyAccessExpression extends MemberExpression, NamedDeclaration {\n        readonly kind: SyntaxKind.PropertyAccessExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly name: MemberName;\n    }\n    export interface PropertyAccessChain extends PropertyAccessExpression {\n        _optionalChainBrand: any;\n        readonly name: MemberName;\n    }\n    export interface SuperPropertyAccessExpression extends PropertyAccessExpression {\n        readonly expression: SuperExpression;\n    }\n    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */\n    export interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {\n        _propertyAccessExpressionLikeQualifiedNameBrand?: any;\n        readonly expression: EntityNameExpression;\n        readonly name: Identifier;\n    }\n    export interface ElementAccessExpression extends MemberExpression {\n        readonly kind: SyntaxKind.ElementAccessExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly argumentExpression: Expression;\n    }\n    export interface ElementAccessChain extends ElementAccessExpression {\n        _optionalChainBrand: any;\n    }\n    export interface SuperElementAccessExpression extends ElementAccessExpression {\n        readonly expression: SuperExpression;\n    }\n    export type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;\n    export interface CallExpression extends LeftHandSideExpression, Declaration {\n        readonly kind: SyntaxKind.CallExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly arguments: NodeArray<Expression>;\n    }\n    export interface CallChain extends CallExpression {\n        _optionalChainBrand: any;\n    }\n    export type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    export interface SuperCall extends CallExpression {\n        readonly expression: SuperExpression;\n    }\n    export interface ImportCall extends CallExpression {\n        readonly expression: ImportExpression;\n    }\n    export interface ExpressionWithTypeArguments extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.ExpressionWithTypeArguments;\n        readonly parent: HeritageClause | JSDocAugmentsTag | JSDocImplementsTag;\n        readonly expression: LeftHandSideExpression;\n    }\n    export interface NewExpression extends PrimaryExpression, Declaration {\n        readonly kind: SyntaxKind.NewExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly arguments?: NodeArray<Expression>;\n    }\n    export interface TaggedTemplateExpression extends MemberExpression {\n        readonly kind: SyntaxKind.TaggedTemplateExpression;\n        readonly tag: LeftHandSideExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly template: TemplateLiteral;\n    }\n    export type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;\n    export interface AsExpression extends Expression {\n        readonly kind: SyntaxKind.AsExpression;\n        readonly expression: Expression;\n        readonly type: TypeNode;\n    }\n    export interface TypeAssertion extends UnaryExpression {\n        readonly kind: SyntaxKind.TypeAssertionExpression;\n        readonly type: TypeNode;\n        readonly expression: UnaryExpression;\n    }\n    export type AssertionExpression = TypeAssertion | AsExpression;\n    export interface NonNullExpression extends LeftHandSideExpression {\n        readonly kind: SyntaxKind.NonNullExpression;\n        readonly expression: Expression;\n    }\n    export interface NonNullChain extends NonNullExpression {\n        _optionalChainBrand: any;\n    }\n    export interface MetaProperty extends PrimaryExpression {\n        readonly kind: SyntaxKind.MetaProperty;\n        readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;\n        readonly name: Identifier;\n    }\n    export interface JsxElement extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxElement;\n        readonly openingElement: JsxOpeningElement;\n        readonly children: NodeArray<JsxChild>;\n        readonly closingElement: JsxClosingElement;\n    }\n    export type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\n    export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\n    export type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;\n    export interface JsxTagNamePropertyAccess extends PropertyAccessExpression {\n        readonly expression: JsxTagNameExpression;\n    }\n    export interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {\n        readonly kind: SyntaxKind.JsxAttributes;\n        readonly parent: JsxOpeningLikeElement;\n    }\n    export interface JsxOpeningElement extends Expression {\n        readonly kind: SyntaxKind.JsxOpeningElement;\n        readonly parent: JsxElement;\n        readonly tagName: JsxTagNameExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly attributes: JsxAttributes;\n    }\n    export interface JsxSelfClosingElement extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxSelfClosingElement;\n        readonly tagName: JsxTagNameExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly attributes: JsxAttributes;\n    }\n    export interface JsxFragment extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxFragment;\n        readonly openingFragment: JsxOpeningFragment;\n        readonly children: NodeArray<JsxChild>;\n        readonly closingFragment: JsxClosingFragment;\n    }\n    export interface JsxOpeningFragment extends Expression {\n        readonly kind: SyntaxKind.JsxOpeningFragment;\n        readonly parent: JsxFragment;\n    }\n    export interface JsxClosingFragment extends Expression {\n        readonly kind: SyntaxKind.JsxClosingFragment;\n        readonly parent: JsxFragment;\n    }\n    export interface JsxAttribute extends ObjectLiteralElement {\n        readonly kind: SyntaxKind.JsxAttribute;\n        readonly parent: JsxAttributes;\n        readonly name: Identifier;\n        readonly initializer?: StringLiteral | JsxExpression;\n    }\n    export interface JsxSpreadAttribute extends ObjectLiteralElement {\n        readonly kind: SyntaxKind.JsxSpreadAttribute;\n        readonly parent: JsxAttributes;\n        readonly expression: Expression;\n    }\n    export interface JsxClosingElement extends Node {\n        readonly kind: SyntaxKind.JsxClosingElement;\n        readonly parent: JsxElement;\n        readonly tagName: JsxTagNameExpression;\n    }\n    export interface JsxExpression extends Expression {\n        readonly kind: SyntaxKind.JsxExpression;\n        readonly parent: JsxElement | JsxFragment | JsxAttributeLike;\n        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\n        readonly expression?: Expression;\n    }\n    export interface JsxText extends LiteralLikeNode {\n        readonly kind: SyntaxKind.JsxText;\n        readonly parent: JsxElement | JsxFragment;\n        readonly containsOnlyTriviaWhiteSpaces: boolean;\n    }\n    export type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\n    export interface Statement extends Node, JSDocContainer {\n        _statementBrand: any;\n    }\n    export interface NotEmittedStatement extends Statement {\n        readonly kind: SyntaxKind.NotEmittedStatement;\n    }\n    /**\n     * A list of comma-separated expressions. This node is only created by transformations.\n     */\n    export interface CommaListExpression extends Expression {\n        readonly kind: SyntaxKind.CommaListExpression;\n        readonly elements: NodeArray<Expression>;\n    }\n    export interface EmptyStatement extends Statement {\n        readonly kind: SyntaxKind.EmptyStatement;\n    }\n    export interface DebuggerStatement extends Statement {\n        readonly kind: SyntaxKind.DebuggerStatement;\n    }\n    export interface MissingDeclaration extends DeclarationStatement {\n        readonly kind: SyntaxKind.MissingDeclaration;\n        readonly name?: Identifier;\n    }\n    export type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;\n    export interface Block extends Statement {\n        readonly kind: SyntaxKind.Block;\n        readonly statements: NodeArray<Statement>;\n    }\n    export interface VariableStatement extends Statement {\n        readonly kind: SyntaxKind.VariableStatement;\n        readonly declarationList: VariableDeclarationList;\n    }\n    export interface ExpressionStatement extends Statement {\n        readonly kind: SyntaxKind.ExpressionStatement;\n        readonly expression: Expression;\n    }\n    export interface IfStatement extends Statement {\n        readonly kind: SyntaxKind.IfStatement;\n        readonly expression: Expression;\n        readonly thenStatement: Statement;\n        readonly elseStatement?: Statement;\n    }\n    export interface IterationStatement extends Statement {\n        readonly statement: Statement;\n    }\n    export interface DoStatement extends IterationStatement {\n        readonly kind: SyntaxKind.DoStatement;\n        readonly expression: Expression;\n    }\n    export interface WhileStatement extends IterationStatement {\n        readonly kind: SyntaxKind.WhileStatement;\n        readonly expression: Expression;\n    }\n    export type ForInitializer = VariableDeclarationList | Expression;\n    export interface ForStatement extends IterationStatement {\n        readonly kind: SyntaxKind.ForStatement;\n        readonly initializer?: ForInitializer;\n        readonly condition?: Expression;\n        readonly incrementor?: Expression;\n    }\n    export type ForInOrOfStatement = ForInStatement | ForOfStatement;\n    export interface ForInStatement extends IterationStatement {\n        readonly kind: SyntaxKind.ForInStatement;\n        readonly initializer: ForInitializer;\n        readonly expression: Expression;\n    }\n    export interface ForOfStatement extends IterationStatement {\n        readonly kind: SyntaxKind.ForOfStatement;\n        readonly awaitModifier?: AwaitKeyword;\n        readonly initializer: ForInitializer;\n        readonly expression: Expression;\n    }\n    export interface BreakStatement extends Statement {\n        readonly kind: SyntaxKind.BreakStatement;\n        readonly label?: Identifier;\n    }\n    export interface ContinueStatement extends Statement {\n        readonly kind: SyntaxKind.ContinueStatement;\n        readonly label?: Identifier;\n    }\n    export type BreakOrContinueStatement = BreakStatement | ContinueStatement;\n    export interface ReturnStatement extends Statement {\n        readonly kind: SyntaxKind.ReturnStatement;\n        readonly expression?: Expression;\n    }\n    export interface WithStatement extends Statement {\n        readonly kind: SyntaxKind.WithStatement;\n        readonly expression: Expression;\n        readonly statement: Statement;\n    }\n    export interface SwitchStatement extends Statement {\n        readonly kind: SyntaxKind.SwitchStatement;\n        readonly expression: Expression;\n        readonly caseBlock: CaseBlock;\n        possiblyExhaustive?: boolean;\n    }\n    export interface CaseBlock extends Node {\n        readonly kind: SyntaxKind.CaseBlock;\n        readonly parent: SwitchStatement;\n        readonly clauses: NodeArray<CaseOrDefaultClause>;\n    }\n    export interface CaseClause extends Node {\n        readonly kind: SyntaxKind.CaseClause;\n        readonly parent: CaseBlock;\n        readonly expression: Expression;\n        readonly statements: NodeArray<Statement>;\n    }\n    export interface DefaultClause extends Node {\n        readonly kind: SyntaxKind.DefaultClause;\n        readonly parent: CaseBlock;\n        readonly statements: NodeArray<Statement>;\n    }\n    export type CaseOrDefaultClause = CaseClause | DefaultClause;\n    export interface LabeledStatement extends Statement {\n        readonly kind: SyntaxKind.LabeledStatement;\n        readonly label: Identifier;\n        readonly statement: Statement;\n    }\n    export interface ThrowStatement extends Statement {\n        readonly kind: SyntaxKind.ThrowStatement;\n        readonly expression: Expression;\n    }\n    export interface TryStatement extends Statement {\n        readonly kind: SyntaxKind.TryStatement;\n        readonly tryBlock: Block;\n        readonly catchClause?: CatchClause;\n        readonly finallyBlock?: Block;\n    }\n    export interface CatchClause extends Node {\n        readonly kind: SyntaxKind.CatchClause;\n        readonly parent: TryStatement;\n        readonly variableDeclaration?: VariableDeclaration;\n        readonly block: Block;\n    }\n    export type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;\n    export type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;\n    export type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;\n    export interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;\n        readonly name?: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly heritageClauses?: NodeArray<HeritageClause>;\n        readonly members: NodeArray<ClassElement>;\n    }\n    export interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {\n        readonly kind: SyntaxKind.ClassDeclaration;\n        /** May be undefined in `export default class { ... }`. */\n        readonly name?: Identifier;\n    }\n    export interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {\n        readonly kind: SyntaxKind.ClassExpression;\n    }\n    export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;\n    export interface ClassElement extends NamedDeclaration {\n        _classElementBrand: any;\n        readonly name?: PropertyName;\n    }\n    export interface TypeElement extends NamedDeclaration {\n        _typeElementBrand: any;\n        readonly name?: PropertyName;\n        readonly questionToken?: QuestionToken;\n    }\n    export interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.InterfaceDeclaration;\n        readonly name: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly heritageClauses?: NodeArray<HeritageClause>;\n        readonly members: NodeArray<TypeElement>;\n    }\n    export interface HeritageClause extends Node {\n        readonly kind: SyntaxKind.HeritageClause;\n        readonly parent: InterfaceDeclaration | ClassLikeDeclaration;\n        readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\n        readonly types: NodeArray<ExpressionWithTypeArguments>;\n    }\n    export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.TypeAliasDeclaration;\n        readonly name: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly type: TypeNode;\n    }\n    export interface EnumMember extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.EnumMember;\n        readonly parent: EnumDeclaration;\n        readonly name: PropertyName;\n        readonly initializer?: Expression;\n    }\n    export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.EnumDeclaration;\n        readonly name: Identifier;\n        readonly members: NodeArray<EnumMember>;\n    }\n    export type ModuleName = Identifier | StringLiteral;\n    export type ModuleBody = NamespaceBody | JSDocNamespaceBody;\n    export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ModuleDeclaration;\n        readonly parent: ModuleBody | SourceFile;\n        readonly name: ModuleName;\n        readonly body?: ModuleBody | JSDocNamespaceDeclaration;\n    }\n    export type NamespaceBody = ModuleBlock | NamespaceDeclaration;\n    export interface NamespaceDeclaration extends ModuleDeclaration {\n        readonly name: Identifier;\n        readonly body: NamespaceBody;\n    }\n    export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;\n    export interface JSDocNamespaceDeclaration extends ModuleDeclaration {\n        readonly name: Identifier;\n        readonly body?: JSDocNamespaceBody;\n    }\n    export interface ModuleBlock extends Node, Statement {\n        readonly kind: SyntaxKind.ModuleBlock;\n        readonly parent: ModuleDeclaration;\n        readonly statements: NodeArray<Statement>;\n    }\n    export type ModuleReference = EntityName | ExternalModuleReference;\n    /**\n     * One of:\n     * - import x = require("mod");\n     * - import x = M.x;\n     */\n    export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ImportEqualsDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly name: Identifier;\n        readonly isTypeOnly: boolean;\n        readonly moduleReference: ModuleReference;\n    }\n    export interface ExternalModuleReference extends Node {\n        readonly kind: SyntaxKind.ExternalModuleReference;\n        readonly parent: ImportEqualsDeclaration;\n        readonly expression: Expression;\n    }\n    export interface ImportDeclaration extends Statement {\n        readonly kind: SyntaxKind.ImportDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly importClause?: ImportClause;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        readonly moduleSpecifier: Expression;\n        readonly assertClause?: AssertClause;\n    }\n    export type NamedImportBindings = NamespaceImport | NamedImports;\n    export type NamedExportBindings = NamespaceExport | NamedExports;\n    export interface ImportClause extends NamedDeclaration {\n        readonly kind: SyntaxKind.ImportClause;\n        readonly parent: ImportDeclaration;\n        readonly isTypeOnly: boolean;\n        readonly name?: Identifier;\n        readonly namedBindings?: NamedImportBindings;\n    }\n    export type AssertionKey = Identifier | StringLiteral;\n    export interface AssertEntry extends Node {\n        readonly kind: SyntaxKind.AssertEntry;\n        readonly parent: AssertClause;\n        readonly name: AssertionKey;\n        readonly value: Expression;\n    }\n    export interface AssertClause extends Node {\n        readonly kind: SyntaxKind.AssertClause;\n        readonly parent: ImportDeclaration | ExportDeclaration;\n        readonly elements: NodeArray<AssertEntry>;\n        readonly multiLine?: boolean;\n    }\n    export interface NamespaceImport extends NamedDeclaration {\n        readonly kind: SyntaxKind.NamespaceImport;\n        readonly parent: ImportClause;\n        readonly name: Identifier;\n    }\n    export interface NamespaceExport extends NamedDeclaration {\n        readonly kind: SyntaxKind.NamespaceExport;\n        readonly parent: ExportDeclaration;\n        readonly name: Identifier;\n    }\n    export interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.NamespaceExportDeclaration;\n        readonly name: Identifier;\n    }\n    export interface ExportDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ExportDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly isTypeOnly: boolean;\n        /** Will not be assigned in the case of `export * from "foo";` */\n        readonly exportClause?: NamedExportBindings;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        readonly moduleSpecifier?: Expression;\n        readonly assertClause?: AssertClause;\n    }\n    export interface NamedImports extends Node {\n        readonly kind: SyntaxKind.NamedImports;\n        readonly parent: ImportClause;\n        readonly elements: NodeArray<ImportSpecifier>;\n    }\n    export interface NamedExports extends Node {\n        readonly kind: SyntaxKind.NamedExports;\n        readonly parent: ExportDeclaration;\n        readonly elements: NodeArray<ExportSpecifier>;\n    }\n    export type NamedImportsOrExports = NamedImports | NamedExports;\n    export interface ImportSpecifier extends NamedDeclaration {\n        readonly kind: SyntaxKind.ImportSpecifier;\n        readonly parent: NamedImports;\n        readonly propertyName?: Identifier;\n        readonly name: Identifier;\n        readonly isTypeOnly: boolean;\n    }\n    export interface ExportSpecifier extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.ExportSpecifier;\n        readonly parent: NamedExports;\n        readonly isTypeOnly: boolean;\n        readonly propertyName?: Identifier;\n        readonly name: Identifier;\n    }\n    export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;\n    export type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier;\n    export type TypeOnlyAliasDeclaration = ImportClause & {\n        readonly isTypeOnly: true;\n        readonly name: Identifier;\n    } | ImportEqualsDeclaration & {\n        readonly isTypeOnly: true;\n    } | NamespaceImport & {\n        readonly parent: ImportClause & {\n            readonly isTypeOnly: true;\n        };\n    } | ImportSpecifier & ({\n        readonly isTypeOnly: true;\n    } | {\n        readonly parent: NamedImports & {\n            readonly parent: ImportClause & {\n                readonly isTypeOnly: true;\n            };\n        };\n    }) | ExportSpecifier & ({\n        readonly isTypeOnly: true;\n    } | {\n        readonly parent: NamedExports & {\n            readonly parent: ExportDeclaration & {\n                readonly isTypeOnly: true;\n            };\n        };\n    });\n    /**\n     * This is either an `export =` or an `export default` declaration.\n     * Unless `isExportEquals` is set, this node was parsed as an `export default`.\n     */\n    export interface ExportAssignment extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ExportAssignment;\n        readonly parent: SourceFile;\n        readonly isExportEquals?: boolean;\n        readonly expression: Expression;\n    }\n    export interface FileReference extends TextRange {\n        fileName: string;\n    }\n    export interface CheckJsDirective extends TextRange {\n        enabled: boolean;\n    }\n    export type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;\n    export interface CommentRange extends TextRange {\n        hasTrailingNewLine?: boolean;\n        kind: CommentKind;\n    }\n    export interface SynthesizedComment extends CommentRange {\n        text: string;\n        pos: -1;\n        end: -1;\n        hasLeadingNewline?: boolean;\n    }\n    export interface JSDocTypeExpression extends TypeNode {\n        readonly kind: SyntaxKind.JSDocTypeExpression;\n        readonly type: TypeNode;\n    }\n    export interface JSDocNameReference extends Node {\n        readonly kind: SyntaxKind.JSDocNameReference;\n        readonly name: EntityName | JSDocMemberName;\n    }\n    /** Class#method reference in JSDoc */\n    export interface JSDocMemberName extends Node {\n        readonly kind: SyntaxKind.JSDocMemberName;\n        readonly left: EntityName | JSDocMemberName;\n        readonly right: Identifier;\n    }\n    export interface JSDocType extends TypeNode {\n        _jsDocTypeBrand: any;\n    }\n    export interface JSDocAllType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocAllType;\n    }\n    export interface JSDocUnknownType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocUnknownType;\n    }\n    export interface JSDocNonNullableType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNonNullableType;\n        readonly type: TypeNode;\n    }\n    export interface JSDocNullableType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNullableType;\n        readonly type: TypeNode;\n    }\n    export interface JSDocOptionalType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocOptionalType;\n        readonly type: TypeNode;\n    }\n    export interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase {\n        readonly kind: SyntaxKind.JSDocFunctionType;\n    }\n    export interface JSDocVariadicType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocVariadicType;\n        readonly type: TypeNode;\n    }\n    export interface JSDocNamepathType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNamepathType;\n        readonly type: TypeNode;\n    }\n    export type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;\n    export interface JSDoc extends Node {\n        readonly kind: SyntaxKind.JSDocComment;\n        readonly parent: HasJSDoc;\n        readonly tags?: NodeArray<JSDocTag>;\n        readonly comment?: string | NodeArray<JSDocComment>;\n    }\n    export interface JSDocTag extends Node {\n        readonly parent: JSDoc | JSDocTypeLiteral;\n        readonly tagName: Identifier;\n        readonly comment?: string | NodeArray<JSDocComment>;\n    }\n    export interface JSDocLink extends Node {\n        readonly kind: SyntaxKind.JSDocLink;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    export interface JSDocLinkCode extends Node {\n        readonly kind: SyntaxKind.JSDocLinkCode;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    export interface JSDocLinkPlain extends Node {\n        readonly kind: SyntaxKind.JSDocLinkPlain;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    export type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;\n    export interface JSDocText extends Node {\n        readonly kind: SyntaxKind.JSDocText;\n        text: string;\n    }\n    export interface JSDocUnknownTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTag;\n    }\n    /**\n     * Note that `@extends` is a synonym of `@augments`.\n     * Both tags are represented by this interface.\n     */\n    export interface JSDocAugmentsTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocAugmentsTag;\n        readonly class: ExpressionWithTypeArguments & {\n            readonly expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    export interface JSDocImplementsTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocImplementsTag;\n        readonly class: ExpressionWithTypeArguments & {\n            readonly expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    export interface JSDocAuthorTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocAuthorTag;\n    }\n    export interface JSDocDeprecatedTag extends JSDocTag {\n        kind: SyntaxKind.JSDocDeprecatedTag;\n    }\n    export interface JSDocClassTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocClassTag;\n    }\n    export interface JSDocPublicTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocPublicTag;\n    }\n    export interface JSDocPrivateTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocPrivateTag;\n    }\n    export interface JSDocProtectedTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocProtectedTag;\n    }\n    export interface JSDocReadonlyTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocReadonlyTag;\n    }\n    export interface JSDocOverrideTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocOverrideTag;\n    }\n    export interface JSDocEnumTag extends JSDocTag, Declaration {\n        readonly kind: SyntaxKind.JSDocEnumTag;\n        readonly parent: JSDoc;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    export interface JSDocThisTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocThisTag;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    export interface JSDocTemplateTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTemplateTag;\n        readonly constraint: JSDocTypeExpression | undefined;\n        readonly typeParameters: NodeArray<TypeParameterDeclaration>;\n    }\n    export interface JSDocSeeTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocSeeTag;\n        readonly name?: JSDocNameReference;\n    }\n    export interface JSDocReturnTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocReturnTag;\n        readonly typeExpression?: JSDocTypeExpression;\n    }\n    export interface JSDocTypeTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTypeTag;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    export interface JSDocTypedefTag extends JSDocTag, NamedDeclaration {\n        readonly kind: SyntaxKind.JSDocTypedefTag;\n        readonly parent: JSDoc;\n        readonly fullName?: JSDocNamespaceDeclaration | Identifier;\n        readonly name?: Identifier;\n        readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;\n    }\n    export interface JSDocCallbackTag extends JSDocTag, NamedDeclaration {\n        readonly kind: SyntaxKind.JSDocCallbackTag;\n        readonly parent: JSDoc;\n        readonly fullName?: JSDocNamespaceDeclaration | Identifier;\n        readonly name?: Identifier;\n        readonly typeExpression: JSDocSignature;\n    }\n    export interface JSDocSignature extends JSDocType, Declaration {\n        readonly kind: SyntaxKind.JSDocSignature;\n        readonly typeParameters?: readonly JSDocTemplateTag[];\n        readonly parameters: readonly JSDocParameterTag[];\n        readonly type: JSDocReturnTag | undefined;\n    }\n    export interface JSDocPropertyLikeTag extends JSDocTag, Declaration {\n        readonly parent: JSDoc;\n        readonly name: EntityName;\n        readonly typeExpression?: JSDocTypeExpression;\n        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */\n        readonly isNameFirst: boolean;\n        readonly isBracketed: boolean;\n    }\n    export interface JSDocPropertyTag extends JSDocPropertyLikeTag {\n        readonly kind: SyntaxKind.JSDocPropertyTag;\n    }\n    export interface JSDocParameterTag extends JSDocPropertyLikeTag {\n        readonly kind: SyntaxKind.JSDocParameterTag;\n    }\n    export interface JSDocTypeLiteral extends JSDocType {\n        readonly kind: SyntaxKind.JSDocTypeLiteral;\n        readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];\n        /** If true, then this type literal represents an *array* of its type. */\n        readonly isArrayType: boolean;\n    }\n    export enum FlowFlags {\n        Unreachable = 1,\n        Start = 2,\n        BranchLabel = 4,\n        LoopLabel = 8,\n        Assignment = 16,\n        TrueCondition = 32,\n        FalseCondition = 64,\n        SwitchClause = 128,\n        ArrayMutation = 256,\n        Call = 512,\n        ReduceLabel = 1024,\n        Referenced = 2048,\n        Shared = 4096,\n        Label = 12,\n        Condition = 96\n    }\n    export type FlowNode = FlowStart | FlowLabel | FlowAssignment | FlowCall | FlowCondition | FlowSwitchClause | FlowArrayMutation | FlowCall | FlowReduceLabel;\n    export interface FlowNodeBase {\n        flags: FlowFlags;\n        id?: number;\n    }\n    export interface FlowStart extends FlowNodeBase {\n        node?: FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;\n    }\n    export interface FlowLabel extends FlowNodeBase {\n        antecedents: FlowNode[] | undefined;\n    }\n    export interface FlowAssignment extends FlowNodeBase {\n        node: Expression | VariableDeclaration | BindingElement;\n        antecedent: FlowNode;\n    }\n    export interface FlowCall extends FlowNodeBase {\n        node: CallExpression;\n        antecedent: FlowNode;\n    }\n    export interface FlowCondition extends FlowNodeBase {\n        node: Expression;\n        antecedent: FlowNode;\n    }\n    export interface FlowSwitchClause extends FlowNodeBase {\n        switchStatement: SwitchStatement;\n        clauseStart: number;\n        clauseEnd: number;\n        antecedent: FlowNode;\n    }\n    export interface FlowArrayMutation extends FlowNodeBase {\n        node: CallExpression | BinaryExpression;\n        antecedent: FlowNode;\n    }\n    export interface FlowReduceLabel extends FlowNodeBase {\n        target: FlowLabel;\n        antecedents: FlowNode[];\n        antecedent: FlowNode;\n    }\n    export type FlowType = Type | IncompleteType;\n    export interface IncompleteType {\n        flags: TypeFlags;\n        type: Type;\n    }\n    export interface AmdDependency {\n        path: string;\n        name?: string;\n    }\n    export interface SourceFile extends Declaration {\n        readonly kind: SyntaxKind.SourceFile;\n        readonly statements: NodeArray<Statement>;\n        readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;\n        fileName: string;\n        text: string;\n        amdDependencies: readonly AmdDependency[];\n        moduleName?: string;\n        referencedFiles: readonly FileReference[];\n        typeReferenceDirectives: readonly FileReference[];\n        libReferenceDirectives: readonly FileReference[];\n        languageVariant: LanguageVariant;\n        isDeclarationFile: boolean;\n        /**\n         * lib.d.ts should have a reference comment like\n         *\n         *  /// <reference no-default-lib="true"/>\n         *\n         * If any other file has this comment, it signals not to include lib.d.ts\n         * because this containing file is intended to act as a default library.\n         */\n        hasNoDefaultLib: boolean;\n        languageVersion: ScriptTarget;\n        /**\n         * When `module` is `Node12` or `NodeNext`, this field controls whether the\n         * source file in question is an ESNext-output-format file, or a CommonJS-output-format\n         * module. This is derived by the module resolver as it looks up the file, since\n         * it is derived from either the file extension of the module, or the containing\n         * `package.json` context, and affects both checking and emit.\n         *\n         * It is _public_ so that (pre)transformers can set this field,\n         * since it switches the builtin `node` module transform. Generally speaking, if unset,\n         * the field is treated as though it is `ModuleKind.CommonJS`.\n         */\n        impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;\n    }\n    export interface Bundle extends Node {\n        readonly kind: SyntaxKind.Bundle;\n        readonly prepends: readonly (InputFiles | UnparsedSource)[];\n        readonly sourceFiles: readonly SourceFile[];\n    }\n    export interface InputFiles extends Node {\n        readonly kind: SyntaxKind.InputFiles;\n        javascriptPath?: string;\n        javascriptText: string;\n        javascriptMapPath?: string;\n        javascriptMapText?: string;\n        declarationPath?: string;\n        declarationText: string;\n        declarationMapPath?: string;\n        declarationMapText?: string;\n    }\n    export interface UnparsedSource extends Node {\n        readonly kind: SyntaxKind.UnparsedSource;\n        fileName: string;\n        text: string;\n        readonly prologues: readonly UnparsedPrologue[];\n        helpers: readonly UnscopedEmitHelper[] | undefined;\n        referencedFiles: readonly FileReference[];\n        typeReferenceDirectives: readonly string[] | undefined;\n        libReferenceDirectives: readonly FileReference[];\n        hasNoDefaultLib?: boolean;\n        sourceMapPath?: string;\n        sourceMapText?: string;\n        readonly syntheticReferences?: readonly UnparsedSyntheticReference[];\n        readonly texts: readonly UnparsedSourceText[];\n    }\n    export type UnparsedSourceText = UnparsedPrepend | UnparsedTextLike;\n    export type UnparsedNode = UnparsedPrologue | UnparsedSourceText | UnparsedSyntheticReference;\n    export interface UnparsedSection extends Node {\n        readonly kind: SyntaxKind;\n        readonly parent: UnparsedSource;\n        readonly data?: string;\n    }\n    export interface UnparsedPrologue extends UnparsedSection {\n        readonly kind: SyntaxKind.UnparsedPrologue;\n        readonly parent: UnparsedSource;\n        readonly data: string;\n    }\n    export interface UnparsedPrepend extends UnparsedSection {\n        readonly kind: SyntaxKind.UnparsedPrepend;\n        readonly parent: UnparsedSource;\n        readonly data: string;\n        readonly texts: readonly UnparsedTextLike[];\n    }\n    export interface UnparsedTextLike extends UnparsedSection {\n        readonly kind: SyntaxKind.UnparsedText | SyntaxKind.UnparsedInternalText;\n        readonly parent: UnparsedSource;\n    }\n    export interface UnparsedSyntheticReference extends UnparsedSection {\n        readonly kind: SyntaxKind.UnparsedSyntheticReference;\n        readonly parent: UnparsedSource;\n    }\n    export interface JsonSourceFile extends SourceFile {\n        readonly statements: NodeArray<JsonObjectExpressionStatement>;\n    }\n    export interface TsConfigSourceFile extends JsonSourceFile {\n        extendedSourceFiles?: string[];\n    }\n    export interface JsonMinusNumericLiteral extends PrefixUnaryExpression {\n        readonly kind: SyntaxKind.PrefixUnaryExpression;\n        readonly operator: SyntaxKind.MinusToken;\n        readonly operand: NumericLiteral;\n    }\n    export type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;\n    export interface JsonObjectExpressionStatement extends ExpressionStatement {\n        readonly expression: JsonObjectExpression;\n    }\n    export interface ScriptReferenceHost {\n        getCompilerOptions(): CompilerOptions;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFileByPath(path: Path): SourceFile | undefined;\n        getCurrentDirectory(): string;\n    }\n    export interface ParseConfigHost {\n        useCaseSensitiveFileNames: boolean;\n        readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];\n        /**\n         * Gets a value indicating whether the specified path exists and is a file.\n         * @param path The path to test.\n         */\n        fileExists(path: string): boolean;\n        readFile(path: string): string | undefined;\n        trace?(s: string): void;\n    }\n    /**\n     * Branded string for keeping track of when we\'ve turned an ambiguous path\n     * specified like "./blah" to an absolute path to an actual\n     * tsconfig file, e.g. "/root/blah/tsconfig.json"\n     */\n    export type ResolvedConfigFileName = string & {\n        _isResolvedConfigFileName: never;\n    };\n    export type WriteFileCallback = (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[]) => void;\n    export class OperationCanceledException {\n    }\n    export interface CancellationToken {\n        isCancellationRequested(): boolean;\n        /** @throws OperationCanceledException if isCancellationRequested is true */\n        throwIfCancellationRequested(): void;\n    }\n    export interface Program extends ScriptReferenceHost {\n        getCurrentDirectory(): string;\n        /**\n         * Get a list of root file names that were passed to a \'createProgram\'\n         */\n        getRootFileNames(): readonly string[];\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then\n         * the JavaScript and declaration files will be produced for all the files in this program.\n         * If targetSourceFile is specified, then only the JavaScript and declaration for that\n         * specific file will be generated.\n         *\n         * If writeFile is not specified then the writeFile callback from the compiler host will be\n         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter\n         * will be invoked when writing the JavaScript and declaration files.\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /** The first time this is called, it will return global diagnostics (no location). */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Gets a type checker that can be used to semantically analyze source files in the program.\n         */\n        getTypeChecker(): TypeChecker;\n        getNodeCount(): number;\n        getIdentifierCount(): number;\n        getSymbolCount(): number;\n        getTypeCount(): number;\n        getInstantiationCount(): number;\n        getRelationCacheSizes(): {\n            assignable: number;\n            identity: number;\n            subtype: number;\n            strictSubtype: number;\n        };\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\n        isSourceFileDefaultLibrary(file: SourceFile): boolean;\n        getProjectReferences(): readonly ProjectReference[] | undefined;\n        getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;\n    }\n    export interface ResolvedProjectReference {\n        commandLine: ParsedCommandLine;\n        sourceFile: SourceFile;\n        references?: readonly (ResolvedProjectReference | undefined)[];\n    }\n    export type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;\n    export interface CustomTransformer {\n        transformSourceFile(node: SourceFile): SourceFile;\n        transformBundle(node: Bundle): Bundle;\n    }\n    export interface CustomTransformers {\n        /** Custom transformers to evaluate before built-in .js transformations. */\n        before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .js transformations. */\n        after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .d.ts transformations. */\n        afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];\n    }\n    export interface SourceMapSpan {\n        /** Line number in the .js file. */\n        emittedLine: number;\n        /** Column number in the .js file. */\n        emittedColumn: number;\n        /** Line number in the .ts file. */\n        sourceLine: number;\n        /** Column number in the .ts file. */\n        sourceColumn: number;\n        /** Optional name (index into names array) associated with this span. */\n        nameIndex?: number;\n        /** .ts file (index into sources array) associated with this span */\n        sourceIndex: number;\n    }\n    /** Return code used by getEmitOutput function to indicate status of the function */\n    export enum ExitStatus {\n        Success = 0,\n        DiagnosticsPresent_OutputsSkipped = 1,\n        DiagnosticsPresent_OutputsGenerated = 2,\n        InvalidProject_OutputsSkipped = 3,\n        ProjectReferenceCycle_OutputsSkipped = 4,\n        /** @deprecated Use ProjectReferenceCycle_OutputsSkipped instead. */\n        ProjectReferenceCycle_OutputsSkupped = 4\n    }\n    export interface EmitResult {\n        emitSkipped: boolean;\n        /** Contains declaration emit diagnostics */\n        diagnostics: readonly Diagnostic[];\n        emittedFiles?: string[];\n    }\n    export interface TypeChecker {\n        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\n        getDeclaredTypeOfSymbol(symbol: Symbol): Type;\n        getPropertiesOfType(type: Type): Symbol[];\n        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;\n        getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;\n        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;\n        getIndexInfosOfType(type: Type): readonly IndexInfo[];\n        getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;\n        getBaseTypes(type: InterfaceType): BaseType[];\n        getBaseTypeOfLiteralType(type: Type): Type;\n        getWidenedType(type: Type): Type;\n        getReturnTypeOfSignature(signature: Signature): Type;\n        getNullableType(type: Type, flags: TypeFlags): Type;\n        getNonNullableType(type: Type): Type;\n        getTypeArguments(type: TypeReference): readonly Type[];\n        /** Note that the resulting nodes cannot be checked. */\n        typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): SignatureDeclaration & {\n            typeArguments?: NodeArray<TypeNode>;\n        } | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\n        getSymbolAtLocation(node: Node): Symbol | undefined;\n        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];\n        /**\n         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.\n         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.\n         */\n        getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;\n        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;\n        /**\n         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.\n         * Otherwise returns its input.\n         * For example, at `export type T = number;`:\n         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.\n         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.\n         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.\n         */\n        getExportSymbolOfSymbol(symbol: Symbol): Symbol;\n        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;\n        getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;\n        getTypeAtLocation(node: Node): Type;\n        getTypeFromTypeNode(node: TypeNode): Type;\n        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;\n        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        getFullyQualifiedName(symbol: Symbol): string;\n        getAugmentedPropertiesOfType(type: Type): Symbol[];\n        getRootSymbols(symbol: Symbol): readonly Symbol[];\n        getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;\n        getContextualType(node: Expression): Type | undefined;\n        /**\n         * returns unknownSignature in the case of an error.\n         * returns undefined if the node is not valid.\n         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.\n         */\n        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;\n        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;\n        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;\n        isUndefinedSymbol(symbol: Symbol): boolean;\n        isArgumentsSymbol(symbol: Symbol): boolean;\n        isUnknownSymbol(symbol: Symbol): boolean;\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\n        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;\n        /** Follow all aliases to get the original symbol. */\n        getAliasedSymbol(symbol: Symbol): Symbol;\n        /** Follow a *single* alias to get the immediately aliased symbol. */\n        getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;\n        getExportsOfModule(moduleSymbol: Symbol): Symbol[];\n        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];\n        isOptionalParameter(node: ParameterDeclaration): boolean;\n        getAmbientModules(): Symbol[];\n        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\n        getApparentType(type: Type): Type;\n        getBaseConstraintOfType(type: Type): Type | undefined;\n        getDefaultFromTypeParameter(type: Type): Type | undefined;\n        getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;\n        /**\n         * Depending on the operation performed, it may be appropriate to throw away the checker\n         * if the cancellation token is triggered. Typically, if it is used for error checking\n         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.\n         */\n        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;\n    }\n    export enum NodeBuilderFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        GenerateNamesForShadowedTypeParams = 4,\n        UseStructuralFallback = 8,\n        ForbidIndexedAccessSymbolReferences = 16,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        UseOnlyExternalAliasing = 128,\n        SuppressAnyReturnType = 256,\n        WriteTypeParametersInQualifiedName = 512,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        NoUndefinedOptionalParameterType = 1073741824,\n        AllowThisInObjectLiteral = 32768,\n        AllowQualifiedNameInPlaceOfIdentifier = 65536,\n        /** @deprecated AllowQualifedNameInPlaceOfIdentifier. Use AllowQualifiedNameInPlaceOfIdentifier instead. */\n        AllowQualifedNameInPlaceOfIdentifier = 65536,\n        AllowAnonymousIdentifier = 131072,\n        AllowEmptyUnionOrIntersection = 262144,\n        AllowEmptyTuple = 524288,\n        AllowUniqueESSymbolType = 1048576,\n        AllowEmptyIndexInfoType = 2097152,\n        AllowNodeModulesRelativePaths = 67108864,\n        IgnoreErrors = 70221824,\n        InObjectTypeLiteral = 4194304,\n        InTypeAlias = 8388608,\n        InInitialEntityName = 16777216\n    }\n    export enum TypeFormatFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        UseStructuralFallback = 8,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        SuppressAnyReturnType = 256,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        AllowUniqueESSymbolType = 1048576,\n        AddUndefined = 131072,\n        WriteArrowStyleSignature = 262144,\n        InArrayType = 524288,\n        InElementType = 2097152,\n        InFirstTypeArgument = 4194304,\n        InTypeAlias = 8388608,\n        /** @deprecated */ WriteOwnNameForAnyLike = 0,\n        NodeBuilderFlagsMask = 814775659\n    }\n    export enum SymbolFormatFlags {\n        None = 0,\n        WriteTypeParametersOrArguments = 1,\n        UseOnlyExternalAliasing = 2,\n        AllowAnyNodeKind = 4,\n        UseAliasDefinedOutsideCurrentScope = 8,\n    }\n    export enum TypePredicateKind {\n        This = 0,\n        Identifier = 1,\n        AssertsThis = 2,\n        AssertsIdentifier = 3\n    }\n    export interface TypePredicateBase {\n        kind: TypePredicateKind;\n        type: Type | undefined;\n    }\n    export interface ThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.This;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type;\n    }\n    export interface IdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.Identifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type;\n    }\n    export interface AssertsThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsThis;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type | undefined;\n    }\n    export interface AssertsIdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsIdentifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type | undefined;\n    }\n    export type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;\n    export enum SymbolFlags {\n        None = 0,\n        FunctionScopedVariable = 1,\n        BlockScopedVariable = 2,\n        Property = 4,\n        EnumMember = 8,\n        Function = 16,\n        Class = 32,\n        Interface = 64,\n        ConstEnum = 128,\n        RegularEnum = 256,\n        ValueModule = 512,\n        NamespaceModule = 1024,\n        TypeLiteral = 2048,\n        ObjectLiteral = 4096,\n        Method = 8192,\n        Constructor = 16384,\n        GetAccessor = 32768,\n        SetAccessor = 65536,\n        Signature = 131072,\n        TypeParameter = 262144,\n        TypeAlias = 524288,\n        ExportValue = 1048576,\n        Alias = 2097152,\n        Prototype = 4194304,\n        ExportStar = 8388608,\n        Optional = 16777216,\n        Transient = 33554432,\n        Assignment = 67108864,\n        ModuleExports = 134217728,\n        Enum = 384,\n        Variable = 3,\n        Value = 111551,\n        Type = 788968,\n        Namespace = 1920,\n        Module = 1536,\n        Accessor = 98304,\n        FunctionScopedVariableExcludes = 111550,\n        BlockScopedVariableExcludes = 111551,\n        ParameterExcludes = 111551,\n        PropertyExcludes = 0,\n        EnumMemberExcludes = 900095,\n        FunctionExcludes = 110991,\n        ClassExcludes = 899503,\n        InterfaceExcludes = 788872,\n        RegularEnumExcludes = 899327,\n        ConstEnumExcludes = 899967,\n        ValueModuleExcludes = 110735,\n        NamespaceModuleExcludes = 0,\n        MethodExcludes = 103359,\n        GetAccessorExcludes = 46015,\n        SetAccessorExcludes = 78783,\n        TypeParameterExcludes = 526824,\n        TypeAliasExcludes = 788968,\n        AliasExcludes = 2097152,\n        ModuleMember = 2623475,\n        ExportHasLocal = 944,\n        BlockScoped = 418,\n        PropertyOrAccessor = 98308,\n        ClassMember = 106500,\n    }\n    export interface Symbol {\n        flags: SymbolFlags;\n        escapedName: __String;\n        declarations?: Declaration[];\n        valueDeclaration?: Declaration;\n        members?: SymbolTable;\n        exports?: SymbolTable;\n        globalExports?: SymbolTable;\n    }\n    export enum InternalSymbolName {\n        Call = "__call",\n        Constructor = "__constructor",\n        New = "__new",\n        Index = "__index",\n        ExportStar = "__export",\n        Global = "__global",\n        Missing = "__missing",\n        Type = "__type",\n        Object = "__object",\n        JSXAttributes = "__jsxAttributes",\n        Class = "__class",\n        Function = "__function",\n        Computed = "__computed",\n        Resolving = "__resolving__",\n        ExportEquals = "export=",\n        Default = "default",\n        This = "this"\n    }\n    /**\n     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.\n     * The shape of this brand is rather unique compared to others we\'ve used.\n     * Instead of just an intersection of a string and an object, it is that union-ed\n     * with an intersection of void and an object. This makes it wholly incompatible\n     * with a normal string (which is good, it cannot be misused on assignment or on usage),\n     * while still being comparable with a normal string via === (also good) and castable from a string.\n     */\n    export type __String = (string & {\n        __escapedIdentifier: void;\n    }) | (void & {\n        __escapedIdentifier: void;\n    }) | InternalSymbolName;\n    /** ReadonlyMap where keys are `__String`s. */\n    export interface ReadonlyUnderscoreEscapedMap<T> extends ReadonlyESMap<__String, T> {\n    }\n    /** Map where keys are `__String`s. */\n    export interface UnderscoreEscapedMap<T> extends ESMap<__String, T>, ReadonlyUnderscoreEscapedMap<T> {\n    }\n    /** SymbolTable based on ES6 Map interface. */\n    export type SymbolTable = UnderscoreEscapedMap<Symbol>;\n    export enum TypeFlags {\n        Any = 1,\n        Unknown = 2,\n        String = 4,\n        Number = 8,\n        Boolean = 16,\n        Enum = 32,\n        BigInt = 64,\n        StringLiteral = 128,\n        NumberLiteral = 256,\n        BooleanLiteral = 512,\n        EnumLiteral = 1024,\n        BigIntLiteral = 2048,\n        ESSymbol = 4096,\n        UniqueESSymbol = 8192,\n        Void = 16384,\n        Undefined = 32768,\n        Null = 65536,\n        Never = 131072,\n        TypeParameter = 262144,\n        Object = 524288,\n        Union = 1048576,\n        Intersection = 2097152,\n        Index = 4194304,\n        IndexedAccess = 8388608,\n        Conditional = 16777216,\n        Substitution = 33554432,\n        NonPrimitive = 67108864,\n        TemplateLiteral = 134217728,\n        StringMapping = 268435456,\n        Literal = 2944,\n        Unit = 109440,\n        StringOrNumberLiteral = 384,\n        PossiblyFalsy = 117724,\n        StringLike = 402653316,\n        NumberLike = 296,\n        BigIntLike = 2112,\n        BooleanLike = 528,\n        EnumLike = 1056,\n        ESSymbolLike = 12288,\n        VoidLike = 49152,\n        UnionOrIntersection = 3145728,\n        StructuredType = 3670016,\n        TypeVariable = 8650752,\n        InstantiableNonPrimitive = 58982400,\n        InstantiablePrimitive = 406847488,\n        Instantiable = 465829888,\n        StructuredOrInstantiable = 469499904,\n        Narrowable = 536624127,\n    }\n    export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;\n    export interface Type {\n        flags: TypeFlags;\n        symbol: Symbol;\n        pattern?: DestructuringPattern;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: readonly Type[];\n    }\n    export interface LiteralType extends Type {\n        value: string | number | PseudoBigInt;\n        freshType: LiteralType;\n        regularType: LiteralType;\n    }\n    export interface UniqueESSymbolType extends Type {\n        symbol: Symbol;\n        escapedName: __String;\n    }\n    export interface StringLiteralType extends LiteralType {\n        value: string;\n    }\n    export interface NumberLiteralType extends LiteralType {\n        value: number;\n    }\n    export interface BigIntLiteralType extends LiteralType {\n        value: PseudoBigInt;\n    }\n    export interface EnumType extends Type {\n    }\n    export enum ObjectFlags {\n        Class = 1,\n        Interface = 2,\n        Reference = 4,\n        Tuple = 8,\n        Anonymous = 16,\n        Mapped = 32,\n        Instantiated = 64,\n        ObjectLiteral = 128,\n        EvolvingArray = 256,\n        ObjectLiteralPatternWithComputedProperties = 512,\n        ReverseMapped = 1024,\n        JsxAttributes = 2048,\n        MarkerType = 4096,\n        JSLiteral = 8192,\n        FreshLiteral = 16384,\n        ArrayLiteral = 32768,\n        ClassOrInterface = 3,\n        ContainsSpread = 4194304,\n        ObjectRestType = 8388608,\n    }\n    export interface ObjectType extends Type {\n        objectFlags: ObjectFlags;\n    }\n    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */\n    export interface InterfaceType extends ObjectType {\n        typeParameters: TypeParameter[] | undefined;\n        outerTypeParameters: TypeParameter[] | undefined;\n        localTypeParameters: TypeParameter[] | undefined;\n        thisType: TypeParameter | undefined;\n    }\n    export type BaseType = ObjectType | IntersectionType | TypeVariable;\n    export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {\n        declaredProperties: Symbol[];\n        declaredCallSignatures: Signature[];\n        declaredConstructSignatures: Signature[];\n        declaredIndexInfos: IndexInfo[];\n    }\n    /**\n     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or\n     * a "this" type, references to the class or interface are made using type references. The\n     * typeArguments property specifies the types to substitute for the type parameters of the\n     * class or interface and optionally includes an extra element that specifies the type to\n     * substitute for "this" in the resulting instantiation. When no extra argument is present,\n     * the type reference itself is substituted for "this". The typeArguments property is undefined\n     * if the class or interface has no type parameters and the reference isn\'t specifying an\n     * explicit "this" argument.\n     */\n    export interface TypeReference extends ObjectType {\n        target: GenericType;\n        node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;\n    }\n    export interface DeferredTypeReference extends TypeReference {\n    }\n    export interface GenericType extends InterfaceType, TypeReference {\n    }\n    export enum ElementFlags {\n        Required = 1,\n        Optional = 2,\n        Rest = 4,\n        Variadic = 8,\n        Fixed = 3,\n        Variable = 12,\n        NonRequired = 14,\n        NonRest = 11\n    }\n    export interface TupleType extends GenericType {\n        elementFlags: readonly ElementFlags[];\n        minLength: number;\n        fixedLength: number;\n        hasRestElement: boolean;\n        combinedFlags: ElementFlags;\n        readonly: boolean;\n        labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];\n    }\n    export interface TupleTypeReference extends TypeReference {\n        target: TupleType;\n    }\n    export interface UnionOrIntersectionType extends Type {\n        types: Type[];\n    }\n    export interface UnionType extends UnionOrIntersectionType {\n    }\n    export interface IntersectionType extends UnionOrIntersectionType {\n    }\n    export type StructuredType = ObjectType | UnionType | IntersectionType;\n    export interface EvolvingArrayType extends ObjectType {\n        elementType: Type;\n        finalArrayType?: Type;\n    }\n    export interface InstantiableType extends Type {\n    }\n    export interface TypeParameter extends InstantiableType {\n    }\n    export interface IndexedAccessType extends InstantiableType {\n        objectType: Type;\n        indexType: Type;\n        constraint?: Type;\n        simplifiedForReading?: Type;\n        simplifiedForWriting?: Type;\n    }\n    export type TypeVariable = TypeParameter | IndexedAccessType;\n    export interface IndexType extends InstantiableType {\n        type: InstantiableType | UnionOrIntersectionType;\n    }\n    export interface ConditionalRoot {\n        node: ConditionalTypeNode;\n        checkType: Type;\n        extendsType: Type;\n        isDistributive: boolean;\n        inferTypeParameters?: TypeParameter[];\n        outerTypeParameters?: TypeParameter[];\n        instantiations?: Map<Type>;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: Type[];\n    }\n    export interface ConditionalType extends InstantiableType {\n        root: ConditionalRoot;\n        checkType: Type;\n        extendsType: Type;\n        resolvedTrueType?: Type;\n        resolvedFalseType?: Type;\n    }\n    export interface TemplateLiteralType extends InstantiableType {\n        texts: readonly string[];\n        types: readonly Type[];\n    }\n    export interface StringMappingType extends InstantiableType {\n        symbol: Symbol;\n        type: Type;\n    }\n    export interface SubstitutionType extends InstantiableType {\n        objectFlags: ObjectFlags;\n        baseType: Type;\n        substitute: Type;\n    }\n    export enum SignatureKind {\n        Call = 0,\n        Construct = 1\n    }\n    export interface Signature {\n        declaration?: SignatureDeclaration | JSDocSignature;\n        typeParameters?: readonly TypeParameter[];\n        parameters: readonly Symbol[];\n    }\n    export enum IndexKind {\n        String = 0,\n        Number = 1\n    }\n    export interface IndexInfo {\n        keyType: Type;\n        type: Type;\n        isReadonly: boolean;\n        declaration?: IndexSignatureDeclaration;\n    }\n    export enum InferencePriority {\n        NakedTypeVariable = 1,\n        SpeculativeTuple = 2,\n        SubstituteSource = 4,\n        HomomorphicMappedType = 8,\n        PartialHomomorphicMappedType = 16,\n        MappedTypeConstraint = 32,\n        ContravariantConditional = 64,\n        ReturnType = 128,\n        LiteralKeyof = 256,\n        NoConstraints = 512,\n        AlwaysStrict = 1024,\n        MaxValue = 2048,\n        PriorityImpliesCombination = 416,\n        Circularity = -1\n    }\n    /** @deprecated Use FileExtensionInfo instead. */\n    export type JsFileExtensionInfo = FileExtensionInfo;\n    export interface FileExtensionInfo {\n        extension: string;\n        isMixedContent: boolean;\n        scriptKind?: ScriptKind;\n    }\n    export interface DiagnosticMessage {\n        key: string;\n        category: DiagnosticCategory;\n        code: number;\n        message: string;\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n    }\n    /**\n     * A linked list of formatted diagnostic messages to be used as part of a multiline message.\n     * It is built from the bottom up, leaving the head to be the "main" diagnostic.\n     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\n     * the difference is that messages are all preformatted in DMC.\n     */\n    export interface DiagnosticMessageChain {\n        messageText: string;\n        category: DiagnosticCategory;\n        code: number;\n        next?: DiagnosticMessageChain[];\n    }\n    export interface Diagnostic extends DiagnosticRelatedInformation {\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n        source?: string;\n        relatedInformation?: DiagnosticRelatedInformation[];\n    }\n    export interface DiagnosticRelatedInformation {\n        category: DiagnosticCategory;\n        code: number;\n        file: SourceFile | undefined;\n        start: number | undefined;\n        length: number | undefined;\n        messageText: string | DiagnosticMessageChain;\n    }\n    export interface DiagnosticWithLocation extends Diagnostic {\n        file: SourceFile;\n        start: number;\n        length: number;\n    }\n    export enum DiagnosticCategory {\n        Warning = 0,\n        Error = 1,\n        Suggestion = 2,\n        Message = 3\n    }\n    export enum ModuleResolutionKind {\n        Classic = 1,\n        NodeJs = 2,\n        Node12 = 3,\n        NodeNext = 99\n    }\n    export interface PluginImport {\n        name: string;\n    }\n    export interface ProjectReference {\n        /** A normalized path on disk */\n        path: string;\n        /** The path as the user originally wrote it */\n        originalPath?: string;\n        /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */\n        prepend?: boolean;\n        /** True if it is intended that this reference form a circularity */\n        circular?: boolean;\n    }\n    export enum WatchFileKind {\n        FixedPollingInterval = 0,\n        PriorityPollingInterval = 1,\n        DynamicPriorityPolling = 2,\n        FixedChunkSizePolling = 3,\n        UseFsEvents = 4,\n        UseFsEventsOnParentDirectory = 5\n    }\n    export enum WatchDirectoryKind {\n        UseFsEvents = 0,\n        FixedPollingInterval = 1,\n        DynamicPriorityPolling = 2,\n        FixedChunkSizePolling = 3\n    }\n    export enum PollingWatchKind {\n        FixedInterval = 0,\n        PriorityInterval = 1,\n        DynamicPriority = 2,\n        FixedChunkSize = 3\n    }\n    export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;\n    export interface CompilerOptions {\n        allowJs?: boolean;\n        allowSyntheticDefaultImports?: boolean;\n        allowUmdGlobalAccess?: boolean;\n        allowUnreachableCode?: boolean;\n        allowUnusedLabels?: boolean;\n        alwaysStrict?: boolean;\n        baseUrl?: string;\n        charset?: string;\n        checkJs?: boolean;\n        declaration?: boolean;\n        declarationMap?: boolean;\n        emitDeclarationOnly?: boolean;\n        declarationDir?: string;\n        disableSizeLimit?: boolean;\n        disableSourceOfProjectReferenceRedirect?: boolean;\n        disableSolutionSearching?: boolean;\n        disableReferencedProjectLoad?: boolean;\n        downlevelIteration?: boolean;\n        emitBOM?: boolean;\n        emitDecoratorMetadata?: boolean;\n        exactOptionalPropertyTypes?: boolean;\n        experimentalDecorators?: boolean;\n        forceConsistentCasingInFileNames?: boolean;\n        importHelpers?: boolean;\n        importsNotUsedAsValues?: ImportsNotUsedAsValues;\n        inlineSourceMap?: boolean;\n        inlineSources?: boolean;\n        isolatedModules?: boolean;\n        jsx?: JsxEmit;\n        keyofStringsOnly?: boolean;\n        lib?: string[];\n        locale?: string;\n        mapRoot?: string;\n        maxNodeModuleJsDepth?: number;\n        module?: ModuleKind;\n        moduleResolution?: ModuleResolutionKind;\n        newLine?: NewLineKind;\n        noEmit?: boolean;\n        noEmitHelpers?: boolean;\n        noEmitOnError?: boolean;\n        noErrorTruncation?: boolean;\n        noFallthroughCasesInSwitch?: boolean;\n        noImplicitAny?: boolean;\n        noImplicitReturns?: boolean;\n        noImplicitThis?: boolean;\n        noStrictGenericChecks?: boolean;\n        noUnusedLocals?: boolean;\n        noUnusedParameters?: boolean;\n        noImplicitUseStrict?: boolean;\n        noPropertyAccessFromIndexSignature?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        noLib?: boolean;\n        noResolve?: boolean;\n        noUncheckedIndexedAccess?: boolean;\n        out?: string;\n        outDir?: string;\n        outFile?: string;\n        paths?: MapLike<string[]>;\n        preserveConstEnums?: boolean;\n        noImplicitOverride?: boolean;\n        preserveSymlinks?: boolean;\n        preserveValueImports?: boolean;\n        project?: string;\n        reactNamespace?: string;\n        jsxFactory?: string;\n        jsxFragmentFactory?: string;\n        jsxImportSource?: string;\n        composite?: boolean;\n        incremental?: boolean;\n        tsBuildInfoFile?: string;\n        removeComments?: boolean;\n        rootDir?: string;\n        rootDirs?: string[];\n        skipLibCheck?: boolean;\n        skipDefaultLibCheck?: boolean;\n        sourceMap?: boolean;\n        sourceRoot?: string;\n        strict?: boolean;\n        strictFunctionTypes?: boolean;\n        strictBindCallApply?: boolean;\n        strictNullChecks?: boolean;\n        strictPropertyInitialization?: boolean;\n        stripInternal?: boolean;\n        suppressExcessPropertyErrors?: boolean;\n        suppressImplicitAnyIndexErrors?: boolean;\n        target?: ScriptTarget;\n        traceResolution?: boolean;\n        useUnknownInCatchVariables?: boolean;\n        resolveJsonModule?: boolean;\n        types?: string[];\n        /** Paths used to compute primary types search locations */\n        typeRoots?: string[];\n        esModuleInterop?: boolean;\n        useDefineForClassFields?: boolean;\n        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;\n    }\n    export interface WatchOptions {\n        watchFile?: WatchFileKind;\n        watchDirectory?: WatchDirectoryKind;\n        fallbackPolling?: PollingWatchKind;\n        synchronousWatchDirectory?: boolean;\n        excludeDirectories?: string[];\n        excludeFiles?: string[];\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    export interface TypeAcquisition {\n        /**\n         * @deprecated typingOptions.enableAutoDiscovery\n         * Use typeAcquisition.enable instead.\n         */\n        enableAutoDiscovery?: boolean;\n        enable?: boolean;\n        include?: string[];\n        exclude?: string[];\n        disableFilenameBasedTypeAcquisition?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    export enum ModuleKind {\n        None = 0,\n        CommonJS = 1,\n        AMD = 2,\n        UMD = 3,\n        System = 4,\n        ES2015 = 5,\n        ES2020 = 6,\n        ES2022 = 7,\n        ESNext = 99,\n        Node12 = 100,\n        NodeNext = 199\n    }\n    export enum JsxEmit {\n        None = 0,\n        Preserve = 1,\n        React = 2,\n        ReactNative = 3,\n        ReactJSX = 4,\n        ReactJSXDev = 5\n    }\n    export enum ImportsNotUsedAsValues {\n        Remove = 0,\n        Preserve = 1,\n        Error = 2\n    }\n    export enum NewLineKind {\n        CarriageReturnLineFeed = 0,\n        LineFeed = 1\n    }\n    export interface LineAndCharacter {\n        /** 0-based. */\n        line: number;\n        character: number;\n    }\n    export enum ScriptKind {\n        Unknown = 0,\n        JS = 1,\n        JSX = 2,\n        TS = 3,\n        TSX = 4,\n        External = 5,\n        JSON = 6,\n        /**\n         * Used on extensions that doesn\'t define the ScriptKind but the content defines it.\n         * Deferred extensions are going to be included in all project contexts.\n         */\n        Deferred = 7\n    }\n    export enum ScriptTarget {\n        ES3 = 0,\n        ES5 = 1,\n        ES2015 = 2,\n        ES2016 = 3,\n        ES2017 = 4,\n        ES2018 = 5,\n        ES2019 = 6,\n        ES2020 = 7,\n        ES2021 = 8,\n        ES2022 = 9,\n        ESNext = 99,\n        JSON = 100,\n        Latest = 99\n    }\n    export enum LanguageVariant {\n        Standard = 0,\n        JSX = 1\n    }\n    /** Either a parsed command line or a parsed tsconfig.json */\n    export interface ParsedCommandLine {\n        options: CompilerOptions;\n        typeAcquisition?: TypeAcquisition;\n        fileNames: string[];\n        projectReferences?: readonly ProjectReference[];\n        watchOptions?: WatchOptions;\n        raw?: any;\n        errors: Diagnostic[];\n        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\n        compileOnSave?: boolean;\n    }\n    export enum WatchDirectoryFlags {\n        None = 0,\n        Recursive = 1\n    }\n    export interface CreateProgramOptions {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        oldProgram?: Program;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n    }\n    export interface ModuleResolutionHost {\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n        trace?(s: string): void;\n        directoryExists?(directoryName: string): boolean;\n        /**\n         * Resolve a symbolic link.\n         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options\n         */\n        realpath?(path: string): string;\n        getCurrentDirectory?(): string;\n        getDirectories?(path: string): string[];\n        useCaseSensitiveFileNames?: boolean | (() => boolean);\n    }\n    /**\n     * Represents the result of module resolution.\n     * Module resolution will pick up tsx/jsx/js files even if \'--jsx\' and \'--allowJs\' are turned off.\n     * The Program will then filter results based on these flags.\n     *\n     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.\n     */\n    export interface ResolvedModule {\n        /** Path of the file the module was resolved to. */\n        resolvedFileName: string;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n    }\n    /**\n     * ResolvedModule with an explicitly provided `extension` property.\n     * Prefer this over `ResolvedModule`.\n     * If changing this, remember to change `moduleResolutionIsEqualTo`.\n     */\n    export interface ResolvedModuleFull extends ResolvedModule {\n        /**\n         * Extension of resolvedFileName. This must match what\'s at the end of resolvedFileName.\n         * This is optional for backwards-compatibility, but will be added if not provided.\n         */\n        extension: Extension;\n        packageId?: PackageId;\n    }\n    /**\n     * Unique identifier with a package name and version.\n     * If changing this, remember to change `packageIdIsEqual`.\n     */\n    export interface PackageId {\n        /**\n         * Name of the package.\n         * Should not include `@types`.\n         * If accessing a non-index file, this should include its name e.g. "foo/bar".\n         */\n        name: string;\n        /**\n         * Name of a submodule within this package.\n         * May be "".\n         */\n        subModuleName: string;\n        /** Version of the package, e.g. "1.2.3" */\n        version: string;\n    }\n    export enum Extension {\n        Ts = ".ts",\n        Tsx = ".tsx",\n        Dts = ".d.ts",\n        Js = ".js",\n        Jsx = ".jsx",\n        Json = ".json",\n        TsBuildInfo = ".tsbuildinfo",\n        Mjs = ".mjs",\n        Mts = ".mts",\n        Dmts = ".d.mts",\n        Cjs = ".cjs",\n        Cts = ".cts",\n        Dcts = ".d.cts"\n    }\n    export interface ResolvedModuleWithFailedLookupLocations {\n        readonly resolvedModule: ResolvedModuleFull | undefined;\n    }\n    export interface ResolvedTypeReferenceDirective {\n        primary: boolean;\n        resolvedFileName: string | undefined;\n        packageId?: PackageId;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n    }\n    export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\n        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;\n        readonly failedLookupLocations: string[];\n    }\n    export interface CompilerHost extends ModuleResolutionHost {\n        getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getSourceFileByPath?(fileName: string, path: Path, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getCancellationToken?(): CancellationToken;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        writeFile: WriteFileCallback;\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        /**\n         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it\n         */\n        getModuleResolutionCache?(): ModuleResolutionCache | undefined;\n        /**\n         * This method is a companion for \'resolveModuleNames\' and is used to resolve \'types\' references to actual type declaration files\n         */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n        getEnvironmentVariable?(name: string): string | undefined;\n        createHash?(data: string): string;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n    }\n    export interface SourceMapRange extends TextRange {\n        source?: SourceMapSource;\n    }\n    export interface SourceMapSource {\n        fileName: string;\n        text: string;\n        skipTrivia?: (pos: number) => number;\n    }\n    export enum EmitFlags {\n        None = 0,\n        SingleLine = 1,\n        AdviseOnEmitNode = 2,\n        NoSubstitution = 4,\n        CapturesThis = 8,\n        NoLeadingSourceMap = 16,\n        NoTrailingSourceMap = 32,\n        NoSourceMap = 48,\n        NoNestedSourceMaps = 64,\n        NoTokenLeadingSourceMaps = 128,\n        NoTokenTrailingSourceMaps = 256,\n        NoTokenSourceMaps = 384,\n        NoLeadingComments = 512,\n        NoTrailingComments = 1024,\n        NoComments = 1536,\n        NoNestedComments = 2048,\n        HelperName = 4096,\n        ExportName = 8192,\n        LocalName = 16384,\n        InternalName = 32768,\n        Indented = 65536,\n        NoIndentation = 131072,\n        AsyncFunctionBody = 262144,\n        ReuseTempVariableScope = 524288,\n        CustomPrologue = 1048576,\n        NoHoisting = 2097152,\n        HasEndOfDeclarationMarker = 4194304,\n        Iterator = 8388608,\n        NoAsciiEscaping = 16777216,\n    }\n    export interface EmitHelperBase {\n        readonly name: string;\n        readonly scoped: boolean;\n        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);\n        readonly priority?: number;\n        readonly dependencies?: EmitHelper[];\n    }\n    export interface ScopedEmitHelper extends EmitHelperBase {\n        readonly scoped: true;\n    }\n    export interface UnscopedEmitHelper extends EmitHelperBase {\n        readonly scoped: false;\n        readonly text: string;\n    }\n    export type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;\n    export type EmitHelperUniqueNameCallback = (name: string) => string;\n    export enum EmitHint {\n        SourceFile = 0,\n        Expression = 1,\n        IdentifierName = 2,\n        MappedTypeParameter = 3,\n        Unspecified = 4,\n        EmbeddedStatement = 5,\n        JsxAttributeValue = 6\n    }\n    export enum OuterExpressionKinds {\n        Parentheses = 1,\n        TypeAssertions = 2,\n        NonNullAssertions = 4,\n        PartiallyEmittedExpressions = 8,\n        Assertions = 6,\n        All = 15,\n        ExcludeJSDocTypeAssertion = 16\n    }\n    export type TypeOfTag = "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";\n    export interface NodeFactory {\n        createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;\n        createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;\n        createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;\n        createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;\n        createStringLiteralFromNode(sourceNode: PropertyNameLiteral, isSingleQuote?: boolean): StringLiteral;\n        createRegularExpressionLiteral(text: string): RegularExpressionLiteral;\n        createIdentifier(text: string): Identifier;\n        /**\n         * Create a unique temporary variable.\n         * @param recordTempVariable An optional callback used to record the temporary variable name. This\n         * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but\n         * can be `undefined` if you plan to record the temporary variable manually.\n         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes\n         * during emit so that the variable can be referenced in a nested function body. This is an alternative to\n         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.\n         */\n        createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;\n        /**\n         * Create a unique temporary variable for use in a loop.\n         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes\n         * during emit so that the variable can be referenced in a nested function body. This is an alternative to\n         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.\n         */\n        createLoopVariable(reservedInNestedScopes?: boolean): Identifier;\n        /** Create a unique name based on the supplied text. */\n        createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;\n        /** Create a unique name generated for a node. */\n        getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;\n        createPrivateIdentifier(text: string): PrivateIdentifier;\n        createToken(token: SyntaxKind.SuperKeyword): SuperExpression;\n        createToken(token: SyntaxKind.ThisKeyword): ThisExpression;\n        createToken(token: SyntaxKind.NullKeyword): NullLiteral;\n        createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;\n        createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;\n        createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;\n        createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;\n        createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;\n        createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;\n        createToken<TKind extends SyntaxKind.Unknown | SyntaxKind.EndOfFileToken>(token: TKind): Token<TKind>;\n        createSuper(): SuperExpression;\n        createThis(): ThisExpression;\n        createNull(): NullLiteral;\n        createTrue(): TrueLiteral;\n        createFalse(): FalseLiteral;\n        createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;\n        createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;\n        createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;\n        updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;\n        createComputedPropertyName(expression: Expression): ComputedPropertyName;\n        updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;\n        createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;\n        updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;\n        createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;\n        updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;\n        createDecorator(expression: Expression): Decorator;\n        updateDecorator(node: Decorator, expression: Expression): Decorator;\n        createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;\n        updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;\n        createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n        updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n        createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;\n        updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;\n        createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n        updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n        createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n        updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n        createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n        updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n        createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n        updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n        createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;\n        updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;\n        createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;\n        updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;\n        createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n        updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n        createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;\n        updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;\n        createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;\n        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;\n        createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;\n        createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;\n        updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;\n        createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;\n        updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;\n        createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;\n        updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;\n        createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;\n        /** @deprecated */\n        createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;\n        updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;\n        /** @deprecated */\n        updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;\n        createTypeQueryNode(exprName: EntityName): TypeQueryNode;\n        updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName): TypeQueryNode;\n        createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;\n        updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;\n        createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;\n        updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;\n        createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;\n        updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;\n        createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;\n        updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;\n        createOptionalTypeNode(type: TypeNode): OptionalTypeNode;\n        updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;\n        createRestTypeNode(type: TypeNode): RestTypeNode;\n        updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;\n        createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;\n        updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;\n        createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;\n        updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;\n        createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n        updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n        createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;\n        updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;\n        createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;\n        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;\n        createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;\n        updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;\n        createThisTypeNode(): ThisTypeNode;\n        createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;\n        updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;\n        createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n        updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n        createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;\n        updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;\n        createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;\n        updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;\n        createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;\n        updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;\n        createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;\n        updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;\n        createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n        updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n        createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;\n        updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;\n        createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;\n        updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;\n        createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;\n        updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;\n        createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;\n        updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;\n        createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;\n        updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;\n        createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;\n        updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;\n        createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;\n        updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;\n        createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;\n        updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;\n        createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;\n        updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;\n        createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n        updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n        createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n        updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n        createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;\n        updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;\n        createParenthesizedExpression(expression: Expression): ParenthesizedExpression;\n        updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;\n        createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;\n        updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;\n        createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;\n        updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;\n        createDeleteExpression(expression: Expression): DeleteExpression;\n        updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;\n        createTypeOfExpression(expression: Expression): TypeOfExpression;\n        updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;\n        createVoidExpression(expression: Expression): VoidExpression;\n        updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;\n        createAwaitExpression(expression: Expression): AwaitExpression;\n        updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;\n        createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;\n        updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;\n        createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;\n        updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;\n        createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;\n        updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;\n        createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;\n        updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;\n        createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n        updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n        createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;\n        createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;\n        createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;\n        createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;\n        createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;\n        createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;\n        createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;\n        createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;\n        createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;\n        createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;\n        updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;\n        createSpreadElement(expression: Expression): SpreadElement;\n        updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;\n        createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n        updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n        createOmittedExpression(): OmittedExpression;\n        createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;\n        updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;\n        createAsExpression(expression: Expression, type: TypeNode): AsExpression;\n        updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;\n        createNonNullExpression(expression: Expression): NonNullExpression;\n        updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;\n        createNonNullChain(expression: Expression): NonNullChain;\n        updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;\n        createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;\n        updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;\n        createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n        updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n        createSemicolonClassElement(): SemicolonClassElement;\n        createBlock(statements: readonly Statement[], multiLine?: boolean): Block;\n        updateBlock(node: Block, statements: readonly Statement[]): Block;\n        createVariableStatement(modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;\n        updateVariableStatement(node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList): VariableStatement;\n        createEmptyStatement(): EmptyStatement;\n        createExpressionStatement(expression: Expression): ExpressionStatement;\n        updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;\n        createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;\n        updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;\n        createDoStatement(statement: Statement, expression: Expression): DoStatement;\n        updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;\n        createWhileStatement(expression: Expression, statement: Statement): WhileStatement;\n        updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;\n        createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n        updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n        createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n        updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n        createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n        updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n        createContinueStatement(label?: string | Identifier): ContinueStatement;\n        updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;\n        createBreakStatement(label?: string | Identifier): BreakStatement;\n        updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;\n        createReturnStatement(expression?: Expression): ReturnStatement;\n        updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;\n        createWithStatement(expression: Expression, statement: Statement): WithStatement;\n        updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;\n        createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n        updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n        createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;\n        updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;\n        createThrowStatement(expression: Expression): ThrowStatement;\n        updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;\n        createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n        updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n        createDebuggerStatement(): DebuggerStatement;\n        createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;\n        updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n        createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;\n        updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;\n        createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n        updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n        createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n        updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n        createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n        updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n        createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n        updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n        createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;\n        updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;\n        createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;\n        updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;\n        createModuleBlock(statements: readonly Statement[]): ModuleBlock;\n        updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;\n        createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n        updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n        createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;\n        updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;\n        createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n        createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;\n        updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;\n        createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;\n        updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;\n        createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;\n        updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;\n        createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;\n        updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;\n        createNamespaceImport(name: Identifier): NamespaceImport;\n        updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;\n        createNamespaceExport(name: Identifier): NamespaceExport;\n        updateNamespaceExport(node: NamespaceExport, name: Identifier): NamespaceExport;\n        createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;\n        updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;\n        createImportSpecifier(isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;\n        updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;\n        createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;\n        updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;\n        createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;\n        updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;\n        createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;\n        updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;\n        createExportSpecifier(isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier): ExportSpecifier;\n        updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ExportSpecifier;\n        createExternalModuleReference(expression: Expression): ExternalModuleReference;\n        updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;\n        createJSDocAllType(): JSDocAllType;\n        createJSDocUnknownType(): JSDocUnknownType;\n        createJSDocNonNullableType(type: TypeNode): JSDocNonNullableType;\n        updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;\n        createJSDocNullableType(type: TypeNode): JSDocNullableType;\n        updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;\n        createJSDocOptionalType(type: TypeNode): JSDocOptionalType;\n        updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;\n        createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;\n        updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;\n        createJSDocVariadicType(type: TypeNode): JSDocVariadicType;\n        updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;\n        createJSDocNamepathType(type: TypeNode): JSDocNamepathType;\n        updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;\n        createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;\n        updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;\n        createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;\n        updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;\n        createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;\n        updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;\n        createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;\n        updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;\n        createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;\n        updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;\n        createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;\n        updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;\n        createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;\n        updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;\n        createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;\n        updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;\n        createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;\n        updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;\n        createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;\n        updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;\n        createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;\n        updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;\n        createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;\n        updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;\n        createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;\n        updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;\n        createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;\n        updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;\n        createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;\n        updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;\n        createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;\n        updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;\n        createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;\n        updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;\n        createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;\n        updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;\n        createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;\n        updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;\n        createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;\n        updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;\n        createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;\n        updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;\n        createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;\n        updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;\n        createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;\n        updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;\n        createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;\n        updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;\n        createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;\n        updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;\n        createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;\n        updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;\n        createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;\n        updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;\n        createJSDocDeprecatedTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;\n        updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;\n        createJSDocOverrideTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;\n        updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;\n        createJSDocText(text: string): JSDocText;\n        updateJSDocText(node: JSDocText, text: string): JSDocText;\n        createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;\n        updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;\n        createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n        updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n        createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n        updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n        createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n        updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n        createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;\n        updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;\n        createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n        createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n        updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n        createJsxOpeningFragment(): JsxOpeningFragment;\n        createJsxJsxClosingFragment(): JsxClosingFragment;\n        updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n        createJsxAttribute(name: Identifier, initializer: StringLiteral | JsxExpression | undefined): JsxAttribute;\n        updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: StringLiteral | JsxExpression | undefined): JsxAttribute;\n        createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;\n        updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;\n        createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;\n        updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;\n        createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;\n        updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;\n        createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;\n        updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;\n        createDefaultClause(statements: readonly Statement[]): DefaultClause;\n        updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;\n        createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n        updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n        createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;\n        updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;\n        createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;\n        updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;\n        createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;\n        updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;\n        createSpreadAssignment(expression: Expression): SpreadAssignment;\n        updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;\n        createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;\n        updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;\n        createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;\n        updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;\n        createNotEmittedStatement(original: Node): NotEmittedStatement;\n        createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;\n        updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;\n        createCommaListExpression(elements: readonly Expression[]): CommaListExpression;\n        updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;\n        createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;\n        updateBundle(node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;\n        createComma(left: Expression, right: Expression): BinaryExpression;\n        createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;\n        createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;\n        createLogicalOr(left: Expression, right: Expression): BinaryExpression;\n        createLogicalAnd(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseOr(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseXor(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;\n        createStrictEquality(left: Expression, right: Expression): BinaryExpression;\n        createStrictInequality(left: Expression, right: Expression): BinaryExpression;\n        createEquality(left: Expression, right: Expression): BinaryExpression;\n        createInequality(left: Expression, right: Expression): BinaryExpression;\n        createLessThan(left: Expression, right: Expression): BinaryExpression;\n        createLessThanEquals(left: Expression, right: Expression): BinaryExpression;\n        createGreaterThan(left: Expression, right: Expression): BinaryExpression;\n        createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;\n        createLeftShift(left: Expression, right: Expression): BinaryExpression;\n        createRightShift(left: Expression, right: Expression): BinaryExpression;\n        createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;\n        createAdd(left: Expression, right: Expression): BinaryExpression;\n        createSubtract(left: Expression, right: Expression): BinaryExpression;\n        createMultiply(left: Expression, right: Expression): BinaryExpression;\n        createDivide(left: Expression, right: Expression): BinaryExpression;\n        createModulo(left: Expression, right: Expression): BinaryExpression;\n        createExponent(left: Expression, right: Expression): BinaryExpression;\n        createPrefixPlus(operand: Expression): PrefixUnaryExpression;\n        createPrefixMinus(operand: Expression): PrefixUnaryExpression;\n        createPrefixIncrement(operand: Expression): PrefixUnaryExpression;\n        createPrefixDecrement(operand: Expression): PrefixUnaryExpression;\n        createBitwiseNot(operand: Expression): PrefixUnaryExpression;\n        createLogicalNot(operand: Expression): PrefixUnaryExpression;\n        createPostfixIncrement(operand: Expression): PostfixUnaryExpression;\n        createPostfixDecrement(operand: Expression): PostfixUnaryExpression;\n        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;\n        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n        createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): CallExpression;\n        createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n        createVoidZero(): VoidExpression;\n        createExportDefault(expression: Expression): ExportAssignment;\n        createExternalModuleExport(exportName: Identifier): ExportDeclaration;\n        restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;\n    }\n    export interface CoreTransformationContext {\n        readonly factory: NodeFactory;\n        /** Gets the compiler options supplied to the transformer. */\n        getCompilerOptions(): CompilerOptions;\n        /** Starts a new lexical environment. */\n        startLexicalEnvironment(): void;\n        /** Suspends the current lexical environment, usually after visiting a parameter list. */\n        suspendLexicalEnvironment(): void;\n        /** Resumes a suspended lexical environment, usually before visiting a function body. */\n        resumeLexicalEnvironment(): void;\n        /** Ends a lexical environment, returning any declarations. */\n        endLexicalEnvironment(): Statement[] | undefined;\n        /** Hoists a function declaration to the containing scope. */\n        hoistFunctionDeclaration(node: FunctionDeclaration): void;\n        /** Hoists a variable declaration to the containing scope. */\n        hoistVariableDeclaration(node: Identifier): void;\n    }\n    export interface TransformationContext extends CoreTransformationContext {\n        /** Records a request for a non-scoped emit helper in the current context. */\n        requestEmitHelper(helper: EmitHelper): void;\n        /** Gets and resets the requested non-scoped emit helpers. */\n        readEmitHelpers(): EmitHelper[] | undefined;\n        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */\n        enableSubstitution(kind: SyntaxKind): void;\n        /** Determines whether expression substitutions are enabled for the provided node. */\n        isSubstitutionEnabled(node: Node): boolean;\n        /**\n         * Hook used by transformers to substitute expressions just before they\n         * are emitted by the pretty printer.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onSubstituteNode: (hint: EmitHint, node: Node) => Node;\n        /**\n         * Enables before/after emit notifications in the pretty printer for the provided\n         * SyntaxKind.\n         */\n        enableEmitNotification(kind: SyntaxKind): void;\n        /**\n         * Determines whether before/after emit notifications should be raised in the pretty\n         * printer when it emits a node.\n         */\n        isEmitNotificationEnabled(node: Node): boolean;\n        /**\n         * Hook used to allow transformers to capture state before or after\n         * the printer emits a node.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\n    }\n    export interface TransformationResult<T extends Node> {\n        /** Gets the transformed source files. */\n        transformed: T[];\n        /** Gets diagnostics for the transformation. */\n        diagnostics?: DiagnosticWithLocation[];\n        /**\n         * Gets a substitute for a node, if one is available; otherwise, returns the original node.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        substituteNode(hint: EmitHint, node: Node): Node;\n        /**\n         * Emits a node with possible notification.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node.\n         */\n        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\n        /**\n         * Indicates if a given node needs an emit notification\n         *\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node): boolean;\n        /**\n         * Clean up EmitNode entries on any parse-tree nodes.\n         */\n        dispose(): void;\n    }\n    /**\n     * A function that is used to initialize and return a `Transformer` callback, which in turn\n     * will be used to transform one or more nodes.\n     */\n    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;\n    /**\n     * A function that transforms a node.\n     */\n    export type Transformer<T extends Node> = (node: T) => T;\n    /**\n     * A function that accepts and possibly transforms a node.\n     */\n    export type Visitor = (node: Node) => VisitResult<Node>;\n    export interface NodeVisitor {\n        <T extends Node>(nodes: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;\n        <T extends Node>(nodes: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;\n    }\n    export interface NodesVisitor {\n        <T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;\n        <T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;\n    }\n    export type VisitResult<T extends Node> = T | T[] | undefined;\n    export interface Printer {\n        /**\n         * Print a node and its subtree as-is, without any emit transformations.\n         * @param hint A value indicating the purpose of a node. This is primarily used to\n         * distinguish between an `Identifier` used in an expression position, versus an\n         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\n         * should just pass `Unspecified`.\n         * @param node The node to print. The node and its subtree are printed as-is, without any\n         * emit transformations.\n         * @param sourceFile A source file that provides context for the node. The source text of\n         * the file is used to emit the original source content for literals and identifiers, while\n         * the identifiers of the source file are used when generating unique names to avoid\n         * collisions.\n         */\n        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;\n        /**\n         * Prints a list of nodes using the given format flags\n         */\n        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;\n        /**\n         * Prints a source file as-is, without any emit transformations.\n         */\n        printFile(sourceFile: SourceFile): string;\n        /**\n         * Prints a bundle of source files as-is, without any emit transformations.\n         */\n        printBundle(bundle: Bundle): string;\n    }\n    export interface PrintHandlers {\n        /**\n         * A hook used by the Printer when generating unique names to avoid collisions with\n         * globally defined names that exist outside of the current source file.\n         */\n        hasGlobalName?(name: string): boolean;\n        /**\n         * A hook used by the Printer to provide notifications prior to emitting a node. A\n         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and\n         * `node` values.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback that, when invoked, will emit the node.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   onEmitNode(hint, node, emitCallback) {\n         *     // set up or track state prior to emitting the node...\n         *     emitCallback(hint, node);\n         *     // restore state after emitting the node...\n         *   }\n         * });\n         * ```\n         */\n        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\n        /**\n         * A hook used to check if an emit notification is required for a node.\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node): boolean;\n        /**\n         * A hook used by the Printer to perform just-in-time substitution of a node. This is\n         * primarily used by node transformations that need to substitute one node for another,\n         * such as replacing `myExportedVar` with `exports.myExportedVar`.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   substituteNode(hint, node) {\n         *     // perform substitution if necessary...\n         *     return node;\n         *   }\n         * });\n         * ```\n         */\n        substituteNode?(hint: EmitHint, node: Node): Node;\n    }\n    export interface PrinterOptions {\n        removeComments?: boolean;\n        newLine?: NewLineKind;\n        omitTrailingSemicolon?: boolean;\n        noEmitHelpers?: boolean;\n    }\n    export interface GetEffectiveTypeRootsHost {\n        directoryExists?(directoryName: string): boolean;\n        getCurrentDirectory?(): string;\n    }\n    export interface TextSpan {\n        start: number;\n        length: number;\n    }\n    export interface TextChangeRange {\n        span: TextSpan;\n        newLength: number;\n    }\n    export interface SyntaxList extends Node {\n        kind: SyntaxKind.SyntaxList;\n        _children: Node[];\n    }\n    export enum ListFormat {\n        None = 0,\n        SingleLine = 0,\n        MultiLine = 1,\n        PreserveLines = 2,\n        LinesMask = 3,\n        NotDelimited = 0,\n        BarDelimited = 4,\n        AmpersandDelimited = 8,\n        CommaDelimited = 16,\n        AsteriskDelimited = 32,\n        DelimitersMask = 60,\n        AllowTrailingComma = 64,\n        Indented = 128,\n        SpaceBetweenBraces = 256,\n        SpaceBetweenSiblings = 512,\n        Braces = 1024,\n        Parenthesis = 2048,\n        AngleBrackets = 4096,\n        SquareBrackets = 8192,\n        BracketsMask = 15360,\n        OptionalIfUndefined = 16384,\n        OptionalIfEmpty = 32768,\n        Optional = 49152,\n        PreferNewLine = 65536,\n        NoTrailingNewLine = 131072,\n        NoInterveningComments = 262144,\n        NoSpaceIfEmpty = 524288,\n        SingleElement = 1048576,\n        SpaceAfterList = 2097152,\n        Modifiers = 262656,\n        HeritageClauses = 512,\n        SingleLineTypeLiteralMembers = 768,\n        MultiLineTypeLiteralMembers = 32897,\n        SingleLineTupleTypeElements = 528,\n        MultiLineTupleTypeElements = 657,\n        UnionTypeConstituents = 516,\n        IntersectionTypeConstituents = 520,\n        ObjectBindingPatternElements = 525136,\n        ArrayBindingPatternElements = 524880,\n        ObjectLiteralExpressionProperties = 526226,\n        ImportClauseEntries = 526226,\n        ArrayLiteralExpressionElements = 8914,\n        CommaListElements = 528,\n        CallExpressionArguments = 2576,\n        NewExpressionArguments = 18960,\n        TemplateExpressionSpans = 262144,\n        SingleLineBlockStatements = 768,\n        MultiLineBlockStatements = 129,\n        VariableDeclarationList = 528,\n        SingleLineFunctionBodyStatements = 768,\n        MultiLineFunctionBodyStatements = 1,\n        ClassHeritageClauses = 0,\n        ClassMembers = 129,\n        InterfaceMembers = 129,\n        EnumMembers = 145,\n        CaseBlockClauses = 129,\n        NamedImportsOrExportsElements = 525136,\n        JsxElementOrFragmentChildren = 262144,\n        JsxElementAttributes = 262656,\n        CaseOrDefaultClauseStatements = 163969,\n        HeritageClauseTypes = 528,\n        SourceFileStatements = 131073,\n        Decorators = 2146305,\n        TypeArguments = 53776,\n        TypeParameters = 53776,\n        Parameters = 2576,\n        IndexSignatureParameters = 8848,\n        JSDocComment = 33\n    }\n    export interface UserPreferences {\n        readonly disableSuggestions?: boolean;\n        readonly quotePreference?: "auto" | "double" | "single";\n        readonly includeCompletionsForModuleExports?: boolean;\n        readonly includeCompletionsForImportStatements?: boolean;\n        readonly includeCompletionsWithSnippetText?: boolean;\n        readonly includeAutomaticOptionalChainCompletions?: boolean;\n        readonly includeCompletionsWithInsertText?: boolean;\n        readonly includeCompletionsWithClassMemberSnippets?: boolean;\n        readonly allowIncompleteCompletions?: boolean;\n        readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";\n        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */\n        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";\n        readonly allowTextChangesInNewFiles?: boolean;\n        readonly providePrefixAndSuffixTextForRename?: boolean;\n        readonly includePackageJsonAutoImports?: "auto" | "on" | "off";\n        readonly provideRefactorNotApplicableReason?: boolean;\n        readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";\n    }\n    /** Represents a bigint literal value without requiring bigint support */\n    export interface PseudoBigInt {\n        negative: boolean;\n        base10Value: string;\n    }\n    export {};\n}\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;\ndeclare function clearTimeout(handle: any): void;\ndeclare namespace ts {\n    export enum FileWatcherEventKind {\n        Created = 0,\n        Changed = 1,\n        Deleted = 2\n    }\n    export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind) => void;\n    export type DirectoryWatcherCallback = (fileName: string) => void;\n    export interface System {\n        args: string[];\n        newLine: string;\n        useCaseSensitiveFileNames: boolean;\n        write(s: string): void;\n        writeOutputIsTTY?(): boolean;\n        getWidthOfTerminal?(): number;\n        readFile(path: string, encoding?: string): string | undefined;\n        getFileSize?(path: string): number;\n        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;\n        /**\n         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that\n         * use native OS file watching\n         */\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n        resolvePath(path: string): string;\n        fileExists(path: string): boolean;\n        directoryExists(path: string): boolean;\n        createDirectory(path: string): void;\n        getExecutingFilePath(): string;\n        getCurrentDirectory(): string;\n        getDirectories(path: string): string[];\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        getModifiedTime?(path: string): Date | undefined;\n        setModifiedTime?(path: string, time: Date): void;\n        deleteFile?(path: string): void;\n        /**\n         * A good implementation is node.js\' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)\n         */\n        createHash?(data: string): string;\n        /** This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`. */\n        createSHA256Hash?(data: string): string;\n        getMemoryUsage?(): number;\n        exit(exitCode?: number): void;\n        realpath?(path: string): string;\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        clearTimeout?(timeoutId: any): void;\n        clearScreen?(): void;\n        base64decode?(input: string): string;\n        base64encode?(input: string): string;\n    }\n    export interface FileWatcher {\n        close(): void;\n    }\n    export function getNodeMajorVersion(): number | undefined;\n    export let sys: System;\n    export {};\n}\ndeclare namespace ts {\n    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;\n    interface Scanner {\n        getStartPos(): number;\n        getToken(): SyntaxKind;\n        getTextPos(): number;\n        getTokenPos(): number;\n        getTokenText(): string;\n        getTokenValue(): string;\n        hasUnicodeEscape(): boolean;\n        hasExtendedUnicodeEscape(): boolean;\n        hasPrecedingLineBreak(): boolean;\n        isIdentifier(): boolean;\n        isReservedWord(): boolean;\n        isUnterminated(): boolean;\n        reScanGreaterToken(): SyntaxKind;\n        reScanSlashToken(): SyntaxKind;\n        reScanAsteriskEqualsToken(): SyntaxKind;\n        reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;\n        reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;\n        scanJsxIdentifier(): SyntaxKind;\n        scanJsxAttributeValue(): SyntaxKind;\n        reScanJsxAttributeValue(): SyntaxKind;\n        reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;\n        reScanLessThanToken(): SyntaxKind;\n        reScanHashToken(): SyntaxKind;\n        reScanQuestionToken(): SyntaxKind;\n        reScanInvalidIdentifier(): SyntaxKind;\n        scanJsxToken(): JsxTokenSyntaxKind;\n        scanJsDocToken(): JSDocSyntaxKind;\n        scan(): SyntaxKind;\n        getText(): string;\n        setText(text: string | undefined, start?: number, length?: number): void;\n        setOnError(onError: ErrorCallback | undefined): void;\n        setScriptTarget(scriptTarget: ScriptTarget): void;\n        setLanguageVariant(variant: LanguageVariant): void;\n        setTextPos(textPos: number): void;\n        lookAhead<T>(callback: () => T): T;\n        scanRange<T>(start: number, length: number, callback: () => T): T;\n        tryScan<T>(callback: () => T): T;\n    }\n    function tokenToString(t: SyntaxKind): string | undefined;\n    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;\n    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;\n    function isWhiteSpaceLike(ch: number): boolean;\n    /** Does not include line breaks. For that, see isWhiteSpaceLike. */\n    function isWhiteSpaceSingleLine(ch: number): boolean;\n    function isLineBreak(ch: number): boolean;\n    function couldStartTrivia(text: string, pos: number): boolean;\n    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;\n    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;\n    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    /** Optionally, get the shebang */\n    function getShebang(text: string): string | undefined;\n    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;\n    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;\n    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;\n}\ndeclare namespace ts {\n    function isExternalModuleNameRelative(moduleName: string): boolean;\n    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;\n    function getDefaultLibFileName(options: CompilerOptions): string;\n    function textSpanEnd(span: TextSpan): number;\n    function textSpanIsEmpty(span: TextSpan): boolean;\n    function textSpanContainsPosition(span: TextSpan, position: number): boolean;\n    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;\n    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;\n    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;\n    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function createTextSpan(start: number, length: number): TextSpan;\n    function createTextSpanFromBounds(start: number, end: number): TextSpan;\n    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;\n    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;\n    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;\n    let unchangedTextChangeRange: TextChangeRange;\n    /**\n     * Called to merge all the changes that occurred across several versions of a script snapshot\n     * into a single change.  i.e. if a user keeps making successive edits to a script we will\n     * have a text change from V1 to V2, V2 to V3, ..., Vn.\n     *\n     * This function will then merge those changes into a single change range valid between V1 and\n     * Vn.\n     */\n    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;\n    function getTypeParameterOwner(d: Declaration): Declaration | undefined;\n    type ParameterPropertyDeclaration = ParameterDeclaration & {\n        parent: ConstructorDeclaration;\n        name: Identifier;\n    };\n    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;\n    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;\n    function isEmptyBindingElement(node: BindingElement): boolean;\n    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;\n    function getCombinedModifierFlags(node: Declaration): ModifierFlags;\n    function getCombinedNodeFlags(node: Node): NodeFlags;\n    /**\n     * Checks to see if the locale is in the appropriate format,\n     * and if it is, attempts to set the appropriate language.\n     */\n    function validateLocaleAndSetLanguage(locale: string, sys: {\n        getExecutingFilePath(): string;\n        resolvePath(path: string): string;\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n    }, errors?: Push<Diagnostic>): void;\n    function getOriginalNode(node: Node): Node;\n    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;\n    function getOriginalNode(node: Node | undefined): Node | undefined;\n    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;\n    /**\n     * Iterates through the parent chain of a node and performs the callback on each parent until the callback\n     * returns a truthy value, then returns that value.\n     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"\n     * At that point findAncestor returns undefined.\n     */\n    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;\n    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;\n    /**\n     * Gets a value indicating whether a node originated in the parse tree.\n     *\n     * @param node The node to test.\n     */\n    function isParseTreeNode(node: Node): boolean;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode(node: Node | undefined): Node | undefined;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;\n    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like \'__proto__\' */\n    function escapeLeadingUnderscores(identifier: string): __String;\n    /**\n     * Remove extra underscore from escaped identifier text content.\n     *\n     * @param identifier The escaped identifier text.\n     * @returns The unescaped identifier text.\n     */\n    function unescapeLeadingUnderscores(identifier: __String): string;\n    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;\n    function symbolName(symbol: Symbol): string;\n    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;\n    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;\n    /**\n     * Gets the JSDoc parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc param tag whose name matches the provided\n     * parameter, whether a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the param\n     * tag on the containing function expression would be first.\n     *\n     * For binding patterns, parameter tags are matched by position.\n     */\n    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];\n    /**\n     * Gets the JSDoc type parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc template tag whose names match the provided\n     * parameter, whether a template tag on a containing function\n     * expression, or a template tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the template\n     * tag on the containing function expression would be first.\n     */\n    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];\n    /**\n     * Return true if the node has JSDoc parameter tags.\n     *\n     * @remarks Includes parameter tags that are not directly on the node,\n     * for example on a variable declaration whose initializer is a function expression.\n     */\n    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;\n    /** Gets the JSDoc augments tag for the node if present */\n    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;\n    /** Gets the JSDoc implements tags for the node if present */\n    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];\n    /** Gets the JSDoc class tag for the node if present */\n    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;\n    /** Gets the JSDoc public tag for the node if present */\n    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;\n    /** Gets the JSDoc private tag for the node if present */\n    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;\n    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;\n    /** Gets the JSDoc deprecated tag for the node if present */\n    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;\n    /** Gets the JSDoc enum tag for the node if present */\n    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;\n    /** Gets the JSDoc this tag for the node if present */\n    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;\n    /** Gets the JSDoc return tag for the node if present */\n    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;\n    /** Gets the JSDoc template tag for the node if present */\n    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;\n    /** Gets the JSDoc type tag for the node if present and valid */\n    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;\n    /**\n     * Gets the type node for the node if provided via JSDoc.\n     *\n     * @remarks The search includes any JSDoc param tag that relates\n     * to the provided parameter, for example a type tag on the\n     * parameter itself, or a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are examined first, so in the previous example, the type\n     * tag directly on the node would be returned.\n     */\n    function getJSDocType(node: Node): TypeNode | undefined;\n    /**\n     * Gets the return type node for the node if provided via JSDoc return tag or type tag.\n     *\n     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function\n     * gets the type from inside the braces, after the fat arrow, etc.\n     */\n    function getJSDocReturnType(node: Node): TypeNode | undefined;\n    /** Get all JSDoc tags related to a node, including those on parent nodes. */\n    function getJSDocTags(node: Node): readonly JSDocTag[];\n    /** Gets all JSDoc tags that match a specified predicate */\n    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];\n    /** Gets all JSDoc tags of a specified kind */\n    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];\n    /** Gets the text of a jsdoc comment, flattening links to their text. */\n    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;\n    /**\n     * Gets the effective type parameters. If the node was parsed in a\n     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.\n     */\n    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];\n    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;\n    function isMemberName(node: Node): node is MemberName;\n    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;\n    function isElementAccessChain(node: Node): node is ElementAccessChain;\n    function isCallChain(node: Node): node is CallChain;\n    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    function isNullishCoalesce(node: Node): boolean;\n    function isConstTypeReference(node: Node): boolean;\n    function skipPartiallyEmittedExpressions(node: Expression): Expression;\n    function skipPartiallyEmittedExpressions(node: Node): Node;\n    function isNonNullChain(node: Node): node is NonNullChain;\n    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;\n    function isNamedExportBindings(node: Node): node is NamedExportBindings;\n    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;\n    function isUnparsedNode(node: Node): node is UnparsedNode;\n    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;\n    /**\n     * True if kind is of some token syntax kind.\n     * For example, this is true for an IfKeyword but not for an IfStatement.\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\n     */\n    function isTokenKind(kind: SyntaxKind): boolean;\n    /**\n     * True if node is of some token syntax kind.\n     * For example, this is true for an IfKeyword but not for an IfStatement.\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\n     */\n    function isToken(n: Node): boolean;\n    function isLiteralExpression(node: Node): node is LiteralExpression;\n    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;\n    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;\n    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;\n    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;\n    function isAssertionKey(node: Node): node is AssertionKey;\n    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;\n    function isModifier(node: Node): node is Modifier;\n    function isEntityName(node: Node): node is EntityName;\n    function isPropertyName(node: Node): node is PropertyName;\n    function isBindingName(node: Node): node is BindingName;\n    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;\n    function isClassElement(node: Node): node is ClassElement;\n    function isClassLike(node: Node): node is ClassLikeDeclaration;\n    function isAccessor(node: Node): node is AccessorDeclaration;\n    function isTypeElement(node: Node): node is TypeElement;\n    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;\n    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;\n    /**\n     * Node test that determines whether a node is a valid type node.\n     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*\n     * of a TypeNode.\n     */\n    function isTypeNode(node: Node): node is TypeNode;\n    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;\n    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;\n    function isCallLikeExpression(node: Node): node is CallLikeExpression;\n    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;\n    function isTemplateLiteral(node: Node): node is TemplateLiteral;\n    function isAssertionExpression(node: Node): node is AssertionExpression;\n    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;\n    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;\n    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;\n    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;\n    /** True if node is of a kind that may contain comment text. */\n    function isJSDocCommentContainingNode(node: Node): boolean;\n    function isSetAccessor(node: Node): node is SetAccessorDeclaration;\n    function isGetAccessor(node: Node): node is GetAccessorDeclaration;\n    /** True if has initializer node attached to it. */\n    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;\n    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;\n    function isStringLiteralLike(node: Node): node is StringLiteralLike;\n    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;\n}\ndeclare namespace ts {\n    const factory: NodeFactory;\n    function createUnparsedSourceFile(text: string): UnparsedSource;\n    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;\n    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;\n    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;\n    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;\n    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;\n    /**\n     * Create an external source map source file reference\n     */\n    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;\n    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;\n}\ndeclare namespace ts {\n    /**\n     * Clears any `EmitNode` entries from parse-tree nodes.\n     * @param sourceFile A source file.\n     */\n    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;\n    /**\n     * Sets flags that control emit behavior of a node.\n     */\n    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;\n    /**\n     * Gets a custom text range to use when emitting source maps.\n     */\n    function getSourceMapRange(node: Node): SourceMapRange;\n    /**\n     * Sets a custom text range to use when emitting source maps.\n     */\n    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;\n    /**\n     * Gets the TextRange to use for source maps for a token of a node.\n     */\n    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;\n    /**\n     * Sets the TextRange to use for source maps for a token of a node.\n     */\n    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;\n    /**\n     * Gets a custom text range to use when emitting comments.\n     */\n    function getCommentRange(node: Node): TextRange;\n    /**\n     * Sets a custom text range to use when emitting comments.\n     */\n    function setCommentRange<T extends Node>(node: T, range: TextRange): T;\n    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;\n    /**\n     * Gets the constant value to emit for an expression representing an enum.\n     */\n    function getConstantValue(node: AccessExpression): string | number | undefined;\n    /**\n     * Sets the constant value to emit for an expression.\n     */\n    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;\n    /**\n     * Adds an EmitHelper to a node.\n     */\n    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;\n    /**\n     * Add EmitHelpers to a node.\n     */\n    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;\n    /**\n     * Removes an EmitHelper from a node.\n     */\n    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;\n    /**\n     * Gets the EmitHelpers of a node.\n     */\n    function getEmitHelpers(node: Node): EmitHelper[] | undefined;\n    /**\n     * Moves matching emit helpers from a source node to a target node.\n     */\n    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;\n}\ndeclare namespace ts {\n    function isNumericLiteral(node: Node): node is NumericLiteral;\n    function isBigIntLiteral(node: Node): node is BigIntLiteral;\n    function isStringLiteral(node: Node): node is StringLiteral;\n    function isJsxText(node: Node): node is JsxText;\n    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;\n    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;\n    function isTemplateHead(node: Node): node is TemplateHead;\n    function isTemplateMiddle(node: Node): node is TemplateMiddle;\n    function isTemplateTail(node: Node): node is TemplateTail;\n    function isDotDotDotToken(node: Node): node is DotDotDotToken;\n    function isPlusToken(node: Node): node is PlusToken;\n    function isMinusToken(node: Node): node is MinusToken;\n    function isAsteriskToken(node: Node): node is AsteriskToken;\n    function isIdentifier(node: Node): node is Identifier;\n    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;\n    function isQualifiedName(node: Node): node is QualifiedName;\n    function isComputedPropertyName(node: Node): node is ComputedPropertyName;\n    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;\n    function isParameter(node: Node): node is ParameterDeclaration;\n    function isDecorator(node: Node): node is Decorator;\n    function isPropertySignature(node: Node): node is PropertySignature;\n    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;\n    function isMethodSignature(node: Node): node is MethodSignature;\n    function isMethodDeclaration(node: Node): node is MethodDeclaration;\n    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;\n    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;\n    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;\n    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;\n    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;\n    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;\n    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;\n    function isTypePredicateNode(node: Node): node is TypePredicateNode;\n    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;\n    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;\n    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;\n    function isTypeQueryNode(node: Node): node is TypeQueryNode;\n    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;\n    function isArrayTypeNode(node: Node): node is ArrayTypeNode;\n    function isTupleTypeNode(node: Node): node is TupleTypeNode;\n    function isNamedTupleMember(node: Node): node is NamedTupleMember;\n    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;\n    function isRestTypeNode(node: Node): node is RestTypeNode;\n    function isUnionTypeNode(node: Node): node is UnionTypeNode;\n    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;\n    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;\n    function isInferTypeNode(node: Node): node is InferTypeNode;\n    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;\n    function isThisTypeNode(node: Node): node is ThisTypeNode;\n    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;\n    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;\n    function isMappedTypeNode(node: Node): node is MappedTypeNode;\n    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;\n    function isImportTypeNode(node: Node): node is ImportTypeNode;\n    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;\n    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;\n    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;\n    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;\n    function isBindingElement(node: Node): node is BindingElement;\n    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;\n    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;\n    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;\n    function isElementAccessExpression(node: Node): node is ElementAccessExpression;\n    function isCallExpression(node: Node): node is CallExpression;\n    function isNewExpression(node: Node): node is NewExpression;\n    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;\n    function isTypeAssertionExpression(node: Node): node is TypeAssertion;\n    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;\n    function isFunctionExpression(node: Node): node is FunctionExpression;\n    function isArrowFunction(node: Node): node is ArrowFunction;\n    function isDeleteExpression(node: Node): node is DeleteExpression;\n    function isTypeOfExpression(node: Node): node is TypeOfExpression;\n    function isVoidExpression(node: Node): node is VoidExpression;\n    function isAwaitExpression(node: Node): node is AwaitExpression;\n    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;\n    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;\n    function isBinaryExpression(node: Node): node is BinaryExpression;\n    function isConditionalExpression(node: Node): node is ConditionalExpression;\n    function isTemplateExpression(node: Node): node is TemplateExpression;\n    function isYieldExpression(node: Node): node is YieldExpression;\n    function isSpreadElement(node: Node): node is SpreadElement;\n    function isClassExpression(node: Node): node is ClassExpression;\n    function isOmittedExpression(node: Node): node is OmittedExpression;\n    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;\n    function isAsExpression(node: Node): node is AsExpression;\n    function isNonNullExpression(node: Node): node is NonNullExpression;\n    function isMetaProperty(node: Node): node is MetaProperty;\n    function isSyntheticExpression(node: Node): node is SyntheticExpression;\n    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;\n    function isCommaListExpression(node: Node): node is CommaListExpression;\n    function isTemplateSpan(node: Node): node is TemplateSpan;\n    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;\n    function isBlock(node: Node): node is Block;\n    function isVariableStatement(node: Node): node is VariableStatement;\n    function isEmptyStatement(node: Node): node is EmptyStatement;\n    function isExpressionStatement(node: Node): node is ExpressionStatement;\n    function isIfStatement(node: Node): node is IfStatement;\n    function isDoStatement(node: Node): node is DoStatement;\n    function isWhileStatement(node: Node): node is WhileStatement;\n    function isForStatement(node: Node): node is ForStatement;\n    function isForInStatement(node: Node): node is ForInStatement;\n    function isForOfStatement(node: Node): node is ForOfStatement;\n    function isContinueStatement(node: Node): node is ContinueStatement;\n    function isBreakStatement(node: Node): node is BreakStatement;\n    function isReturnStatement(node: Node): node is ReturnStatement;\n    function isWithStatement(node: Node): node is WithStatement;\n    function isSwitchStatement(node: Node): node is SwitchStatement;\n    function isLabeledStatement(node: Node): node is LabeledStatement;\n    function isThrowStatement(node: Node): node is ThrowStatement;\n    function isTryStatement(node: Node): node is TryStatement;\n    function isDebuggerStatement(node: Node): node is DebuggerStatement;\n    function isVariableDeclaration(node: Node): node is VariableDeclaration;\n    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;\n    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;\n    function isClassDeclaration(node: Node): node is ClassDeclaration;\n    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;\n    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;\n    function isEnumDeclaration(node: Node): node is EnumDeclaration;\n    function isModuleDeclaration(node: Node): node is ModuleDeclaration;\n    function isModuleBlock(node: Node): node is ModuleBlock;\n    function isCaseBlock(node: Node): node is CaseBlock;\n    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;\n    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;\n    function isImportDeclaration(node: Node): node is ImportDeclaration;\n    function isImportClause(node: Node): node is ImportClause;\n    function isAssertClause(node: Node): node is AssertClause;\n    function isAssertEntry(node: Node): node is AssertEntry;\n    function isNamespaceImport(node: Node): node is NamespaceImport;\n    function isNamespaceExport(node: Node): node is NamespaceExport;\n    function isNamedImports(node: Node): node is NamedImports;\n    function isImportSpecifier(node: Node): node is ImportSpecifier;\n    function isExportAssignment(node: Node): node is ExportAssignment;\n    function isExportDeclaration(node: Node): node is ExportDeclaration;\n    function isNamedExports(node: Node): node is NamedExports;\n    function isExportSpecifier(node: Node): node is ExportSpecifier;\n    function isMissingDeclaration(node: Node): node is MissingDeclaration;\n    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;\n    function isExternalModuleReference(node: Node): node is ExternalModuleReference;\n    function isJsxElement(node: Node): node is JsxElement;\n    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;\n    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;\n    function isJsxClosingElement(node: Node): node is JsxClosingElement;\n    function isJsxFragment(node: Node): node is JsxFragment;\n    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;\n    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;\n    function isJsxAttribute(node: Node): node is JsxAttribute;\n    function isJsxAttributes(node: Node): node is JsxAttributes;\n    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;\n    function isJsxExpression(node: Node): node is JsxExpression;\n    function isCaseClause(node: Node): node is CaseClause;\n    function isDefaultClause(node: Node): node is DefaultClause;\n    function isHeritageClause(node: Node): node is HeritageClause;\n    function isCatchClause(node: Node): node is CatchClause;\n    function isPropertyAssignment(node: Node): node is PropertyAssignment;\n    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;\n    function isSpreadAssignment(node: Node): node is SpreadAssignment;\n    function isEnumMember(node: Node): node is EnumMember;\n    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;\n    function isSourceFile(node: Node): node is SourceFile;\n    function isBundle(node: Node): node is Bundle;\n    function isUnparsedSource(node: Node): node is UnparsedSource;\n    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;\n    function isJSDocNameReference(node: Node): node is JSDocNameReference;\n    function isJSDocMemberName(node: Node): node is JSDocMemberName;\n    function isJSDocLink(node: Node): node is JSDocLink;\n    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;\n    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;\n    function isJSDocAllType(node: Node): node is JSDocAllType;\n    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;\n    function isJSDocNullableType(node: Node): node is JSDocNullableType;\n    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;\n    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;\n    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;\n    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;\n    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;\n    function isJSDoc(node: Node): node is JSDoc;\n    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;\n    function isJSDocSignature(node: Node): node is JSDocSignature;\n    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;\n    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;\n    function isJSDocClassTag(node: Node): node is JSDocClassTag;\n    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;\n    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;\n    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;\n    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;\n    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;\n    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;\n    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;\n    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;\n    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;\n    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;\n    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;\n    function isJSDocThisTag(node: Node): node is JSDocThisTag;\n    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;\n    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;\n    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;\n    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;\n    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;\n    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;\n}\ndeclare namespace ts {\n    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;\n}\ndeclare namespace ts {\n    /**\n     * Invokes a callback for each child of the given node. The \'cbNode\' callback is invoked for all child nodes\n     * stored in properties. If a \'cbNodes\' callback is specified, it is invoked for embedded arrays; otherwise,\n     * embedded arrays are flattened and the \'cbNode\' callback is invoked for each element. If a callback returns\n     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\n     *\n     * @param node a given node to visit its children\n     * @param cbNode a callback to be invoked for all child nodes\n     * @param cbNodes a callback to be invoked for embedded array\n     *\n     * @remarks `forEachChild` must visit the children of a node in the order\n     * that they appear in the source code. The language service depends on this property to locate nodes by position.\n     */\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    export function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;\n    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;\n    /**\n     * Parse json text into SyntaxTree and return node and parse errors if any\n     * @param fileName\n     * @param sourceText\n     */\n    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;\n    export function isExternalModule(file: SourceFile): boolean;\n    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;\n    export {};\n}\ndeclare namespace ts {\n    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;\n    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;\n    /**\n     * Reports config file diagnostics\n     */\n    export interface ConfigFileDiagnosticsReporter {\n        /**\n         * Reports unrecoverable error when parsing config file\n         */\n        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;\n    }\n    /**\n     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors\n     */\n    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {\n        getCurrentDirectory(): string;\n    }\n    /**\n     * Reads the config file, reports errors if any and exits if the config file cannot be found\n     */\n    export function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    export function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Parse the text of the tsconfig.json file\n     * @param fileName The path to the config file\n     * @param jsonText The text of the config file\n     */\n    export function parseConfigFileTextToJson(fileName: string, jsonText: string): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    export function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;\n    /**\n     * Convert the json syntax tree into the json value\n     */\n    export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnostic>): any;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param json The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    export function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param jsonNode The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    export interface ParsedTsconfig {\n        raw: any;\n        options?: CompilerOptions;\n        watchOptions?: WatchOptions;\n        typeAcquisition?: TypeAcquisition;\n        /**\n         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet\n         */\n        extendedConfigPath?: string;\n    }\n    export interface ExtendedConfigCacheEntry {\n        extendedResult: TsConfigSourceFile;\n        extendedConfig: ParsedTsconfig | undefined;\n    }\n    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: CompilerOptions;\n        errors: Diagnostic[];\n    };\n    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: TypeAcquisition;\n        errors: Diagnostic[];\n    };\n    export {};\n}\ndeclare namespace ts {\n    export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;\n    /**\n     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n     * This is possible in case if resolution is performed for directives specified via \'types\' parameter. In this case initial path for secondary lookups\n     * is assumed to be the same as root directory of the project.\n     */\n    export function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;\n    /**\n     * Given a set of options, returns the set of type directive names\n     *   that should be included for this program automatically.\n     * This list could either come from the config file,\n     *   or from enumerating the types root + initial secondary types lookup location.\n     * More type directives might appear in the program later as a result of loading actual source files;\n     *   this list is only the set of defaults that are implicitly included.\n     */\n    export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];\n    export interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {\n    }\n    export interface ModeAwareCache<T> {\n        get(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): T | undefined;\n        set(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined, value: T): this;\n        delete(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): this;\n        has(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): boolean;\n        forEach(cb: (elem: T, key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined) => void): void;\n        size(): number;\n    }\n    /**\n     * Cached resolutions per containing directory.\n     * This assumes that any module id will have the same resolution for sibling files located in the same folder.\n     */\n    export interface PerDirectoryResolutionCache<T> {\n        getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;\n        clear(): void;\n        /**\n         *  Updates with the current compilerOptions the cache will operate with.\n         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects\n         */\n        update(options: CompilerOptions): void;\n    }\n    export interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {\n        getPackageJsonInfoCache(): PackageJsonInfoCache;\n    }\n    /**\n     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory\n     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.\n     */\n    export interface NonRelativeModuleNameResolutionCache extends PackageJsonInfoCache {\n        getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;\n    }\n    export interface PackageJsonInfoCache {\n        clear(): void;\n    }\n    export interface PerModuleNameCache {\n        get(directory: string): ResolvedModuleWithFailedLookupLocations | undefined;\n        set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;\n    }\n    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;\n    export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;\n    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;\n    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;\n    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    export {};\n}\ndeclare namespace ts {\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;\n    /**\n     * Starts a new lexical environment and visits a statement list, ending the lexical environment\n     * and merging hoisted declarations upon completion.\n     */\n    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;\n    /**\n     * Starts a new lexical environment and visits a parameter list, suspending the lexical\n     * environment upon completion.\n     */\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a concise body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;\n    /**\n     * Visits an iteration body, adding any block-scoped variables required by the transformation.\n     */\n    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;\n}\ndeclare namespace ts {\n    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;\n    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];\n    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;\n}\ndeclare namespace ts {\n    export function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;\n    export function resolveTripleslashReference(moduleName: string, containingFile: string): string;\n    export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;\n    export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n    export interface FormatDiagnosticsHost {\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        getNewLine(): string;\n    }\n    export function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    export function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;\n    export function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    export function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;\n    export function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];\n    /**\n     * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the\n     * `options` parameter.\n     *\n     * @param fileName The normalized absolute path to check the format of (it need not exist on disk)\n     * @param [packageJsonInfoCache] A cache for package file lookups - it\'s best to have a cache when this function is called often\n     * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data\n     * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`\n     * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format\n     */\n    export function getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ModuleKind.ESNext | ModuleKind.CommonJS | undefined;\n    /**\n     * Create a new \'Program\' instance. A Program is an immutable collection of \'SourceFile\'s and a \'CompilerOptions\'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. \'@types\' and triple-slash-reference-types are also pulled in.\n     *\n     * @param createProgramOptions - The options for creating a program.\n     * @returns A \'Program\' object.\n     */\n    export function createProgram(createProgramOptions: CreateProgramOptions): Program;\n    /**\n     * Create a new \'Program\' instance. A Program is an immutable collection of \'SourceFile\'s and a \'CompilerOptions\'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. \'@types\' and triple-slash-reference-types are also pulled in.\n     *\n     * @param rootNames - A set of root files.\n     * @param options - The compiler options which should be used.\n     * @param host - The host interacts with the underlying file system.\n     * @param oldProgram - Reuses an old program structure.\n     * @param configFileParsingDiagnostics - error during config file parsing\n     * @returns A \'Program\' object.\n     */\n    export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;\n    /** @deprecated */ export interface ResolveProjectReferencePathHost {\n        fileExists(fileName: string): boolean;\n    }\n    /**\n     * Returns the target config filename of a project reference.\n     * Note: The file might not exist.\n     */\n    export function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;\n    /** @deprecated */ export function resolveProjectReferencePath(host: ResolveProjectReferencePathHost, ref: ProjectReference): ResolvedConfigFileName;\n    export {};\n}\ndeclare namespace ts {\n    interface EmitOutput {\n        outputFiles: OutputFile[];\n        emitSkipped: boolean;\n    }\n    interface OutputFile {\n        name: string;\n        writeByteOrderMark: boolean;\n        text: string;\n    }\n}\ndeclare namespace ts {\n    type AffectedFileResult<T> = {\n        result: T;\n        affected: SourceFile | Program;\n    } | undefined;\n    interface BuilderProgramHost {\n        /**\n         * return true if file names are treated with case sensitivity\n         */\n        useCaseSensitiveFileNames(): boolean;\n        /**\n         * If provided this would be used this hash instead of actual file shape text for detecting changes\n         */\n        createHash?: (data: string) => string;\n        /**\n         * When emit or emitNextAffectedFile are called without writeFile,\n         * this callback if present would be used to write files\n         */\n        writeFile?: WriteFileCallback;\n    }\n    /**\n     * Builder to manage the program state changes\n     */\n    interface BuilderProgram {\n        /**\n         * Returns current program\n         */\n        getProgram(): Program;\n        /**\n         * Get compiler options of the program\n         */\n        getCompilerOptions(): CompilerOptions;\n        /**\n         * Get the source file in the program with file name\n         */\n        getSourceFile(fileName: string): SourceFile | undefined;\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Get the diagnostics for compiler options\n         */\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics that dont belong to any file\n         */\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics from config file parsing\n         */\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Get the syntax diagnostics, for all source files if source file is not supplied\n         */\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the declaration diagnostics, for all source files if source file is not supplied\n         */\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /**\n         * Get all the dependencies of the file\n         */\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        /**\n         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program\n         * The semantic diagnostics are cached and managed here\n         * Note that it is assumed that when asked about semantic diagnostics through this API,\n         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics\n         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,\n         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics\n         */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Emits the JavaScript and declaration files.\n         * When targetSource file is specified, emits the files corresponding to that source file,\n         * otherwise for the whole program.\n         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,\n         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,\n         * it will only emit all the affected files instead of whole program\n         *\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        /**\n         * Get the current directory of the program\n         */\n        getCurrentDirectory(): string;\n    }\n    /**\n     * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files\n     */\n    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {\n        /**\n         * Gets the semantic diagnostics from the program for the next affected file and caches it\n         * Returns undefined if the iteration is complete\n         */\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n    }\n    /**\n     * The builder that can handle the changes in program and iterate through changed file to emit the files\n     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files\n     */\n    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {\n        /**\n         * Emits the next affected file\'s emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;\n    }\n    /**\n     * Create the builder to manage semantic diagnostics and cache them\n     */\n    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;\n    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;\n    /**\n     * Create the builder that can handle the changes in program and iterate through changed files\n     * to emit the those files and manage semantic diagnostics cache as well\n     */\n    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    /**\n     * Creates a builder thats just abstraction over program and can be used with watch\n     */\n    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;\n    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;\n}\ndeclare namespace ts {\n    interface ReadBuildProgramHost {\n        useCaseSensitiveFileNames(): boolean;\n        getCurrentDirectory(): string;\n        readFile(fileName: string): string | undefined;\n    }\n    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;\n    function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;\n    interface IncrementalProgramOptions<T extends BuilderProgram> {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        createProgram?: CreateProgram<T>;\n    }\n    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;\n    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;\n    /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */\n    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;\n    /** Host that has watch functionality used in --watch mode */\n    interface WatchHost {\n        /** If provided, called with Diagnostic message that informs about change in watch status */\n        onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;\n        /** Used to watch changes in source files, missing files needed to update the program or config file */\n        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: CompilerOptions): FileWatcher;\n        /** Used to watch resolved module\'s failed lookup locations, config file specs, type roots where auto type reference directives are added */\n        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: CompilerOptions): FileWatcher;\n        /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        /** If provided, will be used to reset existing delayed compilation */\n        clearTimeout?(timeoutId: any): void;\n    }\n    interface ProgramHost<T extends BuilderProgram> {\n        /**\n         * Used to create the program when need for program creation or recreation detected\n         */\n        createProgram: CreateProgram<T>;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        createHash?(data: string): string;\n        /**\n         * Use to check file presence for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        fileExists(path: string): boolean;\n        /**\n         * Use to read file text for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        readFile(path: string, encoding?: string): string | undefined;\n        /** If provided, used for module resolution as well as to handle directory structure */\n        directoryExists?(path: string): boolean;\n        /** If provided, used in resolutions as well as handling directory structure */\n        getDirectories?(path: string): string[];\n        /** If provided, used to cache and handle directory structure modifications */\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        /** Symbol links resolution */\n        realpath?(path: string): string;\n        /** If provided would be used to write log about compilation */\n        trace?(s: string): void;\n        /** If provided is used to get the environment variable */\n        getEnvironmentVariable?(name: string): string | undefined;\n        /** If provided, used to resolve the module names, otherwise typescript\'s default module resolution */\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        /** If provided, used to resolve type reference directives, otherwise typescript\'s default resolution */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n    }\n    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {\n        /** Instead of using output d.ts file from project reference, use its source file */\n        useSourceOfProjectReferenceRedirect?(): boolean;\n        /** If provided, use this method to get parsed command lines for referenced projects */\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        /** If provided, callback to invoke after every new program creation */\n        afterProgramCreate?(program: T): void;\n    }\n    /**\n     * Host to create watch with root files and options\n     */\n    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {\n        /** root files to use to generate program */\n        rootFiles: string[];\n        /** Compiler options */\n        options: CompilerOptions;\n        watchOptions?: WatchOptions;\n        /** Project References */\n        projectReferences?: readonly ProjectReference[];\n    }\n    /**\n     * Host to create watch with config file\n     */\n    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {\n        /** Name of the config file to compile */\n        configFileName: string;\n        /** Options to extend */\n        optionsToExtend?: CompilerOptions;\n        watchOptionsToExtend?: WatchOptions;\n        extraFileExtensions?: readonly FileExtensionInfo[];\n        /**\n         * Used to generate source file names from the config file and its include, exclude, files rules\n         * and also to cache the directory stucture\n         */\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n    }\n    interface Watch<T> {\n        /** Synchronize with host and get updated program */\n        getProgram(): T;\n        /** Closes the watch */\n        close(): void;\n    }\n    /**\n     * Creates the watch what generates program using the config file\n     */\n    interface WatchOfConfigFile<T> extends Watch<T> {\n    }\n    /**\n     * Creates the watch that generates program using the root files and compiler options\n     */\n    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {\n        /** Updates the root files in the program, only if this is not config file compilation */\n        updateRootFileNames(fileNames: string[]): void;\n    }\n    /**\n     * Create the watch compiler host for either configFile or fileNames and its options\n     */\n    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;\n    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for root files and compiler options\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for config file\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;\n}\ndeclare namespace ts {\n    interface BuildOptions {\n        dry?: boolean;\n        force?: boolean;\n        verbose?: boolean;\n        incremental?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        traceResolution?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;\n    interface ReportFileInError {\n        fileName: string;\n        line: number;\n    }\n    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {\n        createDirectory?(path: string): void;\n        /**\n         * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with\n         * writeFileCallback\n         */\n        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;\n        getCustomTransformers?: (project: string) => CustomTransformers | undefined;\n        getModifiedTime(fileName: string): Date | undefined;\n        setModifiedTime(fileName: string, date: Date): void;\n        deleteFile(fileName: string): void;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        reportDiagnostic: DiagnosticReporter;\n        reportSolutionBuilderStatus: DiagnosticReporter;\n        afterProgramEmitAndDiagnostics?(program: T): void;\n    }\n    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {\n        reportErrorSummary?: ReportEmitErrorSummary;\n    }\n    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {\n    }\n    interface SolutionBuilder<T extends BuilderProgram> {\n        build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;\n        clean(project?: string): ExitStatus;\n        buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;\n        cleanReferences(project?: string): ExitStatus;\n        getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;\n    }\n    /**\n     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic\n     */\n    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;\n    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;\n    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;\n    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;\n    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;\n    enum InvalidatedProjectKind {\n        Build = 0,\n        UpdateBundle = 1,\n        UpdateOutputFileStamps = 2\n    }\n    interface InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind;\n        readonly project: ResolvedConfigFileName;\n        /**\n         *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly\n         */\n        done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;\n        getCompilerOptions(): CompilerOptions;\n        getCurrentDirectory(): string;\n    }\n    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;\n        updateOutputFileStatmps(): void;\n    }\n    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.Build;\n        getBuilderProgram(): T | undefined;\n        getProgram(): Program | undefined;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFiles(): readonly SourceFile[];\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;\n    }\n    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.UpdateBundle;\n        emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;\n    }\n    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;\n}\ndeclare namespace ts.server {\n    type ActionSet = "action::set";\n    type ActionInvalidate = "action::invalidate";\n    type ActionPackageInstalled = "action::packageInstalled";\n    type EventTypesRegistry = "event::typesRegistry";\n    type EventBeginInstallTypes = "event::beginInstallTypes";\n    type EventEndInstallTypes = "event::endInstallTypes";\n    type EventInitializationFailed = "event::initializationFailed";\n}\ndeclare namespace ts.server {\n    interface TypingInstallerResponse {\n        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;\n    }\n    interface TypingInstallerRequestWithProjectName {\n        readonly projectName: string;\n    }\n    interface DiscoverTypings extends TypingInstallerRequestWithProjectName {\n        readonly fileNames: string[];\n        readonly projectRootPath: Path;\n        readonly compilerOptions: CompilerOptions;\n        readonly watchOptions?: WatchOptions;\n        readonly typeAcquisition: TypeAcquisition;\n        readonly unresolvedImports: SortedReadonlyArray<string>;\n        readonly cachePath?: string;\n        readonly kind: "discover";\n    }\n    interface CloseProject extends TypingInstallerRequestWithProjectName {\n        readonly kind: "closeProject";\n    }\n    interface TypesRegistryRequest {\n        readonly kind: "typesRegistry";\n    }\n    interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {\n        readonly kind: "installPackage";\n        readonly fileName: Path;\n        readonly packageName: string;\n        readonly projectRootPath: Path;\n    }\n    interface PackageInstalledResponse extends ProjectResponse {\n        readonly kind: ActionPackageInstalled;\n        readonly success: boolean;\n        readonly message: string;\n    }\n    interface InitializationFailedResponse extends TypingInstallerResponse {\n        readonly kind: EventInitializationFailed;\n        readonly message: string;\n        readonly stack?: string;\n    }\n    interface ProjectResponse extends TypingInstallerResponse {\n        readonly projectName: string;\n    }\n    interface InvalidateCachedTypings extends ProjectResponse {\n        readonly kind: ActionInvalidate;\n    }\n    interface InstallTypes extends ProjectResponse {\n        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;\n        readonly eventId: number;\n        readonly typingsInstallerVersion: string;\n        readonly packagesToInstall: readonly string[];\n    }\n    interface BeginInstallTypes extends InstallTypes {\n        readonly kind: EventBeginInstallTypes;\n    }\n    interface EndInstallTypes extends InstallTypes {\n        readonly kind: EventEndInstallTypes;\n        readonly installSuccess: boolean;\n    }\n    interface SetTypings extends ProjectResponse {\n        readonly typeAcquisition: TypeAcquisition;\n        readonly compilerOptions: CompilerOptions;\n        readonly typings: string[];\n        readonly unresolvedImports: SortedReadonlyArray<string>;\n        readonly kind: ActionSet;\n    }\n}\ndeclare namespace ts {\n    interface Node {\n        getSourceFile(): SourceFile;\n        getChildCount(sourceFile?: SourceFile): number;\n        getChildAt(index: number, sourceFile?: SourceFile): Node;\n        getChildren(sourceFile?: SourceFile): Node[];\n        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;\n        getFullStart(): number;\n        getEnd(): number;\n        getWidth(sourceFile?: SourceFileLike): number;\n        getFullWidth(): number;\n        getLeadingTriviaWidth(sourceFile?: SourceFile): number;\n        getFullText(sourceFile?: SourceFile): string;\n        getText(sourceFile?: SourceFile): string;\n        getFirstToken(sourceFile?: SourceFile): Node | undefined;\n        getLastToken(sourceFile?: SourceFile): Node | undefined;\n        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    }\n    interface Identifier {\n        readonly text: string;\n    }\n    interface PrivateIdentifier {\n        readonly text: string;\n    }\n    interface Symbol {\n        readonly name: string;\n        getFlags(): SymbolFlags;\n        getEscapedName(): __String;\n        getName(): string;\n        getDeclarations(): Declaration[] | undefined;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];\n    }\n    interface Type {\n        getFlags(): TypeFlags;\n        getSymbol(): Symbol | undefined;\n        getProperties(): Symbol[];\n        getProperty(propertyName: string): Symbol | undefined;\n        getApparentProperties(): Symbol[];\n        getCallSignatures(): readonly Signature[];\n        getConstructSignatures(): readonly Signature[];\n        getStringIndexType(): Type | undefined;\n        getNumberIndexType(): Type | undefined;\n        getBaseTypes(): BaseType[] | undefined;\n        getNonNullableType(): Type;\n        getConstraint(): Type | undefined;\n        getDefault(): Type | undefined;\n        isUnion(): this is UnionType;\n        isIntersection(): this is IntersectionType;\n        isUnionOrIntersection(): this is UnionOrIntersectionType;\n        isLiteral(): this is LiteralType;\n        isStringLiteral(): this is StringLiteralType;\n        isNumberLiteral(): this is NumberLiteralType;\n        isTypeParameter(): this is TypeParameter;\n        isClassOrInterface(): this is InterfaceType;\n        isClass(): this is InterfaceType;\n        isIndexType(): this is IndexType;\n    }\n    interface TypeReference {\n        typeArguments?: readonly Type[];\n    }\n    interface Signature {\n        getDeclaration(): SignatureDeclaration;\n        getTypeParameters(): TypeParameter[] | undefined;\n        getParameters(): Symbol[];\n        getTypeParameterAtPosition(pos: number): Type;\n        getReturnType(): Type;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(): JSDocTagInfo[];\n    }\n    interface SourceFile {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n        getLineEndOfPosition(pos: number): number;\n        getLineStarts(): readonly number[];\n        getPositionOfLineAndCharacter(line: number, character: number): number;\n        update(newText: string, textChangeRange: TextChangeRange): SourceFile;\n    }\n    interface SourceFileLike {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    interface SourceMapSource {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    /**\n     * Represents an immutable snapshot of a script at a specified time.Once acquired, the\n     * snapshot is observably immutable. i.e. the same calls with the same parameters will return\n     * the same values.\n     */\n    interface IScriptSnapshot {\n        /** Gets a portion of the script snapshot specified by [start, end). */\n        getText(start: number, end: number): string;\n        /** Gets the length of this script snapshot. */\n        getLength(): number;\n        /**\n         * Gets the TextChangeRange that describe how the text changed between this text and\n         * an older version.  This information is used by the incremental parser to determine\n         * what sections of the script need to be re-parsed.  \'undefined\' can be returned if the\n         * change range cannot be determined.  However, in that case, incremental parsing will\n         * not happen and the entire document will be re - parsed.\n         */\n        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;\n        /** Releases all resources held by this script snapshot */\n        dispose?(): void;\n    }\n    namespace ScriptSnapshot {\n        function fromString(text: string): IScriptSnapshot;\n    }\n    interface PreProcessedFileInfo {\n        referencedFiles: FileReference[];\n        typeReferenceDirectives: FileReference[];\n        libReferenceDirectives: FileReference[];\n        importedFiles: FileReference[];\n        ambientExternalModules?: string[];\n        isLibFile: boolean;\n    }\n    interface HostCancellationToken {\n        isCancellationRequested(): boolean;\n    }\n    interface InstallPackageOptions {\n        fileName: Path;\n        packageName: string;\n    }\n    interface PerformanceEvent {\n        kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";\n        durationMs: number;\n    }\n    enum LanguageServiceMode {\n        Semantic = 0,\n        PartialSemantic = 1,\n        Syntactic = 2\n    }\n    interface IncompleteCompletionsCache {\n        get(): CompletionInfo | undefined;\n        set(response: CompletionInfo): void;\n        clear(): void;\n    }\n    interface LanguageServiceHost extends GetEffectiveTypeRootsHost {\n        getCompilationSettings(): CompilerOptions;\n        getNewLine?(): string;\n        getProjectVersion?(): string;\n        getScriptFileNames(): string[];\n        getScriptKind?(fileName: string): ScriptKind;\n        getScriptVersion(fileName: string): string;\n        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;\n        getProjectReferences?(): readonly ProjectReference[] | undefined;\n        getLocalizedDiagnosticMessages?(): any;\n        getCancellationToken?(): HostCancellationToken;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        log?(s: string): void;\n        trace?(s: string): void;\n        error?(s: string): void;\n        useCaseSensitiveFileNames?(): boolean;\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        readFile?(path: string, encoding?: string): string | undefined;\n        realpath?(path: string): string;\n        fileExists?(path: string): boolean;\n        getTypeRootsVersion?(): number;\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;\n        resolveTypeReferenceDirectives?(typeDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n        getDirectories?(directoryName: string): string[];\n        /**\n         * Gets a set of custom transformers to use during emit.\n         */\n        getCustomTransformers?(): CustomTransformers | undefined;\n        isKnownTypesPackageName?(name: string): boolean;\n        installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;\n        writeFile?(fileName: string, content: string): void;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n    }\n    type WithMetadata<T> = T & {\n        metadata?: unknown;\n    };\n    enum SemanticClassificationFormat {\n        Original = "original",\n        TwentyTwenty = "2020"\n    }\n    interface LanguageService {\n        /** This is used as a part of restarting the language service. */\n        cleanupSemanticCache(): void;\n        /**\n         * Gets errors indicating invalid syntax in a file.\n         *\n         * In English, "this cdeo have, erorrs" is syntactically invalid because it has typos,\n         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax\n         * errors in TypeScript are missing parentheses in an `if` statement, mismatched\n         * curly braces, and using a reserved keyword as a variable name.\n         *\n         * These diagnostics are inexpensive to compute and don\'t require knowledge of\n         * other files. Note that a non-empty result increases the likelihood of false positives\n         * from `getSemanticDiagnostics`.\n         *\n         * While these represent the majority of syntax-related diagnostics, there are some\n         * that require the type system, which will be present in `getSemanticDiagnostics`.\n         *\n         * @param fileName A path to the file you want syntactic diagnostics for\n         */\n        getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets warnings or errors indicating type system issues in a given file.\n         * Requesting semantic diagnostics may start up the type system and\n         * run deferred work, so the first call may take longer than subsequent calls.\n         *\n         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not\n         * include a reference to a source file. Specifically, the first time this is called,\n         * it will return global diagnostics with no associated location.\n         *\n         * To contrast the differences between semantic and syntactic diagnostics, consider the\n         * sentence: "The sun is green." is syntactically correct; those are real English words with\n         * correct sentence structure. However, it is semantically invalid, because it is not true.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSemanticDiagnostics(fileName: string): Diagnostic[];\n        /**\n         * Gets suggestion diagnostics for a specific file. These diagnostics tend to\n         * proactively suggest refactors, as opposed to diagnostics that indicate\n         * potentially incorrect runtime behavior.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets global diagnostics related to the program configuration and compiler options.\n         */\n        getCompilerOptionsDiagnostics(): Diagnostic[];\n        /** @deprecated Use getEncodedSyntacticClassifications instead. */\n        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];\n        /** @deprecated Use getEncodedSemanticClassifications instead. */\n        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];\n        /** Encoded as triples of [start, length, ClassificationType]. */\n        getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;\n        /**\n         * Gets semantic highlights information for a particular file. Has two formats, an older\n         * version used by VS and a format used by VS Code.\n         *\n         * @param fileName The path to the file\n         * @param position A text span to return results within\n         * @param format Which format to use, defaults to "original"\n         * @returns a number array encoded as triples of [start, length, ClassificationType, ...].\n         */\n        getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;\n        /**\n         * Gets completion entries at a particular position in a file.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the entries\n         * @param options An object describing how the request was triggered and what kinds\n         * of code actions can be returned with the completions.\n         * @param formattingSettings settings needed for calling formatting functions.\n         */\n        getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;\n        /**\n         * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.\n         *\n         * @param fileName The path to the file\n         * @param position A zero based index of the character where you want the entries\n         * @param entryName The `name` from an existing completion which came from `getCompletionsAtPosition`\n         * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility\n         * @param source `source` property from the completion entry\n         * @param preferences User settings, can be undefined for backwards compatibility\n         * @param data `data` property from the completion entry\n         */\n        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;\n        getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;\n        /**\n         * Gets semantic information about the identifier at a particular position in a\n         * file. Quick info is what you typically see when you hover in an editor.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the quick info\n         */\n        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;\n        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;\n        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;\n        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;\n        getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;\n        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;\n        getSmartSelectionRange(fileName: string, position: number): SelectionRange;\n        getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;\n        getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;\n        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;\n        findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;\n        getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;\n        getFileReferences(fileName: string): ReferenceEntry[];\n        /** @deprecated */\n        getOccurrencesAtPosition(fileName: string, position: number): readonly ReferenceEntry[] | undefined;\n        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean): NavigateToItem[];\n        getNavigationBarItems(fileName: string): NavigationBarItem[];\n        getNavigationTree(fileName: string): NavigationTree;\n        prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;\n        provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];\n        provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];\n        provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];\n        getOutliningSpans(fileName: string): OutliningSpan[];\n        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];\n        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];\n        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;\n        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions): TextInsertion | undefined;\n        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;\n        /**\n         * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.\n         * Editors should call this after `>` is typed.\n         */\n        getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;\n        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;\n        toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;\n        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];\n        getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;\n        applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;\n        applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;\n        applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): ApplicableRefactorInfo[];\n        getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined): RefactorEditInfo | undefined;\n        organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;\n        getProgram(): Program | undefined;\n        toggleLineComment(fileName: string, textRange: TextRange): TextChange[];\n        toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];\n        commentSelection(fileName: string, textRange: TextRange): TextChange[];\n        uncommentSelection(fileName: string, textRange: TextRange): TextChange[];\n        dispose(): void;\n    }\n    interface JsxClosingTagInfo {\n        readonly newText: string;\n    }\n    interface CombinedCodeFixScope {\n        type: "file";\n        fileName: string;\n    }\n    interface OrganizeImportsArgs extends CombinedCodeFixScope {\n        skipDestructiveCodeActions?: boolean;\n    }\n    type CompletionsTriggerCharacter = "." | \'"\' | "\'" | "`" | "/" | "@" | "<" | "#" | " ";\n    enum CompletionTriggerKind {\n        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */\n        Invoked = 1,\n        /** Completion was triggered by a trigger character. */\n        TriggerCharacter = 2,\n        /** Completion was re-triggered as the current completion list is incomplete. */\n        TriggerForIncompleteCompletions = 3\n    }\n    interface GetCompletionsAtPositionOptions extends UserPreferences {\n        /**\n         * If the editor is asking for completions because a certain character was typed\n         * (as opposed to when the user explicitly requested them) this should be set.\n         */\n        triggerCharacter?: CompletionsTriggerCharacter;\n        triggerKind?: CompletionTriggerKind;\n        /** @deprecated Use includeCompletionsForModuleExports */\n        includeExternalModuleExports?: boolean;\n        /** @deprecated Use includeCompletionsWithInsertText */\n        includeInsertTextCompletions?: boolean;\n    }\n    interface InlayHintsOptions extends UserPreferences {\n        readonly includeInlayParameterNameHints?: "none" | "literals" | "all";\n        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;\n        readonly includeInlayFunctionParameterTypeHints?: boolean;\n        readonly includeInlayVariableTypeHints?: boolean;\n        readonly includeInlayPropertyDeclarationTypeHints?: boolean;\n        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;\n        readonly includeInlayEnumMemberValueHints?: boolean;\n    }\n    type SignatureHelpTriggerCharacter = "," | "(" | "<";\n    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";\n    interface SignatureHelpItemsOptions {\n        triggerReason?: SignatureHelpTriggerReason;\n    }\n    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;\n    /**\n     * Signals that the user manually requested signature help.\n     * The language service will unconditionally attempt to provide a result.\n     */\n    interface SignatureHelpInvokedReason {\n        kind: "invoked";\n        triggerCharacter?: undefined;\n    }\n    /**\n     * Signals that the signature help request came from a user typing a character.\n     * Depending on the character and the syntactic context, the request may or may not be served a result.\n     */\n    interface SignatureHelpCharacterTypedReason {\n        kind: "characterTyped";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter: SignatureHelpTriggerCharacter;\n    }\n    /**\n     * Signals that this signature help request came from typing a character or moving the cursor.\n     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.\n     * The language service will unconditionally attempt to provide a result.\n     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.\n     */\n    interface SignatureHelpRetriggeredReason {\n        kind: "retrigger";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter?: SignatureHelpRetriggerCharacter;\n    }\n    interface ApplyCodeActionCommandResult {\n        successMessage: string;\n    }\n    interface Classifications {\n        spans: number[];\n        endOfLineState: EndOfLineState;\n    }\n    interface ClassifiedSpan {\n        textSpan: TextSpan;\n        classificationType: ClassificationTypeNames;\n    }\n    interface ClassifiedSpan2020 {\n        textSpan: TextSpan;\n        classificationType: number;\n    }\n    /**\n     * Navigation bar interface designed for visual studio\'s dual-column layout.\n     * This does not form a proper tree.\n     * The navbar is returned as a list of top-level items, each of which has a list of child items.\n     * Child items always have an empty array for their `childItems`.\n     */\n    interface NavigationBarItem {\n        text: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        spans: TextSpan[];\n        childItems: NavigationBarItem[];\n        indent: number;\n        bolded: boolean;\n        grayed: boolean;\n    }\n    /**\n     * Node in a tree of nested declarations in a file.\n     * The top node is always a script or module node.\n     */\n    interface NavigationTree {\n        /** Name of the declaration, or a short description, e.g. "<class>". */\n        text: string;\n        kind: ScriptElementKind;\n        /** ScriptElementKindModifier separated by commas, e.g. "public,abstract" */\n        kindModifiers: string;\n        /**\n         * Spans of the nodes that generated this declaration.\n         * There will be more than one if this is the result of merging.\n         */\n        spans: TextSpan[];\n        nameSpan: TextSpan | undefined;\n        /** Present if non-empty */\n        childItems?: NavigationTree[];\n    }\n    interface CallHierarchyItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        file: string;\n        span: TextSpan;\n        selectionSpan: TextSpan;\n        containerName?: string;\n    }\n    interface CallHierarchyIncomingCall {\n        from: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface CallHierarchyOutgoingCall {\n        to: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    enum InlayHintKind {\n        Type = "Type",\n        Parameter = "Parameter",\n        Enum = "Enum"\n    }\n    interface InlayHint {\n        text: string;\n        position: number;\n        kind: InlayHintKind;\n        whitespaceBefore?: boolean;\n        whitespaceAfter?: boolean;\n    }\n    interface TodoCommentDescriptor {\n        text: string;\n        priority: number;\n    }\n    interface TodoComment {\n        descriptor: TodoCommentDescriptor;\n        message: string;\n        position: number;\n    }\n    interface TextChange {\n        span: TextSpan;\n        newText: string;\n    }\n    interface FileTextChanges {\n        fileName: string;\n        textChanges: readonly TextChange[];\n        isNewFile?: boolean;\n    }\n    interface CodeAction {\n        /** Description of the code action to display in the UI of the editor */\n        description: string;\n        /** Text changes to apply to each file as part of the code action */\n        changes: FileTextChanges[];\n        /**\n         * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.\n         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.\n         */\n        commands?: CodeActionCommand[];\n    }\n    interface CodeFixAction extends CodeAction {\n        /** Short name to identify the fix, for use by telemetry. */\n        fixName: string;\n        /**\n         * If present, one may call \'getCombinedCodeFix\' with this fixId.\n         * This may be omitted to indicate that the code fix can\'t be applied in a group.\n         */\n        fixId?: {};\n        fixAllDescription?: string;\n    }\n    interface CombinedCodeActions {\n        changes: readonly FileTextChanges[];\n        commands?: readonly CodeActionCommand[];\n    }\n    type CodeActionCommand = InstallPackageAction;\n    interface InstallPackageAction {\n    }\n    /**\n     * A set of one or more available refactoring actions, grouped under a parent refactoring.\n     */\n    interface ApplicableRefactorInfo {\n        /**\n         * The programmatic name of the refactoring\n         */\n        name: string;\n        /**\n         * A description of this refactoring category to show to the user.\n         * If the refactoring gets inlined (see below), this text will not be visible.\n         */\n        description: string;\n        /**\n         * Inlineable refactorings can have their actions hoisted out to the top level\n         * of a context menu. Non-inlineanable refactorings should always be shown inside\n         * their parent grouping.\n         *\n         * If not specified, this value is assumed to be \'true\'\n         */\n        inlineable?: boolean;\n        actions: RefactorActionInfo[];\n    }\n    /**\n     * Represents a single refactoring action - for example, the "Extract Method..." refactor might\n     * offer several actions, each corresponding to a surround class or closure to extract into.\n     */\n    interface RefactorActionInfo {\n        /**\n         * The programmatic name of the refactoring action\n         */\n        name: string;\n        /**\n         * A description of this refactoring action to show to the user.\n         * If the parent refactoring is inlined away, this will be the only text shown,\n         * so this description should make sense by itself if the parent is inlineable=true\n         */\n        description: string;\n        /**\n         * A message to show to the user if the refactoring cannot be applied in\n         * the current context.\n         */\n        notApplicableReason?: string;\n        /**\n         * The hierarchical dotted name of the refactor action.\n         */\n        kind?: string;\n    }\n    /**\n     * A set of edits to make in response to a refactor action, plus an optional\n     * location where renaming should be invoked from\n     */\n    interface RefactorEditInfo {\n        edits: FileTextChanges[];\n        renameFilename?: string;\n        renameLocation?: number;\n        commands?: CodeActionCommand[];\n    }\n    type RefactorTriggerReason = "implicit" | "invoked";\n    interface TextInsertion {\n        newText: string;\n        /** The position in newText the caret should point to after the insertion. */\n        caretOffset: number;\n    }\n    interface DocumentSpan {\n        textSpan: TextSpan;\n        fileName: string;\n        /**\n         * If the span represents a location that was remapped (e.g. via a .d.ts.map file),\n         * then the original filename and span will be specified here\n         */\n        originalTextSpan?: TextSpan;\n        originalFileName?: string;\n        /**\n         * If DocumentSpan.textSpan is the span for name of the declaration,\n         * then this is the span for relevant declaration\n         */\n        contextSpan?: TextSpan;\n        originalContextSpan?: TextSpan;\n    }\n    interface RenameLocation extends DocumentSpan {\n        readonly prefixText?: string;\n        readonly suffixText?: string;\n    }\n    interface ReferenceEntry extends DocumentSpan {\n        isWriteAccess: boolean;\n        isDefinition: boolean;\n        isInString?: true;\n    }\n    interface ImplementationLocation extends DocumentSpan {\n        kind: ScriptElementKind;\n        displayParts: SymbolDisplayPart[];\n    }\n    enum HighlightSpanKind {\n        none = "none",\n        definition = "definition",\n        reference = "reference",\n        writtenReference = "writtenReference"\n    }\n    interface HighlightSpan {\n        fileName?: string;\n        isInString?: true;\n        textSpan: TextSpan;\n        contextSpan?: TextSpan;\n        kind: HighlightSpanKind;\n    }\n    interface NavigateToItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        matchKind: "exact" | "prefix" | "substring" | "camelCase";\n        isCaseSensitive: boolean;\n        fileName: string;\n        textSpan: TextSpan;\n        containerName: string;\n        containerKind: ScriptElementKind;\n    }\n    enum IndentStyle {\n        None = 0,\n        Block = 1,\n        Smart = 2\n    }\n    enum SemicolonPreference {\n        Ignore = "ignore",\n        Insert = "insert",\n        Remove = "remove"\n    }\n    interface EditorOptions {\n        BaseIndentSize?: number;\n        IndentSize: number;\n        TabSize: number;\n        NewLineCharacter: string;\n        ConvertTabsToSpaces: boolean;\n        IndentStyle: IndentStyle;\n    }\n    interface EditorSettings {\n        baseIndentSize?: number;\n        indentSize?: number;\n        tabSize?: number;\n        newLineCharacter?: string;\n        convertTabsToSpaces?: boolean;\n        indentStyle?: IndentStyle;\n        trimTrailingWhitespace?: boolean;\n    }\n    interface FormatCodeOptions extends EditorOptions {\n        InsertSpaceAfterCommaDelimiter: boolean;\n        InsertSpaceAfterSemicolonInForStatements: boolean;\n        InsertSpaceBeforeAndAfterBinaryOperators: boolean;\n        InsertSpaceAfterConstructor?: boolean;\n        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;\n        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        InsertSpaceAfterTypeAssertion?: boolean;\n        InsertSpaceBeforeFunctionParenthesis?: boolean;\n        PlaceOpenBraceOnNewLineForFunctions: boolean;\n        PlaceOpenBraceOnNewLineForControlBlocks: boolean;\n        insertSpaceBeforeTypeAnnotation?: boolean;\n    }\n    interface FormatCodeSettings extends EditorSettings {\n        readonly insertSpaceAfterCommaDelimiter?: boolean;\n        readonly insertSpaceAfterSemicolonInForStatements?: boolean;\n        readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n        readonly insertSpaceAfterConstructor?: boolean;\n        readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n        readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        readonly insertSpaceAfterTypeAssertion?: boolean;\n        readonly insertSpaceBeforeFunctionParenthesis?: boolean;\n        readonly placeOpenBraceOnNewLineForFunctions?: boolean;\n        readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;\n        readonly insertSpaceBeforeTypeAnnotation?: boolean;\n        readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;\n        readonly semicolons?: SemicolonPreference;\n    }\n    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;\n    interface DefinitionInfo extends DocumentSpan {\n        kind: ScriptElementKind;\n        name: string;\n        containerKind: ScriptElementKind;\n        containerName: string;\n        unverified?: boolean;\n    }\n    interface DefinitionInfoAndBoundSpan {\n        definitions?: readonly DefinitionInfo[];\n        textSpan: TextSpan;\n    }\n    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {\n        displayParts: SymbolDisplayPart[];\n    }\n    interface ReferencedSymbol {\n        definition: ReferencedSymbolDefinitionInfo;\n        references: ReferenceEntry[];\n    }\n    enum SymbolDisplayPartKind {\n        aliasName = 0,\n        className = 1,\n        enumName = 2,\n        fieldName = 3,\n        interfaceName = 4,\n        keyword = 5,\n        lineBreak = 6,\n        numericLiteral = 7,\n        stringLiteral = 8,\n        localName = 9,\n        methodName = 10,\n        moduleName = 11,\n        operator = 12,\n        parameterName = 13,\n        propertyName = 14,\n        punctuation = 15,\n        space = 16,\n        text = 17,\n        typeParameterName = 18,\n        enumMemberName = 19,\n        functionName = 20,\n        regularExpressionLiteral = 21,\n        link = 22,\n        linkName = 23,\n        linkText = 24\n    }\n    interface SymbolDisplayPart {\n        text: string;\n        kind: string;\n    }\n    interface JSDocLinkDisplayPart extends SymbolDisplayPart {\n        target: DocumentSpan;\n    }\n    interface JSDocTagInfo {\n        name: string;\n        text?: SymbolDisplayPart[];\n    }\n    interface QuickInfo {\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        textSpan: TextSpan;\n        displayParts?: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n    }\n    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n    interface RenameInfoSuccess {\n        canRename: true;\n        /**\n         * File or directory to rename.\n         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.\n         */\n        fileToRename?: string;\n        displayName: string;\n        fullDisplayName: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        triggerSpan: TextSpan;\n    }\n    interface RenameInfoFailure {\n        canRename: false;\n        localizedErrorMessage: string;\n    }\n    interface RenameInfoOptions {\n        readonly allowRenameOfImportPath?: boolean;\n    }\n    interface DocCommentTemplateOptions {\n        readonly generateReturnInDocTemplate?: boolean;\n    }\n    interface SignatureHelpParameter {\n        name: string;\n        documentation: SymbolDisplayPart[];\n        displayParts: SymbolDisplayPart[];\n        isOptional: boolean;\n        isRest?: boolean;\n    }\n    interface SelectionRange {\n        textSpan: TextSpan;\n        parent?: SelectionRange;\n    }\n    /**\n     * Represents a single signature to show in signature help.\n     * The id is used for subsequent calls into the language service to ask questions about the\n     * signature help item in the context of any documents that have been updated.  i.e. after\n     * an edit has happened, while signature help is still active, the host can ask important\n     * questions like \'what parameter is the user currently contained within?\'.\n     */\n    interface SignatureHelpItem {\n        isVariadic: boolean;\n        prefixDisplayParts: SymbolDisplayPart[];\n        suffixDisplayParts: SymbolDisplayPart[];\n        separatorDisplayParts: SymbolDisplayPart[];\n        parameters: SignatureHelpParameter[];\n        documentation: SymbolDisplayPart[];\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Represents a set of signature help items, and the preferred item that should be selected.\n     */\n    interface SignatureHelpItems {\n        items: SignatureHelpItem[];\n        applicableSpan: TextSpan;\n        selectedItemIndex: number;\n        argumentIndex: number;\n        argumentCount: number;\n    }\n    interface CompletionInfo {\n        /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */\n        isGlobalCompletion: boolean;\n        isMemberCompletion: boolean;\n        /**\n         * In the absence of `CompletionEntry["replacementSpan"], the editor may choose whether to use\n         * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span\n         * must be used to commit that completion entry.\n         */\n        optionalReplacementSpan?: TextSpan;\n        /**\n         * true when the current location also allows for a new identifier\n         */\n        isNewIdentifierLocation: boolean;\n        /**\n         * Indicates to client to continue requesting completions on subsequent keystrokes.\n         */\n        isIncomplete?: true;\n        entries: CompletionEntry[];\n    }\n    interface CompletionEntryDataAutoImport {\n        /**\n         * The name of the property or export in the module\'s symbol table. Differs from the completion name\n         * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.\n         */\n        exportName: string;\n        moduleSpecifier?: string;\n        /** The file name declaring the export\'s module symbol, if it was an external module */\n        fileName?: string;\n        /** The module name (with quotes stripped) of the export\'s module symbol, if it was an ambient module */\n        ambientModuleName?: string;\n        /** True if the export was found in the package.json AutoImportProvider */\n        isPackageJsonImport?: true;\n    }\n    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {\n        /** The key in the `ExportMapCache` where the completion entry\'s `SymbolExportInfo[]` is found */\n        exportMapKey: string;\n    }\n    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {\n        moduleSpecifier: string;\n    }\n    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;\n    interface CompletionEntry {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        sortText: string;\n        insertText?: string;\n        isSnippet?: true;\n        /**\n         * An optional span that indicates the text to be replaced by this completion item.\n         * If present, this span should be used instead of the default one.\n         * It will be set if the required span differs from the one generated by the default replacement behavior.\n         */\n        replacementSpan?: TextSpan;\n        hasAction?: true;\n        source?: string;\n        sourceDisplay?: SymbolDisplayPart[];\n        isRecommended?: true;\n        isFromUncheckedFile?: true;\n        isPackageJsonImport?: true;\n        isImportStatementCompletion?: true;\n        /**\n         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,\n         * that allows TS Server to look up the symbol represented by the completion item, disambiguating\n         * items with the same name. Currently only defined for auto-import completions, but the type is\n         * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.\n         * The presence of this property should generally not be used to assume that this completion entry\n         * is an auto-import.\n         */\n        data?: CompletionEntryData;\n    }\n    interface CompletionEntryDetails {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        displayParts: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n        codeActions?: CodeAction[];\n        /** @deprecated Use `sourceDisplay` instead. */\n        source?: SymbolDisplayPart[];\n        sourceDisplay?: SymbolDisplayPart[];\n    }\n    interface OutliningSpan {\n        /** The span of the document to actually collapse. */\n        textSpan: TextSpan;\n        /** The span of the document to display when the user hovers over the collapsed span. */\n        hintSpan: TextSpan;\n        /** The text to display in the editor for the collapsed region. */\n        bannerText: string;\n        /**\n         * Whether or not this region should be automatically collapsed when\n         * the \'Collapse to Definitions\' command is invoked.\n         */\n        autoCollapse: boolean;\n        /**\n         * Classification of the contents of the span\n         */\n        kind: OutliningSpanKind;\n    }\n    enum OutliningSpanKind {\n        /** Single or multi-line comments */\n        Comment = "comment",\n        /** Sections marked by \'// #region\' and \'// #endregion\' comments */\n        Region = "region",\n        /** Declarations and expressions */\n        Code = "code",\n        /** Contiguous blocks of import declarations */\n        Imports = "imports"\n    }\n    enum OutputFileType {\n        JavaScript = 0,\n        SourceMap = 1,\n        Declaration = 2\n    }\n    enum EndOfLineState {\n        None = 0,\n        InMultiLineCommentTrivia = 1,\n        InSingleQuoteStringLiteral = 2,\n        InDoubleQuoteStringLiteral = 3,\n        InTemplateHeadOrNoSubstitutionTemplate = 4,\n        InTemplateMiddleOrTail = 5,\n        InTemplateSubstitutionPosition = 6\n    }\n    enum TokenClass {\n        Punctuation = 0,\n        Keyword = 1,\n        Operator = 2,\n        Comment = 3,\n        Whitespace = 4,\n        Identifier = 5,\n        NumberLiteral = 6,\n        BigIntLiteral = 7,\n        StringLiteral = 8,\n        RegExpLiteral = 9\n    }\n    interface ClassificationResult {\n        finalLexState: EndOfLineState;\n        entries: ClassificationInfo[];\n    }\n    interface ClassificationInfo {\n        length: number;\n        classification: TokenClass;\n    }\n    interface Classifier {\n        /**\n         * Gives lexical classifications of tokens on a line without any syntactic context.\n         * For instance, a token consisting of the text \'string\' can be either an identifier\n         * named \'string\' or the keyword \'string\', however, because this classifier is not aware,\n         * it relies on certain heuristics to give acceptable results. For classifications where\n         * speed trumps accuracy, this function is preferable; however, for true accuracy, the\n         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the\n         * lexical, syntactic, and semantic classifiers may issue the best user experience.\n         *\n         * @param text                      The text of a line to classify.\n         * @param lexState                  The state of the lexical classifier at the end of the previous line.\n         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.\n         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),\n         *                                  certain heuristics may be used in its place; however, if there is a\n         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain\n         *                                  classifications which may be incorrectly categorized will be given\n         *                                  back as Identifiers in order to allow the syntactic classifier to\n         *                                  subsume the classification.\n         * @deprecated Use getLexicalClassifications instead.\n         */\n        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;\n        getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;\n    }\n    enum ScriptElementKind {\n        unknown = "",\n        warning = "warning",\n        /** predefined type (void) or keyword (class) */\n        keyword = "keyword",\n        /** top level script node */\n        scriptElement = "script",\n        /** module foo {} */\n        moduleElement = "module",\n        /** class X {} */\n        classElement = "class",\n        /** var x = class X {} */\n        localClassElement = "local class",\n        /** interface Y {} */\n        interfaceElement = "interface",\n        /** type T = ... */\n        typeElement = "type",\n        /** enum E */\n        enumElement = "enum",\n        enumMemberElement = "enum member",\n        /**\n         * Inside module and script only\n         * const v = ..\n         */\n        variableElement = "var",\n        /** Inside function */\n        localVariableElement = "local var",\n        /**\n         * Inside module and script only\n         * function f() { }\n         */\n        functionElement = "function",\n        /** Inside function */\n        localFunctionElement = "local function",\n        /** class X { [public|private]* foo() {} } */\n        memberFunctionElement = "method",\n        /** class X { [public|private]* [get|set] foo:number; } */\n        memberGetAccessorElement = "getter",\n        memberSetAccessorElement = "setter",\n        /**\n         * class X { [public|private]* foo:number; }\n         * interface Y { foo:number; }\n         */\n        memberVariableElement = "property",\n        /**\n         * class X { constructor() { } }\n         * class X { static { } }\n         */\n        constructorImplementationElement = "constructor",\n        /** interface Y { ():number; } */\n        callSignatureElement = "call",\n        /** interface Y { []:number; } */\n        indexSignatureElement = "index",\n        /** interface Y { new():Y; } */\n        constructSignatureElement = "construct",\n        /** function foo(*Y*: string) */\n        parameterElement = "parameter",\n        typeParameterElement = "type parameter",\n        primitiveType = "primitive type",\n        label = "label",\n        alias = "alias",\n        constElement = "const",\n        letElement = "let",\n        directory = "directory",\n        externalModuleName = "external module name",\n        /**\n         * <JsxTagName attribute1 attribute2={0} />\n         * @deprecated\n         */\n        jsxAttribute = "JSX attribute",\n        /** String literal */\n        string = "string",\n        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */\n        link = "link",\n        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */\n        linkName = "link name",\n        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */\n        linkText = "link text"\n    }\n    enum ScriptElementKindModifier {\n        none = "",\n        publicMemberModifier = "public",\n        privateMemberModifier = "private",\n        protectedMemberModifier = "protected",\n        exportedModifier = "export",\n        ambientModifier = "declare",\n        staticModifier = "static",\n        abstractModifier = "abstract",\n        optionalModifier = "optional",\n        deprecatedModifier = "deprecated",\n        dtsModifier = ".d.ts",\n        tsModifier = ".ts",\n        tsxModifier = ".tsx",\n        jsModifier = ".js",\n        jsxModifier = ".jsx",\n        jsonModifier = ".json",\n        dmtsModifier = ".d.mts",\n        mtsModifier = ".mts",\n        mjsModifier = ".mjs",\n        dctsModifier = ".d.cts",\n        ctsModifier = ".cts",\n        cjsModifier = ".cjs"\n    }\n    enum ClassificationTypeNames {\n        comment = "comment",\n        identifier = "identifier",\n        keyword = "keyword",\n        numericLiteral = "number",\n        bigintLiteral = "bigint",\n        operator = "operator",\n        stringLiteral = "string",\n        whiteSpace = "whitespace",\n        text = "text",\n        punctuation = "punctuation",\n        className = "class name",\n        enumName = "enum name",\n        interfaceName = "interface name",\n        moduleName = "module name",\n        typeParameterName = "type parameter name",\n        typeAliasName = "type alias name",\n        parameterName = "parameter name",\n        docCommentTagName = "doc comment tag name",\n        jsxOpenTagName = "jsx open tag name",\n        jsxCloseTagName = "jsx close tag name",\n        jsxSelfClosingTagName = "jsx self closing tag name",\n        jsxAttribute = "jsx attribute",\n        jsxText = "jsx text",\n        jsxAttributeStringLiteralValue = "jsx attribute string literal value"\n    }\n    enum ClassificationType {\n        comment = 1,\n        identifier = 2,\n        keyword = 3,\n        numericLiteral = 4,\n        operator = 5,\n        stringLiteral = 6,\n        regularExpressionLiteral = 7,\n        whiteSpace = 8,\n        text = 9,\n        punctuation = 10,\n        className = 11,\n        enumName = 12,\n        interfaceName = 13,\n        moduleName = 14,\n        typeParameterName = 15,\n        typeAliasName = 16,\n        parameterName = 17,\n        docCommentTagName = 18,\n        jsxOpenTagName = 19,\n        jsxCloseTagName = 20,\n        jsxSelfClosingTagName = 21,\n        jsxAttribute = 22,\n        jsxText = 23,\n        jsxAttributeStringLiteralValue = 24,\n        bigintLiteral = 25\n    }\n    interface InlayHintsContext {\n        file: SourceFile;\n        program: Program;\n        cancellationToken: CancellationToken;\n        host: LanguageServiceHost;\n        span: TextSpan;\n        preferences: InlayHintsOptions;\n    }\n}\ndeclare namespace ts {\n    /** The classifier is used for syntactic highlighting in editors via the TSServer */\n    function createClassifier(): Classifier;\n}\ndeclare namespace ts {\n    interface DocumentHighlights {\n        fileName: string;\n        highlightSpans: HighlightSpan[];\n    }\n}\ndeclare namespace ts {\n    /**\n     * The document registry represents a store of SourceFile objects that can be shared between\n     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)\n     * of files in the context.\n     * SourceFile objects account for most of the memory usage by the language service. Sharing\n     * the same DocumentRegistry instance between different instances of LanguageService allow\n     * for more efficient memory utilization since all projects will share at least the library\n     * file (lib.d.ts).\n     *\n     * A more advanced use of the document registry is to serialize sourceFile objects to disk\n     * and re-hydrate them when needed.\n     *\n     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it\n     * to all subsequent createLanguageService calls.\n     */\n    interface DocumentRegistry {\n        /**\n         * Request a stored SourceFile with a given fileName and compilationSettings.\n         * The first call to acquire will call createLanguageServiceSourceFile to generate\n         * the SourceFile if was not found in the registry.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettings Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings.\n         * @param scriptSnapshot Text of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         * @param version Current version of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         */\n        acquireDocument(fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        acquireDocumentWithKey(fileName: string, path: Path, compilationSettings: CompilerOptions, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        /**\n         * Request an updated version of an already existing SourceFile with a given fileName\n         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile\n         * to get an updated SourceFile.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettings Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings.\n         * @param scriptSnapshot Text of the file.\n         * @param version Current version of the file.\n         */\n        updateDocument(fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        updateDocumentWithKey(fileName: string, path: Path, compilationSettings: CompilerOptions, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;\n        /**\n         * Informs the DocumentRegistry that a file is not needed any longer.\n         *\n         * Note: It is not allowed to call release on a SourceFile that was not acquired from\n         * this registry originally.\n         *\n         * @param fileName The name of the file to be released\n         * @param compilationSettings The compilation settings used to acquire the file\n         */\n        /**@deprecated pass scriptKind for correctness */\n        releaseDocument(fileName: string, compilationSettings: CompilerOptions): void;\n        /**\n         * Informs the DocumentRegistry that a file is not needed any longer.\n         *\n         * Note: It is not allowed to call release on a SourceFile that was not acquired from\n         * this registry originally.\n         *\n         * @param fileName The name of the file to be released\n         * @param compilationSettings The compilation settings used to acquire the file\n         * @param scriptKind The script kind of the file to be released\n         */\n        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind): void;\n        /**\n         * @deprecated pass scriptKind for correctness */\n        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey): void;\n        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind): void;\n        reportStats(): string;\n    }\n    type DocumentRegistryBucketKey = string & {\n        __bucketKey: any;\n    };\n    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;\n}\ndeclare namespace ts {\n    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;\n}\ndeclare namespace ts {\n    interface TranspileOptions {\n        compilerOptions?: CompilerOptions;\n        fileName?: string;\n        reportDiagnostics?: boolean;\n        moduleName?: string;\n        renamedDependencies?: MapLike<string>;\n        transformers?: CustomTransformers;\n    }\n    interface TranspileOutput {\n        outputText: string;\n        diagnostics?: Diagnostic[];\n        sourceMapText?: string;\n    }\n    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;\n    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;\n}\ndeclare namespace ts {\n    /** The version of the language service API */\n    const servicesVersion = "0.8";\n    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;\n    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;\n    function getDefaultCompilerOptions(): CompilerOptions;\n    function getSupportedCodeFixes(): string[];\n    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTarget: ScriptTarget, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;\n    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;\n    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;\n    /**\n     * Get the path of the default library files (lib.d.ts) as distributed with the typescript\n     * node package.\n     * The functionality is not supported if the ts module is consumed outside of a node module.\n     */\n    function getDefaultLibFilePath(options: CompilerOptions): string;\n}\ndeclare namespace ts {\n    /**\n     * Transform one or more nodes using the supplied transformers.\n     * @param source A single `Node` or an array of `Node` objects.\n     * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.\n     * @param compilerOptions Optional compiler options.\n     */\n    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;\n}\ndeclare namespace ts {\n    /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */\n    const createNodeArray: <T extends Node>(elements?: readonly T[] | undefined, hasTrailingComma?: boolean | undefined) => NodeArray<T>;\n    /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */\n    const createNumericLiteral: (value: string | number, numericLiteralFlags?: TokenFlags | undefined) => NumericLiteral;\n    /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */\n    const createBigIntLiteral: (value: string | PseudoBigInt) => BigIntLiteral;\n    /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */\n    const createStringLiteral: {\n        (text: string, isSingleQuote?: boolean | undefined): StringLiteral;\n        (text: string, isSingleQuote?: boolean | undefined, hasExtendedUnicodeEscape?: boolean | undefined): StringLiteral;\n    };\n    /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */\n    const createStringLiteralFromNode: (sourceNode: PropertyNameLiteral, isSingleQuote?: boolean | undefined) => StringLiteral;\n    /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */\n    const createRegularExpressionLiteral: (text: string) => RegularExpressionLiteral;\n    /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */\n    const createLoopVariable: (reservedInNestedScopes?: boolean | undefined) => Identifier;\n    /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */\n    const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier;\n    /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */\n    const createPrivateIdentifier: (text: string) => PrivateIdentifier;\n    /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */\n    const createSuper: () => SuperExpression;\n    /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */\n    const createThis: () => ThisExpression;\n    /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */\n    const createNull: () => NullLiteral;\n    /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */\n    const createTrue: () => TrueLiteral;\n    /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */\n    const createFalse: () => FalseLiteral;\n    /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */\n    const createModifier: <T extends ModifierSyntaxKind>(kind: T) => ModifierToken<T>;\n    /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */\n    const createModifiersFromModifierFlags: (flags: ModifierFlags) => Modifier[] | undefined;\n    /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */\n    const createQualifiedName: (left: EntityName, right: string | Identifier) => QualifiedName;\n    /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */\n    const updateQualifiedName: (node: QualifiedName, left: EntityName, right: Identifier) => QualifiedName;\n    /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */\n    const createComputedPropertyName: (expression: Expression) => ComputedPropertyName;\n    /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */\n    const updateComputedPropertyName: (node: ComputedPropertyName, expression: Expression) => ComputedPropertyName;\n    /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */\n    const createTypeParameterDeclaration: (name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined) => TypeParameterDeclaration;\n    /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */\n    const updateTypeParameterDeclaration: (node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined) => TypeParameterDeclaration;\n    /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */\n    const createParameter: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined) => ParameterDeclaration;\n    /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */\n    const updateParameter: (node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => ParameterDeclaration;\n    /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */\n    const createDecorator: (expression: Expression) => Decorator;\n    /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */\n    const updateDecorator: (node: Decorator, expression: Expression) => Decorator;\n    /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */\n    const createProperty: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertyDeclaration;\n    /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */\n    const updateProperty: (node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertyDeclaration;\n    /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */\n    const createMethod: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => MethodDeclaration;\n    /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */\n    const updateMethod: (node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => MethodDeclaration;\n    /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */\n    const createConstructor: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined) => ConstructorDeclaration;\n    /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */\n    const updateConstructor: (node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined) => ConstructorDeclaration;\n    /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */\n    const createGetAccessor: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => GetAccessorDeclaration;\n    /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */\n    const updateGetAccessor: (node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => GetAccessorDeclaration;\n    /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */\n    const createSetAccessor: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined) => SetAccessorDeclaration;\n    /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */\n    const updateSetAccessor: (node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined) => SetAccessorDeclaration;\n    /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */\n    const createCallSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => CallSignatureDeclaration;\n    /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */\n    const updateCallSignature: (node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => CallSignatureDeclaration;\n    /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */\n    const createConstructSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => ConstructSignatureDeclaration;\n    /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */\n    const updateConstructSignature: (node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => ConstructSignatureDeclaration;\n    /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */\n    const updateIndexSignature: (node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;\n    /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */\n    const createKeywordTypeNode: <TKind extends KeywordTypeSyntaxKind>(kind: TKind) => KeywordTypeNode<TKind>;\n    /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */\n    const createTypePredicateNodeWithModifier: (assertsModifier: AssertsKeyword | undefined, parameterName: string | Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;\n    /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */\n    const updateTypePredicateNodeWithModifier: (node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;\n    /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */\n    const createTypeReferenceNode: (typeName: string | EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeReferenceNode;\n    /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */\n    const updateTypeReferenceNode: (node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined) => TypeReferenceNode;\n    /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */\n    const createFunctionTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => FunctionTypeNode;\n    /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */\n    const updateFunctionTypeNode: (node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => FunctionTypeNode;\n    /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */\n    const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;\n    /** @deprecated Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */\n    const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;\n    /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */\n    const createTypeQueryNode: (exprName: EntityName) => TypeQueryNode;\n    /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */\n    const updateTypeQueryNode: (node: TypeQueryNode, exprName: EntityName) => TypeQueryNode;\n    /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */\n    const createTypeLiteralNode: (members: readonly TypeElement[] | undefined) => TypeLiteralNode;\n    /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */\n    const updateTypeLiteralNode: (node: TypeLiteralNode, members: NodeArray<TypeElement>) => TypeLiteralNode;\n    /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */\n    const createArrayTypeNode: (elementType: TypeNode) => ArrayTypeNode;\n    /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */\n    const updateArrayTypeNode: (node: ArrayTypeNode, elementType: TypeNode) => ArrayTypeNode;\n    /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */\n    const createTupleTypeNode: (elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;\n    /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */\n    const updateTupleTypeNode: (node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;\n    /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */\n    const createOptionalTypeNode: (type: TypeNode) => OptionalTypeNode;\n    /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */\n    const updateOptionalTypeNode: (node: OptionalTypeNode, type: TypeNode) => OptionalTypeNode;\n    /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */\n    const createRestTypeNode: (type: TypeNode) => RestTypeNode;\n    /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */\n    const updateRestTypeNode: (node: RestTypeNode, type: TypeNode) => RestTypeNode;\n    /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */\n    const createUnionTypeNode: (types: readonly TypeNode[]) => UnionTypeNode;\n    /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */\n    const updateUnionTypeNode: (node: UnionTypeNode, types: NodeArray<TypeNode>) => UnionTypeNode;\n    /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */\n    const createIntersectionTypeNode: (types: readonly TypeNode[]) => IntersectionTypeNode;\n    /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */\n    const updateIntersectionTypeNode: (node: IntersectionTypeNode, types: NodeArray<TypeNode>) => IntersectionTypeNode;\n    /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */\n    const createConditionalTypeNode: (checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;\n    /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */\n    const updateConditionalTypeNode: (node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;\n    /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */\n    const createInferTypeNode: (typeParameter: TypeParameterDeclaration) => InferTypeNode;\n    /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */\n    const updateInferTypeNode: (node: InferTypeNode, typeParameter: TypeParameterDeclaration) => InferTypeNode;\n    /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */\n    const createImportTypeNode: (argument: TypeNode, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined) => ImportTypeNode;\n    /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */\n    const updateImportTypeNode: (node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined) => ImportTypeNode;\n    /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */\n    const createParenthesizedType: (type: TypeNode) => ParenthesizedTypeNode;\n    /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */\n    const updateParenthesizedType: (node: ParenthesizedTypeNode, type: TypeNode) => ParenthesizedTypeNode;\n    /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */\n    const createThisTypeNode: () => ThisTypeNode;\n    /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */\n    const updateTypeOperatorNode: (node: TypeOperatorNode, type: TypeNode) => TypeOperatorNode;\n    /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */\n    const createIndexedAccessTypeNode: (objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;\n    /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */\n    const updateIndexedAccessTypeNode: (node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;\n    /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */\n    const createMappedTypeNode: (readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;\n    /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */\n    const updateMappedTypeNode: (node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;\n    /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */\n    const createLiteralTypeNode: (literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;\n    /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */\n    const updateLiteralTypeNode: (node: LiteralTypeNode, literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;\n    /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */\n    const createObjectBindingPattern: (elements: readonly BindingElement[]) => ObjectBindingPattern;\n    /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */\n    const updateObjectBindingPattern: (node: ObjectBindingPattern, elements: readonly BindingElement[]) => ObjectBindingPattern;\n    /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */\n    const createArrayBindingPattern: (elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;\n    /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */\n    const updateArrayBindingPattern: (node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;\n    /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */\n    const createBindingElement: (dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression | undefined) => BindingElement;\n    /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */\n    const updateBindingElement: (node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined) => BindingElement;\n    /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */\n    const createArrayLiteral: (elements?: readonly Expression[] | undefined, multiLine?: boolean | undefined) => ArrayLiteralExpression;\n    /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */\n    const updateArrayLiteral: (node: ArrayLiteralExpression, elements: readonly Expression[]) => ArrayLiteralExpression;\n    /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */\n    const createObjectLiteral: (properties?: readonly ObjectLiteralElementLike[] | undefined, multiLine?: boolean | undefined) => ObjectLiteralExpression;\n    /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */\n    const updateObjectLiteral: (node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]) => ObjectLiteralExpression;\n    /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */\n    const createPropertyAccess: (expression: Expression, name: string | MemberName) => PropertyAccessExpression;\n    /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */\n    const updatePropertyAccess: (node: PropertyAccessExpression, expression: Expression, name: MemberName) => PropertyAccessExpression;\n    /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */\n    const createPropertyAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName) => PropertyAccessChain;\n    /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */\n    const updatePropertyAccessChain: (node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName) => PropertyAccessChain;\n    /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */\n    const createElementAccess: (expression: Expression, index: number | Expression) => ElementAccessExpression;\n    /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */\n    const updateElementAccess: (node: ElementAccessExpression, expression: Expression, argumentExpression: Expression) => ElementAccessExpression;\n    /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */\n    const createElementAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression) => ElementAccessChain;\n    /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */\n    const updateElementAccessChain: (node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression) => ElementAccessChain;\n    /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */\n    const createCall: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallExpression;\n    /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */\n    const updateCall: (node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallExpression;\n    /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */\n    const createCallChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallChain;\n    /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */\n    const updateCallChain: (node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallChain;\n    /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */\n    const createNew: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;\n    /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */\n    const updateNew: (node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;\n    /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */\n    const createTypeAssertion: (type: TypeNode, expression: Expression) => TypeAssertion;\n    /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */\n    const updateTypeAssertion: (node: TypeAssertion, type: TypeNode, expression: Expression) => TypeAssertion;\n    /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */\n    const createParen: (expression: Expression) => ParenthesizedExpression;\n    /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */\n    const updateParen: (node: ParenthesizedExpression, expression: Expression) => ParenthesizedExpression;\n    /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */\n    const createFunctionExpression: (modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block) => FunctionExpression;\n    /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */\n    const updateFunctionExpression: (node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block) => FunctionExpression;\n    /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */\n    const createDelete: (expression: Expression) => DeleteExpression;\n    /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */\n    const updateDelete: (node: DeleteExpression, expression: Expression) => DeleteExpression;\n    /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */\n    const createTypeOf: (expression: Expression) => TypeOfExpression;\n    /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */\n    const updateTypeOf: (node: TypeOfExpression, expression: Expression) => TypeOfExpression;\n    /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */\n    const createVoid: (expression: Expression) => VoidExpression;\n    /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */\n    const updateVoid: (node: VoidExpression, expression: Expression) => VoidExpression;\n    /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */\n    const createAwait: (expression: Expression) => AwaitExpression;\n    /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */\n    const updateAwait: (node: AwaitExpression, expression: Expression) => AwaitExpression;\n    /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */\n    const createPrefix: (operator: PrefixUnaryOperator, operand: Expression) => PrefixUnaryExpression;\n    /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */\n    const updatePrefix: (node: PrefixUnaryExpression, operand: Expression) => PrefixUnaryExpression;\n    /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */\n    const createPostfix: (operand: Expression, operator: PostfixUnaryOperator) => PostfixUnaryExpression;\n    /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */\n    const updatePostfix: (node: PostfixUnaryExpression, operand: Expression) => PostfixUnaryExpression;\n    /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */\n    const createBinary: (left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */\n    const updateConditional: (node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression) => ConditionalExpression;\n    /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */\n    const createTemplateExpression: (head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;\n    /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */\n    const updateTemplateExpression: (node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;\n    /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */\n    const createTemplateHead: {\n        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateHead;\n        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateHead;\n    };\n    /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */\n    const createTemplateMiddle: {\n        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateMiddle;\n        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateMiddle;\n    };\n    /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */\n    const createTemplateTail: {\n        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateTail;\n        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateTail;\n    };\n    /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */\n    const createNoSubstitutionTemplateLiteral: {\n        (text: string, rawText?: string | undefined): NoSubstitutionTemplateLiteral;\n        (text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;\n    };\n    /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */\n    const updateYield: (node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined) => YieldExpression;\n    /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */\n    const createSpread: (expression: Expression) => SpreadElement;\n    /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */\n    const updateSpread: (node: SpreadElement, expression: Expression) => SpreadElement;\n    /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */\n    const createOmittedExpression: () => OmittedExpression;\n    /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */\n    const createAsExpression: (expression: Expression, type: TypeNode) => AsExpression;\n    /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */\n    const updateAsExpression: (node: AsExpression, expression: Expression, type: TypeNode) => AsExpression;\n    /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */\n    const createNonNullExpression: (expression: Expression) => NonNullExpression;\n    /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */\n    const updateNonNullExpression: (node: NonNullExpression, expression: Expression) => NonNullExpression;\n    /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */\n    const createNonNullChain: (expression: Expression) => NonNullChain;\n    /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */\n    const updateNonNullChain: (node: NonNullChain, expression: Expression) => NonNullChain;\n    /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */\n    const createMetaProperty: (keywordToken: SyntaxKind.ImportKeyword | SyntaxKind.NewKeyword, name: Identifier) => MetaProperty;\n    /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */\n    const updateMetaProperty: (node: MetaProperty, name: Identifier) => MetaProperty;\n    /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */\n    const createTemplateSpan: (expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;\n    /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */\n    const updateTemplateSpan: (node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;\n    /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */\n    const createSemicolonClassElement: () => SemicolonClassElement;\n    /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */\n    const createBlock: (statements: readonly Statement[], multiLine?: boolean | undefined) => Block;\n    /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */\n    const updateBlock: (node: Block, statements: readonly Statement[]) => Block;\n    /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */\n    const createVariableStatement: (modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]) => VariableStatement;\n    /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */\n    const updateVariableStatement: (node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList) => VariableStatement;\n    /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */\n    const createEmptyStatement: () => EmptyStatement;\n    /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */\n    const createExpressionStatement: (expression: Expression) => ExpressionStatement;\n    /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */\n    const updateExpressionStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;\n    /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */\n    const createStatement: (expression: Expression) => ExpressionStatement;\n    /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */\n    const updateStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;\n    /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */\n    const createIf: (expression: Expression, thenStatement: Statement, elseStatement?: Statement | undefined) => IfStatement;\n    /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */\n    const updateIf: (node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined) => IfStatement;\n    /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */\n    const createDo: (statement: Statement, expression: Expression) => DoStatement;\n    /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */\n    const updateDo: (node: DoStatement, statement: Statement, expression: Expression) => DoStatement;\n    /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */\n    const createWhile: (expression: Expression, statement: Statement) => WhileStatement;\n    /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */\n    const updateWhile: (node: WhileStatement, expression: Expression, statement: Statement) => WhileStatement;\n    /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */\n    const createFor: (initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;\n    /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */\n    const updateFor: (node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;\n    /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */\n    const createForIn: (initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;\n    /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */\n    const updateForIn: (node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;\n    /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */\n    const createForOf: (awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;\n    /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */\n    const updateForOf: (node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;\n    /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */\n    const createContinue: (label?: string | Identifier | undefined) => ContinueStatement;\n    /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */\n    const updateContinue: (node: ContinueStatement, label: Identifier | undefined) => ContinueStatement;\n    /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */\n    const createBreak: (label?: string | Identifier | undefined) => BreakStatement;\n    /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */\n    const updateBreak: (node: BreakStatement, label: Identifier | undefined) => BreakStatement;\n    /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */\n    const createReturn: (expression?: Expression | undefined) => ReturnStatement;\n    /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */\n    const updateReturn: (node: ReturnStatement, expression: Expression | undefined) => ReturnStatement;\n    /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */\n    const createWith: (expression: Expression, statement: Statement) => WithStatement;\n    /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */\n    const updateWith: (node: WithStatement, expression: Expression, statement: Statement) => WithStatement;\n    /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */\n    const createSwitch: (expression: Expression, caseBlock: CaseBlock) => SwitchStatement;\n    /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */\n    const updateSwitch: (node: SwitchStatement, expression: Expression, caseBlock: CaseBlock) => SwitchStatement;\n    /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */\n    const createLabel: (label: string | Identifier, statement: Statement) => LabeledStatement;\n    /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */\n    const updateLabel: (node: LabeledStatement, label: Identifier, statement: Statement) => LabeledStatement;\n    /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */\n    const createThrow: (expression: Expression) => ThrowStatement;\n    /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */\n    const updateThrow: (node: ThrowStatement, expression: Expression) => ThrowStatement;\n    /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */\n    const createTry: (tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;\n    /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */\n    const updateTry: (node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;\n    /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */\n    const createDebuggerStatement: () => DebuggerStatement;\n    /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */\n    const createVariableDeclarationList: (declarations: readonly VariableDeclaration[], flags?: NodeFlags | undefined) => VariableDeclarationList;\n    /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */\n    const updateVariableDeclarationList: (node: VariableDeclarationList, declarations: readonly VariableDeclaration[]) => VariableDeclarationList;\n    /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */\n    const createFunctionDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => FunctionDeclaration;\n    /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */\n    const updateFunctionDeclaration: (node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined) => FunctionDeclaration;\n    /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */\n    const createClassDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassDeclaration;\n    /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */\n    const updateClassDeclaration: (node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassDeclaration;\n    /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */\n    const createInterfaceDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]) => InterfaceDeclaration;\n    /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */\n    const updateInterfaceDeclaration: (node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]) => InterfaceDeclaration;\n    /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */\n    const createTypeAliasDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode) => TypeAliasDeclaration;\n    /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */\n    const updateTypeAliasDeclaration: (node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode) => TypeAliasDeclaration;\n    /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */\n    const createEnumDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]) => EnumDeclaration;\n    /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */\n    const updateEnumDeclaration: (node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]) => EnumDeclaration;\n    /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */\n    const createModuleDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined) => ModuleDeclaration;\n    /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */\n    const updateModuleDeclaration: (node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined) => ModuleDeclaration;\n    /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */\n    const createModuleBlock: (statements: readonly Statement[]) => ModuleBlock;\n    /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */\n    const updateModuleBlock: (node: ModuleBlock, statements: readonly Statement[]) => ModuleBlock;\n    /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */\n    const createCaseBlock: (clauses: readonly CaseOrDefaultClause[]) => CaseBlock;\n    /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */\n    const updateCaseBlock: (node: CaseBlock, clauses: readonly CaseOrDefaultClause[]) => CaseBlock;\n    /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */\n    const createNamespaceExportDeclaration: (name: string | Identifier) => NamespaceExportDeclaration;\n    /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */\n    const updateNamespaceExportDeclaration: (node: NamespaceExportDeclaration, name: Identifier) => NamespaceExportDeclaration;\n    /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */\n    const createImportEqualsDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference) => ImportEqualsDeclaration;\n    /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */\n    const updateImportEqualsDeclaration: (node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference) => ImportEqualsDeclaration;\n    /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */\n    const createImportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined) => ImportDeclaration;\n    /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */\n    const updateImportDeclaration: (node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined) => ImportDeclaration;\n    /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */\n    const createNamespaceImport: (name: Identifier) => NamespaceImport;\n    /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */\n    const updateNamespaceImport: (node: NamespaceImport, name: Identifier) => NamespaceImport;\n    /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */\n    const createNamedImports: (elements: readonly ImportSpecifier[]) => NamedImports;\n    /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */\n    const updateNamedImports: (node: NamedImports, elements: readonly ImportSpecifier[]) => NamedImports;\n    /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */\n    const createImportSpecifier: (isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;\n    /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */\n    const updateImportSpecifier: (node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;\n    /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */\n    const createExportAssignment: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression) => ExportAssignment;\n    /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */\n    const updateExportAssignment: (node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression) => ExportAssignment;\n    /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */\n    const createNamedExports: (elements: readonly ExportSpecifier[]) => NamedExports;\n    /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */\n    const updateNamedExports: (node: NamedExports, elements: readonly ExportSpecifier[]) => NamedExports;\n    /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */\n    const createExportSpecifier: (isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier) => ExportSpecifier;\n    /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */\n    const updateExportSpecifier: (node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ExportSpecifier;\n    /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */\n    const createExternalModuleReference: (expression: Expression) => ExternalModuleReference;\n    /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */\n    const updateExternalModuleReference: (node: ExternalModuleReference, expression: Expression) => ExternalModuleReference;\n    /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */\n    const createJSDocTypeExpression: (type: TypeNode) => JSDocTypeExpression;\n    /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */\n    const createJSDocTypeTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypeTag;\n    /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */\n    const createJSDocReturnTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReturnTag;\n    /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */\n    const createJSDocThisTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocThisTag;\n    /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */\n    const createJSDocComment: (comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined) => JSDoc;\n    /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */\n    const createJSDocParameterTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocParameterTag;\n    /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */\n    const createJSDocClassTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocClassTag;\n    /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */\n    const createJSDocAugmentsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {\n        readonly expression: Identifier | PropertyAccessEntityNameExpression;\n    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAugmentsTag;\n    /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */\n    const createJSDocEnumTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocEnumTag;\n    /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */\n    const createJSDocTemplateTag: (tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTemplateTag;\n    /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */\n    const createJSDocTypedefTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeLiteral | JSDocTypeExpression | undefined, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypedefTag;\n    /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */\n    const createJSDocCallbackTag: (tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocCallbackTag;\n    /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */\n    const createJSDocSignature: (typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag | undefined) => JSDocSignature;\n    /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */\n    const createJSDocPropertyTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPropertyTag;\n    /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */\n    const createJSDocTypeLiteral: (jsDocPropertyTags?: readonly JSDocPropertyLikeTag[] | undefined, isArrayType?: boolean | undefined) => JSDocTypeLiteral;\n    /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */\n    const createJSDocImplementsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {\n        readonly expression: Identifier | PropertyAccessEntityNameExpression;\n    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocImplementsTag;\n    /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */\n    const createJSDocAuthorTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAuthorTag;\n    /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */\n    const createJSDocPublicTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPublicTag;\n    /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */\n    const createJSDocPrivateTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPrivateTag;\n    /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */\n    const createJSDocProtectedTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocProtectedTag;\n    /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */\n    const createJSDocReadonlyTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReadonlyTag;\n    /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */\n    const createJSDocTag: (tagName: Identifier, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocUnknownTag;\n    /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */\n    const createJsxElement: (openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;\n    /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */\n    const updateJsxElement: (node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;\n    /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */\n    const createJsxSelfClosingElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;\n    /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */\n    const updateJsxSelfClosingElement: (node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;\n    /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */\n    const createJsxOpeningElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;\n    /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */\n    const updateJsxOpeningElement: (node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;\n    /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */\n    const createJsxClosingElement: (tagName: JsxTagNameExpression) => JsxClosingElement;\n    /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */\n    const updateJsxClosingElement: (node: JsxClosingElement, tagName: JsxTagNameExpression) => JsxClosingElement;\n    /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */\n    const createJsxFragment: (openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;\n    /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */\n    const createJsxText: (text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;\n    /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */\n    const updateJsxText: (node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;\n    /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */\n    const createJsxOpeningFragment: () => JsxOpeningFragment;\n    /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */\n    const createJsxJsxClosingFragment: () => JsxClosingFragment;\n    /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */\n    const updateJsxFragment: (node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;\n    /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */\n    const createJsxAttribute: (name: Identifier, initializer: StringLiteral | JsxExpression | undefined) => JsxAttribute;\n    /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */\n    const updateJsxAttribute: (node: JsxAttribute, name: Identifier, initializer: StringLiteral | JsxExpression | undefined) => JsxAttribute;\n    /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */\n    const createJsxAttributes: (properties: readonly JsxAttributeLike[]) => JsxAttributes;\n    /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */\n    const updateJsxAttributes: (node: JsxAttributes, properties: readonly JsxAttributeLike[]) => JsxAttributes;\n    /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */\n    const createJsxSpreadAttribute: (expression: Expression) => JsxSpreadAttribute;\n    /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */\n    const updateJsxSpreadAttribute: (node: JsxSpreadAttribute, expression: Expression) => JsxSpreadAttribute;\n    /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */\n    const createJsxExpression: (dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined) => JsxExpression;\n    /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */\n    const updateJsxExpression: (node: JsxExpression, expression: Expression | undefined) => JsxExpression;\n    /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */\n    const createCaseClause: (expression: Expression, statements: readonly Statement[]) => CaseClause;\n    /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */\n    const updateCaseClause: (node: CaseClause, expression: Expression, statements: readonly Statement[]) => CaseClause;\n    /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */\n    const createDefaultClause: (statements: readonly Statement[]) => DefaultClause;\n    /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */\n    const updateDefaultClause: (node: DefaultClause, statements: readonly Statement[]) => DefaultClause;\n    /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */\n    const createHeritageClause: (token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;\n    /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */\n    const updateHeritageClause: (node: HeritageClause, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;\n    /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */\n    const createCatchClause: (variableDeclaration: string | VariableDeclaration | BindingName | undefined, block: Block) => CatchClause;\n    /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */\n    const updateCatchClause: (node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block) => CatchClause;\n    /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */\n    const createPropertyAssignment: (name: string | PropertyName, initializer: Expression) => PropertyAssignment;\n    /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */\n    const updatePropertyAssignment: (node: PropertyAssignment, name: PropertyName, initializer: Expression) => PropertyAssignment;\n    /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */\n    const createShorthandPropertyAssignment: (name: string | Identifier, objectAssignmentInitializer?: Expression | undefined) => ShorthandPropertyAssignment;\n    /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */\n    const updateShorthandPropertyAssignment: (node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined) => ShorthandPropertyAssignment;\n    /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */\n    const createSpreadAssignment: (expression: Expression) => SpreadAssignment;\n    /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */\n    const updateSpreadAssignment: (node: SpreadAssignment, expression: Expression) => SpreadAssignment;\n    /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */\n    const createEnumMember: (name: string | PropertyName, initializer?: Expression | undefined) => EnumMember;\n    /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */\n    const updateEnumMember: (node: EnumMember, name: PropertyName, initializer: Expression | undefined) => EnumMember;\n    /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */\n    const updateSourceFileNode: (node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean | undefined, referencedFiles?: readonly FileReference[] | undefined, typeReferences?: readonly FileReference[] | undefined, hasNoDefaultLib?: boolean | undefined, libReferences?: readonly FileReference[] | undefined) => SourceFile;\n    /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */\n    const createNotEmittedStatement: (original: Node) => NotEmittedStatement;\n    /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */\n    const createPartiallyEmittedExpression: (expression: Expression, original?: Node | undefined) => PartiallyEmittedExpression;\n    /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */\n    const updatePartiallyEmittedExpression: (node: PartiallyEmittedExpression, expression: Expression) => PartiallyEmittedExpression;\n    /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */\n    const createCommaList: (elements: readonly Expression[]) => CommaListExpression;\n    /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */\n    const updateCommaList: (node: CommaListExpression, elements: readonly Expression[]) => CommaListExpression;\n    /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */\n    const createBundle: (sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;\n    /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */\n    const updateBundle: (node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;\n    /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */\n    const createImmediatelyInvokedFunctionExpression: {\n        (statements: readonly Statement[]): CallExpression;\n        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n    };\n    /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */\n    const createImmediatelyInvokedArrowFunction: {\n        (statements: readonly Statement[]): CallExpression;\n        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n    };\n    /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */\n    const createVoidZero: () => VoidExpression;\n    /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */\n    const createExportDefault: (expression: Expression) => ExportAssignment;\n    /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */\n    const createExternalModuleExport: (exportName: Identifier) => ExportDeclaration;\n    /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */\n    const createNamespaceExport: (name: Identifier) => NamespaceExport;\n    /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */\n    const updateNamespaceExport: (node: NamespaceExport, name: Identifier) => NamespaceExport;\n    /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */\n    const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;\n    /** @deprecated Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */\n    const createIdentifier: (text: string) => Identifier;\n    /** @deprecated Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */\n    const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;\n    /** @deprecated Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */\n    const getGeneratedNameForNode: (node: Node | undefined) => Identifier;\n    /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */\n    const createOptimisticUniqueName: (text: string) => Identifier;\n    /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */\n    const createFileLevelUniqueName: (text: string) => Identifier;\n    /** @deprecated Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */\n    const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;\n    /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */\n    const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;\n    /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */\n    const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;\n    /** @deprecated Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */\n    const createLiteral: {\n        (value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;\n        (value: number | PseudoBigInt): NumericLiteral;\n        (value: boolean): BooleanLiteral;\n        (value: string | number | PseudoBigInt | boolean): PrimaryExpression;\n    };\n    /** @deprecated Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */\n    const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;\n    /** @deprecated Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */\n    const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;\n    /** @deprecated Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */\n    const createTypeOperatorNode: {\n        (type: TypeNode): TypeOperatorNode;\n        (operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;\n    };\n    /** @deprecated Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */\n    const createTaggedTemplate: {\n        (tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;\n        (tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n    };\n    /** @deprecated Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */\n    const updateTaggedTemplate: {\n        (node: TaggedTemplateExpression, tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;\n        (node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n    };\n    /** @deprecated Use `factory.updateBinary` or the factory supplied by your transformation context instead. */\n    const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;\n    /** @deprecated Use `factory.createConditional` or the factory supplied by your transformation context instead. */\n    const createConditional: {\n        (condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression;\n        (condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;\n    };\n    /** @deprecated Use `factory.createYield` or the factory supplied by your transformation context instead. */\n    const createYield: {\n        (expression?: Expression | undefined): YieldExpression;\n        (asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;\n    };\n    /** @deprecated Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */\n    const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;\n    /** @deprecated Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */\n    const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;\n    /** @deprecated Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */\n    const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;\n    /** @deprecated Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */\n    const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;\n    /** @deprecated Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */\n    const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;\n    /** @deprecated Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */\n    const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;\n    /** @deprecated Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */\n    const createArrowFunction: {\n        (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;\n        (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;\n    };\n    /** @deprecated Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */\n    const updateArrowFunction: {\n        (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;\n        (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;\n    };\n    /** @deprecated Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */\n    const createVariableDeclaration: {\n        (name: string | BindingName, type?: TypeNode | undefined, initializer?: Expression | undefined): VariableDeclaration;\n        (name: string | BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n    };\n    /** @deprecated Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */\n    const updateVariableDeclaration: {\n        (node: VariableDeclaration, name: BindingName, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n        (node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n    };\n    /** @deprecated Use `factory.createImportClause` or the factory supplied by your transformation context instead. */\n    const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;\n    /** @deprecated Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */\n    const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;\n    /** @deprecated Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */\n    const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;\n    /** @deprecated Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */\n    const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;\n    /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */\n    const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;\n    /** @deprecated Use `factory.createComma` or the factory supplied by your transformation context instead. */\n    const createComma: (left: Expression, right: Expression) => Expression;\n    /** @deprecated Use `factory.createLessThan` or the factory supplied by your transformation context instead. */\n    const createLessThan: (left: Expression, right: Expression) => Expression;\n    /** @deprecated Use `factory.createAssignment` or the factory supplied by your transformation context instead. */\n    const createAssignment: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */\n    const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */\n    const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createAdd` or the factory supplied by your transformation context instead. */\n    const createAdd: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createSubtract` or the factory supplied by your transformation context instead. */\n    const createSubtract: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */\n    const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */\n    const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;\n    /** @deprecated Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */\n    const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;\n    /** @deprecated Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */\n    const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;\n    /** @deprecated Use an appropriate `factory` method instead. */\n    const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;\n    /**\n     * Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set.\n     *\n     * NOTE: It is unsafe to change any properties of a `Node` that relate to its AST children, as those changes won\'t be\n     * captured with respect to transformations.\n     *\n     * @deprecated Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`.\n     */\n    const getMutableClone: <T extends Node>(node: T) => T;\n    /** @deprecated Use `isTypeAssertionExpression` instead. */\n    const isTypeAssertion: (node: Node) => node is TypeAssertion;\n    /**\n     * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.\n     */\n    interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {\n    }\n    /**\n     * @deprecated Use `ts.ESMap<K, V>` instead.\n     */\n    interface Map<T> extends ESMap<string, T> {\n    }\n    /**\n     * @deprecated Use `isMemberName` instead.\n     */\n    const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;\n}\n';