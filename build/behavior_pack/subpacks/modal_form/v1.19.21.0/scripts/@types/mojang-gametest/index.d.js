export default"// Type definitions for Minecraft Bedrock Edition script APIs (experimental) 0.1\n// Project: https://docs.microsoft.com/minecraft/creator/\n// Definitions by: Jake Shirley <https://github.com/JakeShirley>\n//                 Mike Ammerlaan <https://github.com/mammerla>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/* *****************************************************************************\n   Copyright (c) Microsoft Corporation.\n   ***************************************************************************** */\n/**\n * GameTest provides scriptable APIs for scaffolding and\n * testing content experiences in Minecraft.\n */\n/**\n * Represents the type of fluid for use within a fluid\n * containing block, like a cauldron.\n */\ndeclare enum FluidType {\n    /**\n     * Represents water as a type of fluida.\n     */\n    water = 0,\n    /**\n     * Represents lava as a type of fluid.\n     */\n    lava = 1,\n    /**\n     * Represents powder snow as a type of fluid.\n     */\n    powderSnow = 2,\n    /**\n     * Represents a potion as a type of fluid.\n     */\n    potion = 3,\n}\n/**\n * Returns information about whether this fence is connected to\n * other fences in several directions.\n */\ndeclare class FenceConnectivity {\n    /**\n     * Represents whether this fence block is connected to another\n     * fence to the east (x + 1).\n     */\n    readonly 'east': boolean;\n    /**\n     * Represents whether this fence block is connected to another\n     * fence to the north (z - 1).\n     */\n    readonly 'north': boolean;\n    /**\n     * Represents whether this fence block is connected to another\n     * fence to the south (z + 1).\n     */\n    readonly 'south': boolean;\n    /**\n     * Represents whether this fence block is connected to another\n     * fence to the west (x - 1).\n     */\n    readonly 'west': boolean;\n}\n/**\n * Executes a set of steps defined via chained .thenXyz\n * methods, sequentially. This facilitates a 'script' of\n * GameTest setup methods and assertions over time.\n */\ndeclare class GameTestSequence {\n    /**\n     * @remarks\n     * Runs the given callback as a step within a GameTest\n     * sequence. Exceptions thrown within the callback will end\n     * sequence execution.\n     * @param callback\n     * Callback function to execute.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenExecute(callback: () => void): GameTestSequence;\n    /**\n     * @remarks\n     * After a delay, runs the given callback as a step within a\n     * GameTest sequence. Exceptions thrown within the callback\n     * will end sequence execution.\n     * @param delayTicks\n     * Number of ticks to wait before executing the callback.\n     * @param callback\n     * Callback function to execute.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenExecuteAfter(delayTicks: number, callback: () => void): GameTestSequence;\n    /**\n     * @remarks\n     * Runs the given callback every tick for the given number of\n     * ticks.\n     * @param tickCount\n     * @param callback\n     * Callback function to execute.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenExecuteFor(tickCount: number, callback: () => void): GameTestSequence;\n    /**\n     * @remarks\n     * Causes the test to fail if this step in the GameTest\n     * sequence is reached.\n     * @param errorMessage\n     * Error message summarizing the failure condition.\n     */\n    thenFail(errorMessage: string): void;\n    /**\n     * @remarks\n     * Idles the GameTest sequence for the specified delayTicks.\n     * @param delayTicks\n     * Number of ticks to delay for this step in the GameTest\n     * sequence.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenIdle(delayTicks: number): GameTestSequence;\n    /**\n     * @remarks\n     * Marks the GameTest a success if this step is reached in the\n     * GameTest sequence.\n     */\n    thenSucceed(): void;\n    /**\n     * @remarks\n     * Executes the given callback every tick until it succeeds.\n     * Exceptions thrown within the callback will end sequence\n     * execution.\n     * @param callback\n     * Testing callback function to execute. Typically, this\n     * function will have .assertXyz functions within it.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenWait(callback: () => void): GameTestSequence;\n    /**\n     * @remarks\n     * After a delay from the previous step, executes the given\n     * callback every tick until it succeeds. Exceptions thrown\n     * within the callback will end sequence execution.\n     * @param delayTicks\n     * Tick (after the previous step in the GameTest sequence) to\n     * run the callback at.\n     * @param callback\n     * Testing callback function to execute. Typically, this\n     * function will have .assertXyz functions within it.\n     * @returns\n     * Returns a GameTestSequence object where additional .thenXyz\n     * method steps can be added.\n     */\n    thenWaitAfter(delayTicks: number, callback: () => void): GameTestSequence;\n}\n/**\n * A utility class to set GameTest parameters for a test.\n * Methods can be chained together to set multiple properties.\n */\ndeclare class RegistrationBuilder {\n    /**\n     * @remarks\n     * Sets the batch for the test to run in.\n     * @param batchName\n     * Name of the batch for the test.\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    batch(batchName: 'night' | 'day'): RegistrationBuilder;\n    /**\n     * @remarks\n     * Sets the maximum number of times a test will try to rerun if\n     * it fails.\n     * @param attemptCount\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    maxAttempts(attemptCount: number): RegistrationBuilder;\n    /**\n     * @remarks\n     * Sets the maximum number of ticks a test will run for before\n     * timing out and failing.\n     * @param tickCount\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    maxTicks(tickCount: number): RegistrationBuilder;\n    /**\n     * @remarks\n     * Size around the GameTest, in blocks, that should be reserved\n     * for the test when running multiple tests together.\n     * @param paddingBlocks\n     * Size, in blocks, around the GameTest where additional\n     * GameTests should not be created.\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    padding(paddingBlocks: number): RegistrationBuilder;\n    /**\n     * @remarks\n     * Whether this test is required to pass as part of its broader\n     * set of tests.\n     * @param isRequired\n     * If set to true, the test must pass in order for the entire\n     * run of tests to pass.\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    required(isRequired: boolean): RegistrationBuilder;\n    /**\n     * @remarks\n     * Sets the number of successful test runs to be considered\n     * successful.\n     * @param attemptCount\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    requiredSuccessfulAttempts(attemptCount: number): RegistrationBuilder;\n    /**\n     * @remarks\n     * If true, runs the test in all four rotations when run via\n     * /gametest runset.\n     * @param rotate\n     */\n    rotateTest(rotate: boolean): RegistrationBuilder;\n    /**\n     * @remarks\n     * Sets the number of ticks for a test to wait before executing\n     * when the structure is spawned.\n     * @param tickCount\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    setupTicks(tickCount: number): RegistrationBuilder;\n    /**\n     * @remarks\n     * Sets the name of the structure for a test to use. \"xyz:bar\"\n     * will load `/structures/xyz/bar.mcstructure` from the\n     * behavior pack stack.\n     * @param structureName\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    structureName(structureName: string): RegistrationBuilder;\n    /**\n     * @remarks\n     * Adds a tag to a test. You can run all tests with a given tag\n     * with `/gametest runset <tag>`.\n     * @param tag\n     * @returns\n     * RegistrationBuilder object where additional configuration\n     * methods can be called.\n     */\n    tag(tag: string): RegistrationBuilder;\n}\n/**\n * A simulated player can be used within GameTests to represent\n * how a player moves throughout the world and to support\n * testing of how entities and the environment will react to a\n * player. This type derives much of its structure and methods\n * from the {@link mojang-minecraft.Player} type.\n */\ndeclare class SimulatedPlayer extends Player {\n    /**\n     * Rotation of the body in degrees. Range is between -180 and\n     * 180 degrees.\n     * @throws This property can throw when used.\n     */\n    readonly 'bodyRotation': number;\n    /**\n     * Dimension that the simulated player is currently within.\n     * @throws This property can throw when used.\n     */\n    readonly 'dimension': Dimension;\n    /**\n     * Location of the center of the head component of the player.\n     * @throws This property can throw when used.\n     */\n    readonly 'headLocation': Location;\n    /**\n     * Rotation of the head across pitch and yaw angles.\n     * @throws This property can throw when used.\n     */\n    readonly 'headRotation': XYRotation;\n    /**\n     * Identifier for the player.\n     * @throws This property can throw when used.\n     */\n    readonly 'id': string;\n    /**\n     * True if the player is currently using a sneaking movement.\n     */\n    'isSneaking': boolean;\n    /**\n     * Current location of the player.\n     * @throws This property can throw when used.\n     */\n    readonly 'location': Location;\n    /**\n     * Name of the player.\n     * @throws This property can throw when used.\n     */\n    readonly 'name': string;\n    /**\n     * Optional name tag of the player.\n     */\n    'nameTag': string;\n    /**\n     * Manages the selected slot in the player's hotbar.\n     */\n    'selectedSlot': number;\n    /**\n     * Retrieves or sets an entity that is used as the target of\n     * AI-related behaviors, like attacking.\n     */\n    'target': Entity;\n    /**\n     * Current speed of the player across X, Y, and Z dimensions.\n     * @throws This property can throw when used.\n     */\n    readonly 'velocity': Vector;\n    /**\n     * Vector of the current view of the player.\n     * @throws This property can throw when used.\n     */\n    readonly 'viewVector': Vector;\n    /**\n     * @remarks\n     * Adds an effect, like poison, to the entity.\n     * @param effectType\n     * Type of effect to add to the entity.\n     * @param duration\n     * Amount of time, in seconds, for the effect to apply.\n     * @param amplifier\n     * Optional amplification of the effect to apply.\n     * @throws This function can throw errors.\n     */\n    addEffect(effectType: EffectType, duration: number, amplifier: number): void;\n    /**\n     * @remarks\n     * Adds a specified tag to a simulated player.\n     * @param tag\n     * Content of the tag to add.\n     * @throws This function can throw errors.\n     */\n    addTag(tag: string): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to make an attack 'swipe'.\n     * Returns true if the attack was performed - for example, the\n     * player was not on cooldown and had a valid target. Target\n     * selection is performed by raycasting from the player's head.\n     * @throws This function can throw errors.\n     */\n    attack(): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to attack the provided target.\n     * Returns true if the attack was performed - for example, the\n     * player was not on cooldown and had a valid target. The\n     * attack can be performed at any distance and does not require\n     * line of sight to the target entity.\n     * @param entity\n     * @throws This function can throw errors.\n     */\n    attackEntity(entity: Entity): boolean;\n    /**\n     * @remarks\n     * Destroys the block at blockLocation, respecting the rules of\n     * the server player's game mode. The block will be hit until\n     * broken, an item is used or stopBreakingBlock is called.\n     * Returns true if the block at blockLocation is solid.\n     * @param blockLocation\n     * Location of the block to interact with.\n     * @param direction\n     * Direction to place the specified item within.\n     * @throws This function can throw errors.\n     */\n    breakBlock(blockLocation: BlockLocation, direction?: number): boolean;\n    /**\n     * @remarks\n     * Gets the first block that intersects with the vector of the\n     * view of this entity.\n     * @param options\n     * Additional options for processing this raycast query.\n     * @throws This function can throw errors.\n     */\n    getBlockFromViewVector(options?: BlockRaycastOptions): Block;\n    /**\n     * @remarks\n     * Gets a component (that represents additional capabilities)\n     * for an entity.\n     * @param componentId\n     * The identifier of the component (e.g., 'minecraft:rideable')\n     * to retrieve. If no namespace prefix is specified,\n     * 'minecraft:' is assumed. If the component is not present on\n     * the entity, undefined is returned.\n     */\n    getComponent: EntityComponents;\n    /**\n     * @remarks\n     * Returns all components that are both present on this entity\n     * and supported by the API.\n     */\n    getComponents(): IEntityComponent[];\n    /**\n     * @remarks\n     * Returns the effect for the specified EffectType on the\n     * entity, or undefined if the effect is not present.\n     * @param effectType\n     * @returns\n     * Effect object for the specified effect, or undefined if the\n     * effect is not present.\n     * @throws This function can throw errors.\n     */\n    getEffect(effectType: EffectType): Effect;\n    /**\n     * @remarks\n     * Gets the first entity that intersects with the vector of the\n     * view of this entity.\n     * @param options\n     * Additional options for processing this raycast query.\n     * @throws This function can throw errors.\n     */\n    getEntitiesFromViewVector(options?: EntityRaycastOptions): Entity[];\n    /**\n     * @remarks\n     * Gets the current item cooldown time for a particular\n     * cooldown category.\n     * @param itemCategory\n     * Specifies the cooldown category to retrieve the current\n     * cooldown for.\n     * @throws This function can throw errors.\n     */\n    getItemCooldown(itemCategory: string): number;\n    /**\n     * @remarks\n     * Returns all tags associated with this simulated player.\n     * @throws This function can throw errors.\n     */\n    getTags(): string[];\n    /**\n     * @remarks\n     * Gives the simulated player a particular item stack.\n     * @param itemStack\n     * Item to give.\n     * @param selectSlot\n     * Whether to set the selected slot once given.\n     * @throws This function can throw errors.\n     */\n    giveItem(itemStack: ItemStack, selectSlot?: boolean): boolean;\n    /**\n     * @remarks\n     * Returns true if the specified component is present on this\n     * entity.\n     * @param componentId\n     * The identifier of the component (e.g., 'minecraft:rideable')\n     * to retrieve. If no namespace prefix is specified,\n     * 'minecraft:' is assumed.\n     */\n    hasComponent(componentId: string): boolean;\n    /**\n     * @remarks\n     * Tests whether a simulated player has a particular tag.\n     * @param tag\n     * Identifier of the tag to test for.\n     * @throws This function can throw errors.\n     */\n    hasTag(tag: string): boolean;\n    /**\n     * @remarks\n     * Performs a raycast from the playerâ€™s head and interacts with\n     * the first intersected block or entity. Returns true if the\n     * interaction was successful. Maximum range is 6 blocks.\n     * @throws This function can throw errors.\n     */\n    interact(): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to interact with a block. The\n     * block at the specified block location must be solid. Returns\n     * true if the interaction was performed.\n     * @param blockLocation\n     * Location of the block to interact with.\n     * @param direction\n     * Direction to place the specified item within.\n     * @throws This function can throw errors.\n     */\n    interactWithBlock(blockLocation: BlockLocation, direction?: number): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to interact with a mob. Returns\n     * true if the interaction was performed.\n     * @param entity\n     * Entity to interact with.\n     * @throws This function can throw errors.\n     */\n    interactWithEntity(entity: Entity): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to jump.\n     * @returns\n     * True if a jump was performed.\n     * @throws This function can throw errors.\n     */\n    jump(): boolean;\n    /**\n     * @remarks\n     * Kills this entity. The entity will drop loot as normal.\n     * @throws This function can throw errors.\n     */\n    kill(): void;\n    /**\n     * @remarks\n     * Rotates the simulated player's head/body to look at the\n     * given block location.\n     * @param blockLocation\n     * @throws This function can throw errors.\n     */\n    lookAtBlock(blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * Rotates the simulated player's head/body to look at the\n     * given entity.\n     * @param entity\n     * @throws This function can throw errors.\n     */\n    lookAtEntity(entity: Entity): void;\n    /**\n     * @remarks\n     * Rotates the simulated player's head/body to look at the\n     * given location.\n     * @param location\n     * @throws This function can throw errors.\n     */\n    lookAtLocation(location: Location): void;\n    /**\n     * @remarks\n     * Orders the simulated player to walk in the given direction\n     * relative to the GameTest.\n     * @param westEast\n     * @param northSouth\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    move(westEast: number, northSouth: number, speed?: number): void;\n    /**\n     * @remarks\n     * Orders the simulated player to walk in the given direction\n     * relative to the player's current rotation.\n     * @param leftRight\n     * @param backwardForward\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    moveRelative(leftRight: number, backwardForward: number, speed?: number): void;\n    /**\n     * @remarks\n     * Orders the simulated player to move to the given block\n     * location in a straight line. If a move or navigation is\n     * already playing, this will override the last\n     * move/navigation.\n     * @param blockLocation\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    moveToBlock(blockLocation: BlockLocation, speed?: number): void;\n    /**\n     * @remarks\n     * Orders the simulated player to move to the given location in\n     * a straight line. If a move or navigation is already playing,\n     * this will override the last move/navigation.\n     * @param location\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    moveToLocation(location: Location, speed?: number): void;\n    /**\n     * @remarks\n     * Orders the simulated player to move to a specific block\n     * location using navigation. If a move or navigation is\n     * already playing, this will override the last move/walk. Note\n     * that if the simulated player gets stuck, that simulated\n     * player will stop. The player must be touching the ground in\n     * order to start navigation.\n     * @param blockLocation\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    navigateToBlock(blockLocation: BlockLocation, speed?: number): NavigationResult;\n    /**\n     * @remarks\n     * Will use navigation to follow the selected entity to within\n     * a one block radius. If a move or navigation is already\n     * playing, this will override the last move/navigation.\n     * @param entity\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    navigateToEntity(entity: Entity, speed?: number): NavigationResult;\n    /**\n     * @remarks\n     * Orders the simulated player to move to a specific location\n     * using navigation. If a move or navigation is already\n     * playing, this will override the last move/walk. Note that if\n     * the simulated player gets stuck, that simulated player will\n     * stop. The player must be touching the ground in order to\n     * start navigation.\n     * @param location\n     * @param speed\n     * @throws This function can throw errors.\n     */\n    navigateToLocation(location: Location, speed?: number): NavigationResult;\n    /**\n     * @remarks\n     * Use navigation to follow the route provided via the\n     * locations parameter. If a move or navigation is already\n     * playing, this will override the last move/navigation.\n     * @param locations\n     * A list of locations to use for routing.\n     * @param speed\n     * Net speed to use for doing the navigation.\n     * @throws This function can throw errors.\n     */\n    navigateToLocations(locations: Location[], speed?: number): void;\n    /**\n     * @remarks\n     * This method is inherited from Player, but is inoperative in\n     * the case of a SimulatedPlayer.\n     * @param soundID\n     * Identifier of the sound to play.\n     * @param soundOptions\n     * Additional optional options for the sound.\n     * @throws This function can throw errors.\n     */\n    playSound(soundID: string, soundOptions?: SoundOptions): void;\n    /**\n     * @remarks\n     * Removes a specified tag from a simulated player.\n     * @param tag\n     * Content of the tag to remove.\n     * @throws This function can throw errors.\n     */\n    removeTag(tag: string): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to turn by the provided angle,\n     * relative to the player's current rotation.\n     * @param angleInDegrees\n     * @throws This function can throw errors.\n     */\n    rotateBody(angleInDegrees: number): void;\n    /**\n     * @remarks\n     * Runs a particular command from the context of this simulated\n     * player.\n     * @param commandString\n     * Command to run. Note that command strings should not start\n     * with slash.\n     * @returns\n     * For commands that return data, returns a JSON structure with\n     * command response values.\n     * @throws This function can throw errors.\n     * @example commands.js\n     * ```typescript\n     *        player.runCommand(\"say You got a new high score!\");\n     *        player.runCommand(\"scoreboard players set @s score 10\");\n     *\n     * ```\n     */\n    runCommand(commandString: string): any;\n    /**\n     * @remarks\n     * Causes the simulated player to turn to face the provided\n     * angle, relative to the GameTest.\n     * @param angleInDegrees\n     * @throws This function can throw errors.\n     */\n    setBodyRotation(angleInDegrees: number): void;\n    /**\n     * @remarks\n     * Sets the game mode that the simulated player is operating\n     * under.\n     * @param gameMode\n     * Game mode to set.\n     * @throws This function can throw errors.\n     */\n    setGameMode(gameMode: GameMode): void;\n    /**\n     * @remarks\n     * Sets a particular item for the simulated player.\n     * @param itemStack\n     * Item to set.\n     * @param slot\n     * Slot to place the given item in.\n     * @param selectSlot\n     * Whether to set the selected slot once set.\n     * @throws This function can throw errors.\n     */\n    setItem(itemStack: ItemStack, slot: number, selectSlot?: boolean): boolean;\n    /**\n     * @remarks\n     * Sets a velocity for the entity to move with.\n     * @param velocity\n     * X/Y/Z components of the velocity.\n     * @throws This function can throw errors.\n     */\n    setVelocity(velocity: Vector): void;\n    /**\n     * @remarks\n     * Sets the item cooldown time for a particular cooldown\n     * category.\n     * @param itemCategory\n     * Specifies the cooldown category to retrieve the current\n     * cooldown for.\n     * @param tickDuration\n     * Duration in ticks of the item cooldown.\n     * @throws This function can throw errors.\n     */\n    startItemCooldown(itemCategory: string, tickDuration: number): void;\n    /**\n     * @remarks\n     * Stops destroying the block that is currently being hit.\n     * @throws This function can throw errors.\n     */\n    stopBreakingBlock(): void;\n    /**\n     * @remarks\n     * Stops interacting with entities or blocks.\n     * @throws This function can throw errors.\n     */\n    stopInteracting(): void;\n    /**\n     * @remarks\n     * Stops moving/walking/following if the simulated player is\n     * moving.\n     * @throws This function can throw errors.\n     */\n    stopMoving(): void;\n    /**\n     * @remarks\n     * Stops using the currently active item.\n     * @throws This function can throw errors.\n     */\n    stopUsingItem(): void;\n    /**\n     * @remarks\n     * Teleports the selected player to a new location\n     * @param location\n     * New location for the player.\n     * @param dimension\n     * Dimension to move the selected player to.\n     * @param xRotation\n     * X rotation of the player after teleportation.\n     * @param yRotation\n     * Y rotation of the player after teleportation.\n     * @throws This function can throw errors.\n     */\n    teleport(\n        location: Location,\n        dimension: Dimension,\n        xRotation: number,\n        yRotation: number,\n    ): void;\n    /**\n     * @remarks\n     * Teleports the selected player to a new location, and will\n     * have the player facing a specified location.\n     * @param location\n     * New location for the player.\n     * @param dimension\n     * Dimension to move the selected player to.\n     * @param facingLocation\n     * Location that this player will be facing.\n     * @throws This function can throw errors.\n     */\n    teleportFacing(\n        location: Location,\n        dimension: Dimension,\n        facingLocation: Location,\n    ): void;\n    /**\n     * @remarks\n     * Triggers an entity type event. For every entity, a number of\n     * events are defined in an entities' definition for key entity\n     * behaviors; for example, creepers have a\n     * minecraft:start_exploding type event.\n     * @param eventName\n     * Name of the entity type event to trigger. If a namespace is\n     * not specified, minecraft: is assumed.\n     * @throws This function can throw errors.\n     */\n    triggerEvent(eventName: string): void;\n    /**\n     * @remarks\n     * Causes the simulated player to use an item. Does not consume\n     * the item. Returns false if the item is on cooldown.\n     * @param itemStack\n     * Item to use.\n     * @throws This function can throw errors.\n     */\n    useItem(itemStack: ItemStack): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to hold and use an item in their\n     * inventory.\n     * @param slot\n     * Index of the inventory slot.\n     * @throws This function can throw errors.\n     */\n    useItemInSlot(slot: number): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to use an item in their\n     * inventory on a block. The block at the specified block\n     * location must be solid. Returns true if the item was used.\n     * @param slot\n     * Index of the slot to use.\n     * @param blockLocation\n     * Location to use the item upon.\n     * @param direction\n     * Direction to place the specified item within.\n     * @param faceLocationX\n     * Block-face-relative X position where to place the item.\n     * @param faceLocationY\n     * Block-face-relative Y position where to place the item.\n     * @throws This function can throw errors.\n     */\n    useItemInSlotOnBlock(\n        slot: number,\n        blockLocation: BlockLocation,\n        direction?: number,\n        faceLocationX?: number,\n        faceLocationY?: number,\n    ): boolean;\n    /**\n     * @remarks\n     * Causes the simulated player to use an item on a block. The\n     * block at the specified block location must be solid. Returns\n     * true if the item was used.\n     * @param itemStack\n     * Item to use.\n     * @param blockLocation\n     * Location to use the item upon.\n     * @param direction\n     * Direction to place the specified item within.\n     * @param faceLocationX\n     * Block-face-relative X position where to place the item.\n     * @param faceLocationY\n     * Block-face-relative Y position where to place the item.\n     * @throws This function can throw errors.\n     */\n    useItemOnBlock(\n        itemStack: ItemStack,\n        blockLocation: BlockLocation,\n        direction?: number,\n        faceLocationX?: number,\n        faceLocationY?: number,\n    ): boolean;\n}\n/**\n * These well-known tags can be used to classify different\n * tests into suites to run.\n */\n// tslint:disable-next-line:no-unnecessary-class\ndeclare class Tags {\n    /**\n     * Indicates that the tagged test should be a part of all\n     * suites.\n     */\n    static readonly 'suiteAll' = 'suite:all';\n    /**\n     * Indicates that the tagged test should be a part of an\n     * internal (debug) test suite.\n     */\n    static readonly 'suiteDebug' = 'suite:debug';\n    /**\n     * Indicates that the tagged test should be a part of the\n     * default test suite.\n     */\n    static readonly 'suiteDefault' = 'suite:default';\n    /**\n     * Indicates that the tagged test should be a part of a suite\n     * of disabled tests.\n     */\n    static readonly 'suiteDisabled' = 'suite:disabled';\n}\n/**\n * Main class for GameTest functions, with helpers and data for\n * manipulating the respective test. Note that all methods of\n * this class expect BlockLocations and Locations relative to\n * the GameTest structure block.\n */\ndeclare class Test {\n    /**\n     * @remarks\n     * Tests that the condition specified in _condition_ is true.\n     * If not, an error with the specified _message_ is thrown.\n     * @param condition\n     * Expression of the condition to evaluate.\n     * @param message\n     * Message that is passed if the _condition_ does not evaluate\n     * to true.\n     * @throws This function can throw errors.\n     */\n    assert(condition: boolean, message: string): void;\n    /**\n     * @remarks\n     * Tests that a block of the specified type is present at the\n     * specified location. If it is not, an exception is thrown.\n     * @param blockType\n     * Expected block type.\n     * @param blockLocation\n     * Location of the block to test at.\n     * @param isPresent\n     * If true, this function tests whether a block of the\n     * specified type is at the location. If false, tests that a\n     * block of the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    assertBlockPresent(\n        blockType: BlockType,\n        blockLocation: BlockLocation,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that a block has a particular state value at the\n     * specified location. If it does not have that state value, an\n     * exception is thrown.\n     * @param blockLocation\n     * Location of the block to test at.\n     * @param callback\n     * Callback function that contains additional tests based on\n     * the block at the specified location.\n     * @throws This function can throw errors.\n     * @example testIfButtonNotPressed.js\n     * ```typescript\n     *        test.assertBlockState(buttonPos, (block) => {\n     *          return block.getBlockData().getProperty(\"button_pressed_bit\") == 0;\n     *        });\n     * ```\n     */\n    assertBlockState(\n        blockLocation: BlockLocation,\n        callback: (arg: Block) => boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that an entity can reach a particular location.\n     * Depending on the value of canReach, throws an exception if\n     * the condition is not met.\n     * @param mob\n     * Entity that you wish to test the location against.\n     * @param blockLocation\n     * Structure-relative location to test whether the specified\n     * mob can reach.\n     * @param canReach\n     * If true, tests whether the mob can reach the location. If\n     * false, tests whether the mob is not able to reach the\n     * location.\n     * @throws This function can throw errors.\n     */\n    assertCanReachLocation(\n        mob: Entity,\n        blockLocation: BlockLocation,\n        canReach?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that a container (e.g., a chest) at the specified\n     * location contains a specified of item stack. If not, an\n     * error is thrown.\n     * @param itemStack\n     * Represents the type of item to check for. The specified\n     * container must contain at least 1 item matching the item\n     * type defined in _itemStack_.\n     * @param blockLocation\n     * Location of the block with a container (for example, a\n     * chest) to test the contents of.\n     * @throws This function can throw errors.\n     */\n    assertContainerContains(itemStack: ItemStack, blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * Tests that a container (e.g., a chest) at the specified\n     * location is empty. If not, an error is thrown.\n     * @param blockLocation\n     * Location of the block with a container (for example, a\n     * chest) to test is empty of contents.\n     * @throws This function can throw errors.\n     */\n    assertContainerEmpty(blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * Tests that an entity has a specific piece of armor equipped.\n     * If not, an error is thrown.\n     * @param entityTypeIdentifier\n     * Identifier of the entity to match (e.g.,\n     * 'minecraft:skeleton').\n     * @param armorSlot\n     * Container slot index to test.\n     * @param armorName\n     * Name of the armor to look for.\n     * @param armorData\n     * Data value integer to look for.\n     * @param blockLocation\n     * Location of the entity with armor to test for.\n     * @param hasArmor\n     * Whether or not the entity is expected to have the specified\n     * armor equipped.\n     * @throws This function can throw errors.\n     * @example horseArmorTest.js\n     * ```typescript\n     *        test.assertEntityHasArmor(\"minecraft:horse\", armorSlotTorso, \"diamond_horse_armor\", 0, horseLocation, true);\n     *\n     * ```\n     */\n    assertEntityHasArmor(\n        entityTypeIdentifier: string,\n        armorSlot: number,\n        armorName: string,\n        armorData: number,\n        blockLocation: BlockLocation,\n        hasArmor?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that an entity has a particular component. If not, an\n     * exception is thrown.\n     * @param entityTypeIdentifier\n     * Identifier of the specified entity (e.g.,\n     * 'minecraft:skeleton'). If the namespace is not specified,\n     * 'minecraft:' is assumed.\n     * @param componentIdentifier\n     * Identifier of the component to check for. If the namespace\n     * is not specified, 'minecraft:' is assumed.\n     * @param blockLocation\n     * Location of the block with a container (for example, a\n     * chest.)\n     * @param hasComponent\n     * Determines whether to test that the component exists, or\n     * does not.\n     * @throws This function can throw errors.\n     * @example sheepShearedTest.js\n     * ```typescript\n     *        test.assertEntityHasComponent(\"minecraft:sheep\", \"minecraft:is_sheared\", entityLoc, false);\n     *\n     * ```\n     */\n    assertEntityHasComponent(\n        entityTypeIdentifier: string,\n        componentIdentifier: string,\n        blockLocation: BlockLocation,\n        hasComponent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Depending on the value for isPresent, tests that a\n     * particular entity is present or not present at the specified\n     * location. Depending on the value of isPresent, if the entity\n     * is found or not found, an error is thrown.\n     * @param entity\n     * Specific entity to test for.\n     * @param blockLocation\n     * Location of the entity to test for.\n     * @param isPresent\n     * Whether to test that an entity is present or not present at\n     * the specified location.\n     * @throws This function can throw errors.\n     */\n    assertEntityInstancePresent(\n        entity: Entity,\n        blockLocation: BlockLocation,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Depending on the value of isPresent, tests for the presence\n     * or non-presence of entity of a specified type at a\n     * particular location. If the condition is not met, an\n     * exception is thrown.\n     * @param entityTypeIdentifier\n     * Type of entity to test for (e.g., 'minecraft:skeleton'). If\n     * an entity namespace is not specified, 'minecraft:' is\n     * assumed.\n     * @param blockLocation\n     * Location of the entity to test for.\n     * @param isPresent\n     * If true, this function tests whether an entity of the\n     * specified type is present. If false, tests that an entity of\n     * the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    assertEntityPresent(\n        entityTypeIdentifier: string,\n        blockLocation: BlockLocation,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that an entity of a specified type is present within\n     * the GameTest area. If not, an exception is thrown.\n     * @param entityTypeIdentifier\n     * Type of entity to test for (e.g., 'minecraft:skeleton'). If\n     * an entity namespace is not specified, 'minecraft:' is\n     * assumed.\n     * @param isPresent\n     * If true, this function tests whether an entity of the\n     * specified type is present in the GameTest area. If false,\n     * tests that an entity of the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    assertEntityPresentInArea(entityTypeIdentifier: string, isPresent?: boolean): void;\n    /**\n     * @remarks\n     * Tests that an entity (e.g., a skeleton) at the specified\n     * location has a particular piece of data. If not, an error is\n     * thrown.\n     * @param blockLocation\n     * Location of the entity to look for.\n     * @param entityTypeIdentifier\n     * Identifier of the entity (e.g., 'minecraft:skeleton') to\n     * look for. Note if no namespace is specified, 'minecraft:' is\n     * assumed.\n     * @param callback\n     * Callback function where facets of the selected entity can be\n     * tested for. If this callback function returns false or no\n     * entity with the specified identifier is found, an exception\n     * is thrown.\n     * @throws This function can throw errors.\n     * @example villagerEffectTest.js\n     * ```typescript\n     *        test.assertEntityState(\n     *          villagerPos,\n     *          \"minecraft:villager_v2\",\n     *          (entity) => entity.getEffect(MinecraftEffectTypes.regeneration).duration > 120\n     *        ); // At least 6 seconds remaining in the villagers' effect\n     *\n     * ```\n     */\n    assertEntityState(\n        blockLocation: BlockLocation,\n        entityTypeIdentifier: string,\n        callback: (arg: Entity) => boolean,\n    ): void;\n    /**\n     * @remarks\n     * Depending on the value of isTouching, tests that an entity\n     * of a specified type is touching or connected to another\n     * entity. If the condition is not met, an exception is thrown.\n     * @param entityTypeIdentifier\n     * Type of entity to test for (e.g., 'minecraft:skeleton'). If\n     * an entity namespace is not specified, 'minecraft:' is\n     * assumed.\n     * @param location\n     * Location of the entity to test for.\n     * @param isTouching\n     * If true, this function tests whether the entity is touching\n     * the specified location. If false, tests that an entity is\n     * not testing the specified location.\n     * @throws This function can throw errors.\n     */\n    assertEntityTouching(entityTypeIdentifier: string, location: Location, isTouching?: boolean): void;\n    /**\n     * @remarks\n     * Depending on the value of isWaterlogged, tests that a block\n     * at a location contains water. If the condition is not met,\n     * an error is thrown. Pure water blocks are not considered to\n     * be waterlogged.\n     * @param blockLocation\n     * Location of the block to test for.\n     * @param isWaterlogged\n     * Whether to test that the block at _position_ is expected to\n     * be waterlogged.\n     * @throws This function can throw errors.\n     */\n    assertIsWaterlogged(blockLocation: BlockLocation, isWaterlogged?: boolean): void;\n    /**\n     * @remarks\n     * Tests that items of a particular type and count are present\n     * within an area. If not, an error is thrown.\n     * @param itemType\n     * Type of item to look for.\n     * @param blockLocation\n     * Location to search around for the specified set of items.\n     * @param searchDistance\n     * Range, in blocks, to aggregate a count of items around. If\n     * 0, will only search the particular block at _position_.\n     * @param count\n     * Number of items, at minimum, to look and test for.\n     * @throws This function can throw errors.\n     * @example findFeathers.js\n     * ```typescript\n     *        test.assertItemEntityCountIs(Items.feather, expectedFeatherLoc, 0, 1);\n     *\n     * ```\n     */\n    assertItemEntityCountIs(\n        itemType: ItemType,\n        blockLocation: BlockLocation,\n        searchDistance: number,\n        count: number,\n    ): void;\n    /**\n     * @remarks\n     * Depending on the value of isPresent, tests whether a\n     * particular item entity is present or not at a particular\n     * location. If the condition is not met, an exception is\n     * thrown.\n     * @param itemType\n     * Type of item to test for.\n     * @param blockLocation\n     * Location of the item entity to test for.\n     * @param searchDistance\n     * Radius in blocks to look for the item entity.\n     * @param isPresent\n     * If true, this function tests whether an item entity of the\n     * specified type is present. If false, tests that an item\n     * entity of the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    assertItemEntityPresent(\n        itemType: ItemType,\n        blockLocation: BlockLocation,\n        searchDistance: number,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests that Redstone power at a particular location matches a\n     * particular value. If not, an exception is thrown.\n     * @param blockLocation\n     * Location to test.\n     * @param power\n     * Expected power level.\n     * @throws This function can throw errors.\n     */\n    assertRedstonePower(blockLocation: BlockLocation, power: number): void;\n    /**\n     * @remarks\n     * Marks the current test as a failure case.\n     * @param errorMessage\n     * Error message summarizing the failure condition.\n     * @throws This function can throw errors.\n     */\n    fail(errorMessage: string): void;\n    /**\n     * @remarks\n     * Runs the given callback. If the callback does not throw an\n     * exception, the test is marked as a failure.\n     * @param callback\n     * Callback function that runs. If the function runs\n     * successfully, the test is marked as a failure. Typically,\n     * this function will have .assertXyz method calls within it.\n     * @throws This function can throw errors.\n     */\n    failIf(callback: () => void): void;\n    /**\n     * @remarks\n     * Gets a block at the specified block location.\n     * @param blockLocation\n     * Location of the block to retrieve.\n     * @throws This function can throw errors.\n     */\n    getBlock(blockLocation: BlockLocation): Block;\n    /**\n     * @remarks\n     * Gets the dimension of this test.\n     * @throws This function can throw errors.\n     */\n    getDimension(): Dimension;\n    /**\n     * @remarks\n     * If the block at the specified block location is a fence,\n     * this returns a helper object with details on how a fence is\n     * connected.\n     * @param blockLocation\n     * Location of the block to retrieve.\n     * @throws This function can throw errors.\n     */\n    getFenceConnectivity(blockLocation: BlockLocation): FenceConnectivity;\n    /**\n     * @remarks\n     * Returns the direction of the current test - see the\n     * {@link mojang-minecraft}.Direction enum for more information on\n     * potential values (north, east, south, west - values 2-5).\n     */\n    getTestDirection(): Direction;\n    /**\n     * @remarks\n     * This asynchronous function will wait for the specified time\n     * in ticks before continuing execution.\n     * @param tickDelay\n     * Amount of time to wait, in ticks.\n     */\n    idle(tickDelay: number): Promise<void>;\n    /**\n     * @remarks\n     * Kills all entities within the GameTest structure.\n     * @throws This function can throw errors.\n     */\n    killAllEntities(): void;\n    /**\n     * @remarks\n     * Presses a button at a block location.\n     * @param blockLocation\n     * Location to push the button at.\n     * @throws\n     * Will throw an error if a button is not present at the\n     * specified position.\n     */\n    pressButton(blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * Displays the specified message to all players.\n     * @param text\n     * Message to display.\n     * @throws This function can throw errors.\n     */\n    print(text: string): void;\n    /**\n     * @remarks\n     * Pulls a lever at a block location.\n     * @param blockLocation\n     * Location to pull the lever at.\n     * @throws\n     * Will throw an error if a lever is not present at the\n     * specified position.\n     */\n    pullLever(blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * Sends a Redstone pulse at a particular location by creating\n     * a temporary Redstone block.\n     * @param blockLocation\n     * Location to pulse Redstone at.\n     * @param duration\n     * Number of ticks to pulse Redstone.\n     * @throws This function can throw errors.\n     */\n    pulseRedstone(blockLocation: BlockLocation, duration: number): void;\n    /**\n     * @remarks\n     * From a BlockLocation, returns a new BlockLocation with\n     * coordinates relative to the current GameTest structure\n     * block. For example, the relative coordinates for the block\n     * above the structure block are (0, 1, 0). Rotation of the\n     * GameTest structure is also taken into account.\n     * @param worldBlockLocation\n     * Absolute location in the world to convert to a relative\n     * location.\n     * @returns\n     * A location relative to the GameTest command block.\n     * @throws This function can throw errors.\n     */\n    relativeBlockLocation(worldBlockLocation: BlockLocation): BlockLocation;\n    /**\n     * @remarks\n     * From a location, returns a new location with coordinates\n     * relative to the current GameTest structure block. For\n     * example, the relative coordinates for the block above the\n     * structure block are (0, 1, 0). Rotation of the GameTest\n     * structure is also taken into account.\n     * @param worldLocation\n     * Absolute location in the world to convert to a relative\n     * location.\n     * @returns\n     * A location relative to the GameTest command block.\n     * @throws This function can throw errors.\n     */\n    relativeLocation(worldLocation: Location): Location;\n    /**\n     * @remarks\n     * Removes a simulated player from the world.\n     * @param simulatedPlayer\n     * Simulated player to remove.\n     */\n    removeSimulatedPlayer(simulatedPlayer: SimulatedPlayer): void;\n    /**\n     * @remarks\n     * Returns a relative direction given the current rotation of\n     * the current test. Passing in Direction.south will return the\n     * test direction; Passing in Direction.north will return the\n     * opposite of the test direction, and so on.\n     * @param direction\n     * Direction to translate into a direction relative to the\n     * GameTest facing. Passing in Direction.south will return the\n     * test direction; Passing in Direction.north will return the\n     * opposite of the test direction, and so on.\n     * @throws This function can throw errors.\n     */\n    rotateDirection(direction: Direction): Direction;\n    /**\n     * @remarks\n     * Returns a relative vector given the current rotation of\n     * the current test. Passing in vector.south will return the\n     * test vector; Passing in vector.north will return the\n     * opposite of the test vector, and so on.\n     * @param vector\n     * vector to translate into a vector relative to the\n     * GameTest facing. Passing in vector.south will return the\n     * test vector; Passing in vector.north will return the\n     * opposite of the test vector, and so on.\n     * @throws This function can throw errors.\n     */\n    rotateVector(vector: Vector): Vector;\n    /**\n     * @remarks\n     * Runs a specific callback after a specified delay of ticks\n     * @param delayTicks\n     * Number of ticks to delay before running the specified\n     * callback.\n     * @param callback\n     * Callback function to execute.\n     * @throws This function can throw errors.\n     */\n    runAfterDelay(delayTicks: number, callback: () => void): void;\n    /**\n     * @remarks\n     * Runs the given callback after a delay of _tick_ ticks from\n     * the start of the GameTest.\n     * @param tick\n     * Tick (after the start of the GameTest) to run the callback\n     * at.\n     * @param callback\n     * Callback function to execute.\n     * @throws This function can throw errors.\n     */\n    runAtTickTime(tick: number, callback: () => void): void;\n    /**\n     * @remarks\n     * Sets a block to a particular configuration (a\n     * BlockPermutation) at the specified block location.\n     * @param blockData\n     * Permutation that contains the configuration data for a\n     * block.\n     * @param blockLocation\n     * Location of the block to set.\n     * @throws This function can throw errors.\n     */\n    setBlockPermutation(\n        blockData: BlockPermutation,\n        blockLocation: BlockLocation,\n    ): void;\n    /**\n     * @remarks\n     * Sets a block to a particular type at the specified block\n     * location.\n     * @param blockType\n     * Type of block to set.\n     * @param blockLocation\n     * Location of the block to set.\n     * @throws This function can throw errors.\n     */\n    setBlockType(blockType: BlockType, blockLocation: BlockLocation): void;\n    /**\n     * @remarks\n     * For blocks that are fluid containers - like a cauldron -\n     * changes the type of fluid within that container.\n     * @param location\n     * Location of the fluid container block.\n     * @param type\n     * Type of fluid to set. See {@link mojang-gametest}.FluidType for a\n     * list of values.\n     * @throws This function can throw errors.\n     */\n    setFluidContainer(location: BlockLocation, type: number): void;\n    /**\n     * @remarks\n     * Sets the fuse of an explodable entity.\n     * @param entity\n     * Entity that is explodable.\n     * @param fuseLength\n     * Length of time, in ticks, before the entity explodes.\n     * @throws This function can throw errors.\n     */\n    setTntFuse(entity: Entity, fuseLength: number): void;\n    /**\n     * @remarks\n     * Spawns an entity at a location.\n     * @param entityTypeIdentifier\n     * Type of entity to create. If no namespace is provided,\n     * 'minecraft:' is assumed. Note that an optional initial spawn\n     * event can be specified between less than/greater than signs\n     * (e.g., namespace:entityType<spawnEvent>).\n     * @param blockLocation\n     * @returns\n     * The spawned entity. If the entity cannot be spawned, returns\n     * undefined.\n     * @throws This function can throw errors.\n     * @example spawnAdultPig.js\n     * ```typescript\n     *        test.spawn(\"minecraft:pig<minecraft:ageable_grow_up>\", new BlockLocation(1, 2, 1));\n     *\n     * ```\n     */\n    spawn(entityTypeIdentifier: string, blockLocation: BlockLocation): Entity;\n    /**\n     * @remarks\n     * Spawns an entity at a location.\n     * @param entityTypeIdentifier\n     * Type of entity to create. If no namespace is provided,\n     * 'minecraft:' is assumed. Note that an optional initial spawn\n     * event can be specified between less than/greater than signs\n     * (e.g., namespace:entityType<spawnEvent>).\n     * @param location\n     * @returns\n     * The spawned entity. If the entity cannot be spawned, returns\n     * undefined.\n     * @throws This function can throw errors.\n     * @example spawnAdultPig.js\n     * ```typescript\n     *        test.spawn(\"minecraft:pig<minecraft:ageable_grow_up>\", new Location(1.5, 2, 1.5));\n     * ```\n     */\n    spawnAtLocation(entityTypeIdentifier: string, location: Location): Entity;\n    /**\n     * @remarks\n     * Spawns an item entity at a specified location.\n     * @param itemStack\n     * ItemStack that describes the item entity to create.\n     * @param location\n     * Location to create the item entity at.\n     * @throws This function can throw errors.\n     * @example spawnEmeralds.js\n     * ```typescript\n     *        const oneEmerald = new ItemStack(MinecraftItemTypes.emerald, 1, 0);\n     *        const fiveEmeralds = new ItemStack(MinecraftItemTypes.emerald, 5, 0);\n     *\n     *        test.spawnItem(oneEmerald, new Location(3.5, 3, 1.5));\n     *        test.spawnItem(fiveEmeralds, new Location(1.5, 3, 1.5));\n     *\n     * ```\n     */\n    spawnItem(itemStack: ItemStack, location: Location): Entity;\n    /**\n     * @remarks\n     * Creates a new simulated player within the world.\n     * @param blockLocation\n     * Location where to spawn the simulated player.\n     * @param name\n     * Name to give the new simulated player.\n     * @param gameMode\n     * @throws This function can throw errors.\n     */\n    spawnSimulatedPlayer(\n        blockLocation: BlockLocation,\n        name?: string,\n        gameMode?: GameMode,\n    ): SimulatedPlayer;\n    /**\n     * @remarks\n     * Spawns an entity at a location without any AI behaviors.\n     * This method is frequently used in conjunction with methods\n     * like .walkTo to create predictable mob actions.\n     * @param entityTypeIdentifier\n     * @param blockLocation\n     * Location where the entity should be spawned.\n     * @throws This function can throw errors.\n     */\n    spawnWithoutBehaviors(\n        entityTypeIdentifier: string,\n        blockLocation: BlockLocation,\n    ): Entity;\n    /**\n     * @remarks\n     * Spawns an entity at a location without any AI behaviors.\n     * This method is frequently used in conjunction with methods\n     * like .walkTo to create predictable mob actions.\n     * @param entityTypeIdentifier\n     * @param location\n     * Location where the entity should be spawned.\n     * @throws This function can throw errors.\n     */\n    spawnWithoutBehaviorsAtLocation(\n        entityTypeIdentifier: string,\n        location: Location,\n    ): Entity;\n    /**\n     * @remarks\n     * Tests that a particular item entity is present at a\n     * particular location. If not, an exception is thrown.\n     * @param blockLocation\n     * BlockLocation containing a multiface block.\n     * @param fromFace\n     * Face to spread from. This face must already be set.\n     * @param direction\n     * Direction to spread. Use the Minecraft.Direction enum to\n     * specify a direction.\n     * @throws This function can throw errors.\n     * @example spreadFromFaceTowardDirection.js\n     * ```typescript\n     *        test.spreadFromFaceTowardDirection(new BlockLocation(1, 2, 1), Direction.south, Direction.down);\n     * ```\n     */\n    spreadFromFaceTowardDirection(\n        blockLocation: BlockLocation,\n        fromFace: Direction,\n        direction: Direction,\n    ): void;\n    /**\n     * @remarks\n     * Creates a new GameTestSequence - A set of steps that play\n     * out sequentially within a GameTest.\n     * @returns\n     * A new GameTestSequence with chaining methods that facilitate\n     * creating a set of steps.\n     */\n    startSequence(): GameTestSequence;\n    /**\n     * @remarks\n     * Marks the current test as a success case.\n     * @throws This function can throw errors.\n     */\n    succeed(): void;\n    /**\n     * @remarks\n     * Runs the given callback. If the callback does not throw an\n     * exception, the test is marked as a success.\n     * @param callback\n     * Callback function that runs. If the function runs\n     * successfully, the test is marked as a success. Typically,\n     * this function will have .assertXyz method calls within it.\n     * @throws This function can throw errors.\n     */\n    succeedIf(callback: () => void): void;\n    /**\n     * @remarks\n     * Marks the test as a success at the specified tick.\n     * @param tick\n     * Tick after the start of the GameTest to mark the test as\n     * successful.\n     * @throws This function can throw errors.\n     */\n    succeedOnTick(tick: number): void;\n    /**\n     * @remarks\n     * Runs the given callback at _tick_ ticks after the start of\n     * the test. If the callback does not throw an exception, the\n     * test is marked as a failure.\n     * @param tick\n     * Tick after the start of the GameTest to run the testing\n     * callback at.\n     * @param callback\n     * Callback function that runs. If the function runs\n     * successfully, the test is marked as a success.\n     * @throws This function can throw errors.\n     */\n    succeedOnTickWhen(tick: number, callback: () => void): void;\n    /**\n     * @remarks\n     * Runs the given callback every tick. When the callback\n     * successfully executes, the test is marked as a success.\n     * Specifically, the test will succeed when the callback does\n     * not throw an exception.\n     * @param callback\n     * Testing callback function that runs. If the function runs\n     * successfully, the test is marked as a success.\n     * @throws This function can throw errors.\n     */\n    succeedWhen(callback: () => void): void;\n    /**\n     * @remarks\n     * Depending on the condition of isPresent, tests for the\n     * presence of a block of a particular type on every tick. When\n     * the specified block of a type is found or not found\n     * (depending on isPresent), the test is marked as a success.\n     * @param blockType\n     * Type of block to test for.\n     * @param blockLocation\n     * Location of the block to test at.\n     * @param isPresent\n     * If true, this function tests whether a block of the\n     * specified type is present. If false, tests that a block of\n     * the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    succeedWhenBlockPresent(\n        blockType: BlockType,\n        blockLocation: BlockLocation,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Tests for the presence of a component on every tick.\n     * Depending on the value of hasComponent, when the specified\n     * component is found, the test is marked as a success.\n     * @param entityTypeIdentifier\n     * Type of entity to look for. If no namespace is specified,\n     * 'minecraft:' is assumed.\n     * @param componentIdentifier\n     * Type of component to test for the presence of. If no\n     * namespace is specified, 'minecraft:' is assumed.\n     * @param blockLocation\n     * Block location of the entity to test.\n     * @param hasComponent\n     * If true, this function tests for the presence of a\n     * component. If false, this function tests for the lack of a\n     * component.\n     * @throws This function can throw errors.\n     */\n    succeedWhenEntityHasComponent(\n        entityTypeIdentifier: string,\n        componentIdentifier: string,\n        blockLocation: BlockLocation,\n        hasComponent: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Depending on the value of isPresent, tests for the presence\n     * of an entity on every tick. When an entity of the specified\n     * type is found or not found (depending on isPresent), the\n     * test is marked as a success.\n     * @param entityTypeIdentifier\n     * Type of entity to test for (e.g., 'minecraft:skeleton'). If\n     * an entity namespace is not specified, 'minecraft:' is\n     * assumed.\n     * @param blockLocation\n     * Location of the entity to test for.\n     * @param isPresent\n     * If true, this function tests whether an entity of the\n     * specified type is present. If false, tests that an entity of\n     * the specified type is not present.\n     * @throws This function can throw errors.\n     */\n    succeedWhenEntityPresent(\n        entityTypeIdentifier: string,\n        blockLocation: BlockLocation,\n        isPresent?: boolean,\n    ): void;\n    /**\n     * @remarks\n     * Triggers a block event from a fixed list of available block\n     * events.\n     * @param blockLocation\n     * @param event\n     * Event to trigger. Valid values include minecraft:drip,\n     * minecraft:grow_stalagtite, minecraft:grow_stalagmite,\n     * minecraft:grow_up, minecraft:grow_down and\n     * minecraft:grow_sideways.\n     * @param eventParameters\n     * @throws This function can throw errors.\n     */\n    triggerInternalBlockEvent(\n        blockLocation: BlockLocation,\n        event: string,\n        eventParameters?: number[],\n    ): void;\n    /**\n     * @remarks\n     * This asynchronous function will wait until the code in the\n     * specified callback successfully completes. until can be used\n     * in conjunction with .assert functions to evaluate that a\n     * condition is true.\n     * @param callback\n     * Function with code to evaluate.\n     */\n    until(callback: () => void): Promise<void>;\n    /**\n     * @remarks\n     * Forces a mob to walk to a particular location. Usually used\n     * in conjunction with methods like .spawnWithoutBehaviors to\n     * have more predictable mob behaviors. Mobs will stop\n     * navigation as soon as they intersect the target location.\n     * @param mob\n     * Mob entity to give orders to.\n     * @param blockLocation\n     * Location where the entity should be walk to.\n     * @param speedModifier\n     * Adjustable modifier to the mob's walking speed.\n     * @throws This function can throw errors.\n     */\n    walkTo(mob: Entity, blockLocation: BlockLocation, speedModifier?: number): void;\n    /**\n     * @remarks\n     * Forces a mob to walk to a particular location. Usually used\n     * in conjunction with methods like .spawnWithoutBehaviors to\n     * have more predictable mob behaviors. Mobs will stop\n     * navigation as soon as they intersect the target location.\n     * @param mob\n     * Mob entity to give orders to.\n     * @param location\n     * Location where the entity should be walk to.\n     * @param speedModifier\n     * Adjustable modifier to the mob's walking speed.\n     * @throws This function can throw errors.\n     */\n    walkToLocation(mob: Entity, location: Location, speedModifier?: number): void;\n    /**\n     * @remarks\n     * From a BlockLocation with coordinates relative to the\n     * GameTest structure block, returns a new BlockLocation with\n     * coordinates relative to world. Rotation of the GameTest\n     * structure is also taken into account.\n     * @param relativeBlockLocation\n     * Location relative to the GameTest command block.\n     * @returns\n     * An absolute location relative to the GameTest command block.\n     * @throws This function can throw errors.\n     */\n    worldBlockLocation(relativeBlockLocation: BlockLocation): BlockLocation;\n    /**\n     * @remarks\n     * From a location with coordinates relative to the GameTest\n     * structure block, returns a new location with coordinates\n     * relative to world. Rotation of the GameTest structure is\n     * also taken into account.\n     * @param relativeLocation\n     * Location relative to the GameTest command block.\n     * @returns\n     * An absolute location relative to the GameTest command block.\n     * @throws This function can throw errors.\n     */\n    worldLocation(relativeLocation: Location): Location;\n}\n/**\n * @remarks\n * Registers a new GameTest function. This GameTest will become\n * available in Minecraft via /gametest run\n * [testClassName]:[testName].\n * @param testClassName\n * Name of the class of tests this test should be a part of.\n * @param testName\n * Name of this specific test.\n * @param testFunction\n * Implementation of the test function.\n * @returns\n * Returns a {@link mojang-gametest.RegistrationBuilder} object where\n * additional options for this test can be specified via\n * builder methods.\n * @example example1.js\n * ```typescript\n *        GameTest.register(\"ExampleTests\", \"alwaysFail\", (test) => {\n *          test.fail(\"This test, runnable via '/gametest run ExampleTests:alwaysFail', will always fail\");\n *        });\n *\n * ```\n */\ndeclare function register(\n    testClassName: string,\n    testName: string,\n    testFunction: (arg: Test) => void,\n): RegistrationBuilder;\n/**\n * @remarks\n * Registers a new GameTest function that is designed for\n * asynchronous execution. This GameTest will become available\n * in Minecraft via /gametest run [testClassName]:[testName].\n * @param testClassName\n * Name of the class of tests this test should be a part of.\n * @param testName\n * Name of this specific test.\n * @param testFunction\n * Implementation of the test function.\n * @returns\n * Returns a {@link mojang-gametest.RegistrationBuilder} object where\n * additional options for this test can be specified via\n * builder methods.\n */\ndeclare function registerAsync(\n    testClassName: string,\n    testName: string,\n    testFunction: (arg: Test) => Promise<void>,\n): RegistrationBuilder;";export const Namespace="declare namespace mojanggametest {\n    export enum FluidType { water = 0, lava = 1, powderSnow = 2, potion = 3, }\n    export class FenceConnectivity { readonly 'east': boolean; readonly 'north': boolean; readonly 'south': boolean; readonly 'west': boolean; }\n    export class GameTestSequence { thenExecute(callback: () => void): GameTestSequence; thenExecuteAfter(delayTicks: number, callback: () => void): GameTestSequence; thenExecuteFor(tickCount: number, callback: () => void): GameTestSequence; thenFail(errorMessage: string): void; thenIdle(delayTicks: number): GameTestSequence; thenSucceed(): void; thenWait(callback: () => void): GameTestSequence; thenWaitAfter(delayTicks: number, callback: () => void): GameTestSequence; }\n    export class RegistrationBuilder { batch(batchName: 'night' | 'day'): RegistrationBuilder; maxAttempts(attemptCount: number): RegistrationBuilder; maxTicks(tickCount: number): RegistrationBuilder; padding(paddingBlocks: number): RegistrationBuilder; required(isRequired: boolean): RegistrationBuilder; requiredSuccessfulAttempts(attemptCount: number): RegistrationBuilder; rotateTest(rotate: boolean): RegistrationBuilder; setupTicks(tickCount: number): RegistrationBuilder; structureName(structureName: string): RegistrationBuilder; tag(tag: string): RegistrationBuilder; }\n    export class SimulatedPlayer extends mojangminecraft.Player { readonly 'bodyRotation': number; readonly 'dimension': mojangminecraft.Dimension; readonly 'headLocation': mojangminecraft.Location; readonly 'headRotation': mojangminecraft.XYRotation; readonly 'id': string; 'isSneaking': boolean; readonly 'location': mojangminecraft.Location; readonly 'name': string; 'nameTag': string; 'selectedSlot': number; 'target': mojangminecraft.Entity; readonly 'velocity': mojangminecraft.Vector; readonly 'viewVector': mojangminecraft.Vector; addEffect(effectType: mojangminecraft.EffectType, duration: number, amplifier: number): void; addTag(tag: string): boolean; attack(): boolean; attackEntity(entity: mojangminecraft.Entity): boolean; breakBlock(blockLocation: mojangminecraft.BlockLocation, direction?: number): boolean; getBlockFromViewVector(options?: mojangminecraft.BlockRaycastOptions): mojangminecraft.Block; getComponent: EntityComponents; getComponents(): mojangminecraft.IEntityComponent[]; getEffect(effectType: mojangminecraft.EffectType): mojangminecraft.Effect; getEntitiesFromViewVector(options?: mojangminecraft.EntityRaycastOptions): mojangminecraft.Entity[]; getItemCooldown(itemCategory: string): number; getTags(): string[]; giveItem(itemStack: mojangminecraft.ItemStack, selectSlot?: boolean): boolean; hasComponent(componentId: string): boolean; hasTag(tag: string): boolean; interact(): boolean; interactWithBlock(blockLocation: mojangminecraft.BlockLocation, direction?: number): boolean; interactWithEntity(entity: mojangminecraft.Entity): boolean; jump(): boolean; kill(): void; lookAtBlock(blockLocation: mojangminecraft.BlockLocation): void; lookAtEntity(entity: mojangminecraft.Entity): void; lookAtLocation(location: mojangminecraft.Location): void; move(westEast: number, northSouth: number, speed?: number): void; moveRelative(leftRight: number, backwardForward: number, speed?: number): void; moveToBlock(blockLocation: mojangminecraft.BlockLocation, speed?: number): void; moveToLocation(location: mojangminecraft.Location, speed?: number): void; navigateToBlock(blockLocation: mojangminecraft.BlockLocation, speed?: number): mojangminecraft.NavigationResult; navigateToEntity(entity: mojangminecraft.Entity, speed?: number): mojangminecraft.NavigationResult; navigateToLocation(location: mojangminecraft.Location, speed?: number): mojangminecraft.NavigationResult; navigateToLocations(locations: mojangminecraft.Location[], speed?: number): void; playSound(soundID: string, soundOptions?: mojangminecraft.SoundOptions): void; removeTag(tag: string): boolean; rotateBody(angleInDegrees: number): void; runCommand(commandString: string): any; setBodyRotation(angleInDegrees: number): void; setGameMode(gameMode: mojangminecraft.GameMode): void; setItem(itemStack: mojangminecraft.ItemStack, slot: number, selectSlot?: boolean): boolean; setVelocity(velocity: mojangminecraft.Vector): void; startItemCooldown(itemCategory: string, tickDuration: number): void; stopBreakingBlock(): void; stopInteracting(): void; stopMoving(): void; stopUsingItem(): void; teleport(location: mojangminecraft.Location, dimension: mojangminecraft.Dimension, xRotation: number, yRotation: number,): void; teleportFacing(location: mojangminecraft.Location, dimension: mojangminecraft.Dimension, facingLocation: mojangminecraft.Location,): void; triggerEvent(eventName: string): void; useItem(itemStack: mojangminecraft.ItemStack): boolean; useItemInSlot(slot: number): boolean; useItemInSlotOnBlock(slot: number, blockLocation: mojangminecraft.BlockLocation, direction?: number, faceLocationX?: number, faceLocationY?: number,): boolean; useItemOnBlock(itemStack: mojangminecraft.ItemStack, blockLocation: mojangminecraft.BlockLocation, direction?: number, faceLocationX?: number, faceLocationY?: number,): boolean; }\n    export class Tags { static readonly 'suiteAll' = 'suite:all'; static readonly 'suiteDebug' = 'suite:debug'; static readonly 'suiteDefault' = 'suite:default'; static readonly 'suiteDisabled' = 'suite:disabled'; }\n    export class Test { assert(condition: boolean, message: string): void; assertBlockPresent(blockType: mojangminecraft.BlockType, blockLocation: mojangminecraft.BlockLocation, isPresent?: boolean,): void; assertBlockState(blockLocation: mojangminecraft.BlockLocation, callback: (arg: mojangminecraft.Block) => boolean,): void; assertCanReachLocation(mob: mojangminecraft.Entity, blockLocation: mojangminecraft.BlockLocation, canReach?: boolean,): void; assertContainerContains(itemStack: mojangminecraft.ItemStack, blockLocation: mojangminecraft.BlockLocation): void; assertContainerEmpty(blockLocation: mojangminecraft.BlockLocation): void; assertEntityHasArmor(entityTypeIdentifier: string, armorSlot: number, armorName: string, armorData: number, blockLocation: mojangminecraft.BlockLocation, hasArmor?: boolean,): void; assertEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: mojangminecraft.BlockLocation, hasComponent?: boolean,): void; assertEntityInstancePresent(entity: mojangminecraft.Entity, blockLocation: mojangminecraft.BlockLocation, isPresent?: boolean,): void; assertEntityPresent(entityTypeIdentifier: string, blockLocation: mojangminecraft.BlockLocation, isPresent?: boolean,): void; assertEntityPresentInArea(entityTypeIdentifier: string, isPresent?: boolean): void; assertEntityState(blockLocation: mojangminecraft.BlockLocation, entityTypeIdentifier: string, callback: (arg: mojangminecraft.Entity) => boolean,): void; assertEntityTouching(entityTypeIdentifier: string, location: mojangminecraft.Location, isTouching?: boolean): void; assertIsWaterlogged(blockLocation: mojangminecraft.BlockLocation, isWaterlogged?: boolean): void; assertItemEntityCountIs(itemType: mojangminecraft.ItemType, blockLocation: mojangminecraft.BlockLocation, searchDistance: number, count: number,): void; assertItemEntityPresent(itemType: mojangminecraft.ItemType, blockLocation: mojangminecraft.BlockLocation, searchDistance: number, isPresent?: boolean,): void; assertRedstonePower(blockLocation: mojangminecraft.BlockLocation, power: number): void; fail(errorMessage: string): void; failIf(callback: () => void): void; getBlock(blockLocation: mojangminecraft.BlockLocation): mojangminecraft.Block; getDimension(): mojangminecraft.Dimension; getFenceConnectivity(blockLocation: mojangminecraft.BlockLocation): FenceConnectivity; getTestDirection(): mojangminecraft.Direction; idle(tickDelay: number): Promise<void>; killAllEntities(): void; pressButton(blockLocation: mojangminecraft.BlockLocation): void; print(text: string): void; pullLever(blockLocation: mojangminecraft.BlockLocation): void; pulseRedstone(blockLocation: mojangminecraft.BlockLocation, duration: number): void; relativeBlockLocation(worldBlockLocation: mojangminecraft.BlockLocation): mojangminecraft.BlockLocation; relativeLocation(worldLocation: mojangminecraft.Location): mojangminecraft.Location; removeSimulatedPlayer(simulatedPlayer: SimulatedPlayer): void; rotateDirection(direction: mojangminecraft.Direction): mojangminecraft.Direction; rotateVector(vector: mojangminecraft.Vector): mojangminecraft.Vector; runAfterDelay(delayTicks: number, callback: () => void): void; runAtTickTime(tick: number, callback: () => void): void; setBlockPermutation(blockData: mojangminecraft.BlockPermutation, blockLocation: mojangminecraft.BlockLocation,): void; setBlockType(blockType: mojangminecraft.BlockType, blockLocation: mojangminecraft.BlockLocation): void; setFluidContainer(location: mojangminecraft.BlockLocation, type: number): void; setTntFuse(entity: mojangminecraft.Entity, fuseLength: number): void; spawn(entityTypeIdentifier: string, blockLocation: mojangminecraft.BlockLocation): mojangminecraft.Entity; spawnAtLocation(entityTypeIdentifier: string, location: mojangminecraft.Location): mojangminecraft.Entity; spawnItem(itemStack: mojangminecraft.ItemStack, location: mojangminecraft.Location): mojangminecraft.Entity; spawnSimulatedPlayer(blockLocation: mojangminecraft.BlockLocation, name?: string, gameMode?: mojangminecraft.GameMode,): SimulatedPlayer; spawnWithoutBehaviors(entityTypeIdentifier: string, blockLocation: mojangminecraft.BlockLocation,): mojangminecraft.Entity; spawnWithoutBehaviorsAtLocation(entityTypeIdentifier: string, location: mojangminecraft.Location,): mojangminecraft.Entity; spreadFromFaceTowardDirection(blockLocation: mojangminecraft.BlockLocation, fromFace: mojangminecraft.Direction, direction: mojangminecraft.Direction,): void; startSequence(): GameTestSequence; succeed(): void; succeedIf(callback: () => void): void; succeedOnTick(tick: number): void; succeedOnTickWhen(tick: number, callback: () => void): void; succeedWhen(callback: () => void): void; succeedWhenBlockPresent(blockType: mojangminecraft.BlockType, blockLocation: mojangminecraft.BlockLocation, isPresent?: boolean,): void; succeedWhenEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: mojangminecraft.BlockLocation, hasComponent: boolean,): void; succeedWhenEntityPresent(entityTypeIdentifier: string, blockLocation: mojangminecraft.BlockLocation, isPresent?: boolean,): void; triggerInternalBlockEvent(blockLocation: mojangminecraft.BlockLocation, event: string, eventParameters?: number[],): void; until(callback: () => void): Promise<void>; walkTo(mob: mojangminecraft.Entity, blockLocation: mojangminecraft.BlockLocation, speedModifier?: number): void; walkToLocation(mob: mojangminecraft.Entity, location: mojangminecraft.Location, speedModifier?: number): void; worldBlockLocation(relativeBlockLocation: mojangminecraft.BlockLocation): mojangminecraft.BlockLocation; worldLocation(relativeLocation: mojangminecraft.Location): mojangminecraft.Location; }\n    export function register(testClassName: string, testName: string, testFunction: (arg: Test) => void,): RegistrationBuilder;\n    export function registerAsync(testClassName: string, testName: string, testFunction: (arg: Test) => Promise<void>,): RegistrationBuilder;\n}";